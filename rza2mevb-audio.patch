diff --git a/arch/arm/boot/dts/r7s9210-rza2mevb.dts b/arch/arm/boot/dts/r7s9210-rza2mevb.dts
old mode 100644
new mode 100755
index 73eb32fb5..8a83cd0d3
--- a/arch/arm/boot/dts/r7s9210-rza2mevb.dts
+++ b/arch/arm/boot/dts/r7s9210-rza2mevb.dts
@@ -293,6 +293,16 @@
 			<RZA2_PINMUX(PORT4, 7, 2)>; // TXCLKOUTM
 #endif
 	};
+
+	/* Audio ch 0 Pins */
+	audio_pins:  audio0 {
+		pinmux =
+			<RZA2_PINMUX(PORT9, 6, 5)>,	/* SSIBCK0 */
+			<RZA2_PINMUX(PORT9, 5, 5)>,	/* SSILRCK0 */
+			<RZA2_PINMUX(PORT9, 4, 5)>,	/* SSITxD0 */
+			<RZA2_PINMUX(PORT9, 3, 5)>,	/* SSIRxD0 */
+			<RZA2_PINMUX(PORT6, 4, 4)>;	/* AUDIO_CLK */
+	};
 };
 
 #if (CONSOLE == 1) || (ADDITIONAL_SERIAL == 1)
@@ -609,8 +619,16 @@
 #endif /* LVDS */
 
 /* ========== SPI Flash MTD File System Example ========== */
-#if 0
+&spi0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&spi0_pins>;
+	status = "okay";
+	dmas = 	<&dma0 RZADMA_SLAVE_RSPI0_TX>,
+		<&dma0 RZADMA_SLAVE_RSPI0_RX>;
+	dma-names = "tx", "rx";
+};
 
+#if 0
 /* RSPI0 was tested by hooking up a SPI flash to DRP Header.
  * SW6-2: ON (to enable RSPI pin on DRP header)
  * Requires:
@@ -632,10 +650,6 @@
  * $ mount -t jffs2 /dev/mtdblock1 /mnt
  */
 &spi0 {
-	pinctrl-names = "default";
-	pinctrl-0 = <&spi0_pins>;
-	status = "okay";
-
 	flash@0 {
 	/* 	compatible = "spansion,s25fl512s", "jedec,spi-nor"; */
 		compatible = "jedec,spi-nor";	/* let it auto-detect the flash */
@@ -669,7 +683,6 @@
 
 /* ========== SPI EEPROM Example ========== */
 #if 0
-
 /* On early RZ/A2M CPU boards, a SPI EEPROM (R1EX25002ASA00G) was populated and
  * connect to RSPI-0. Note that these pins conflicted with SDRAM.
  *
@@ -683,13 +696,6 @@
  *  $ hexdump -C -n 16 /sys/class/spi_master/spi0/spi0.0/eeprom
  */
 &spi0 {
-	pinctrl-names = "default";
-	pinctrl-0 = <&spi0_pins>;
-	dmas = 	<&dma0 RZADMA_SLAVE_RSPI0_TX>,
-			<&dma0 RZADMA_SLAVE_RSPI0_RX>;
-	dma-names = "tx", "rx";
-	status = "okay";
-
 	eeprom@0 {
 		compatible = "atmel,at25";	/* generic name */
 		reg = <0>;
@@ -705,18 +711,56 @@
 };
 #endif
 
+/* DMA Controller */
 &dma0  {
-		/*slave id for another device*/
-	slave_id=< RZADMA_SLAVE_RSPI0_TX
-			   RZADMA_SLAVE_RSPI0_RX>;
-		/* address of slave device*/
-	addr=< 0xe800c804
-		   0xe800c804>;
-		/*channel config (chcfg) for slave device, first for RSPI0_TX*/
-	chcfg=<	0x1 0x0 0x1 0x1 0x2 0x0 0x0 0x0	/*.reqd .loen .hien .lvl .am .sds .dds .tm*/
-			0x0 0x0 0x1 0x1 0x2 0x0 0x0 0x0>;
-		/*dmas for slave device, first for RSPI0_TX*/
-	dmars=<	0x1 0xb5 /*.rid .mid*/
-			0x2 0xb5>;
+	/* ID for slave device */
+	slave_id = <RZADMA_SLAVE_RSPI0_TX
+		    RZADMA_SLAVE_RSPI0_RX
+		    RZADMA_SLAVE_PCM_MEM_SSI0
+		    RZADMA_SLAVE_PCM_SSI0_MEM>;
+	/* address of slave device */
+	addr = <0xe800c804
+		0xe800c804
+		0xe8048018
+		0xe804801c>;
+	/* chcfg for slave device (reqd loen hien lvl am sds dds tm) */
+	chcfg = <0x1 0x0 0x1 0x1 0x2 0x0 0x0 0x0
+		 0x0 0x0 0x1 0x1 0x2 0x0 0x0 0x0
+		 0x1 0x0 0x1 0x0 0x2 0x1 0x1 0x0
+		 0x0 0x0 0x1 0x0 0x2 0x1 0x1 0x0>;
+	/* dmas for slave device (rid mid) */
+	dmars = <0x1 0xb5
+		 0x2 0xb5
+		 0x1 0x9c
+		 0x2 0x9c>;
+};
+
+/* ASoC Sound Support using SSIF */
+/* requires:
+ *  CONFIG_SOUND=y
+ *  CONFIG_SND=y
+ *  CONFIG_SND_SOC=y
+ *  CONFIG_SND_RZA2MEVB=y
+ *  CONFIG_RZA_DMA=y
+ */
+/ {
+	sound_machine: sound {
+		compatible = "renesas,rza2mevb_sound_alsa";
+	};
+
+	sound: rza2-pcm-audio@e8048000 {
+		compatible = "renesas,rza2mevb";
+		reg = <0xe8048000 0x00001828>;
+		channel = <0>;
+	};
 };
 
+&spi0 {
+	codec: codec@0 {
+		compatible = "wlf,wm8978";
+		reg = <0>;
+		spi-max-frequency = <1000000>;
+		pinctrl-names = "default";
+		pinctrl-0 = <&audio_pins>;
+	};
+};
diff --git a/arch/arm/boot/dts/r7s9210.dtsi b/arch/arm/boot/dts/r7s9210.dtsi
old mode 100644
new mode 100755
index 2ecae69e2..538b50716
--- a/arch/arm/boot/dts/r7s9210.dtsi
+++ b/arch/arm/boot/dts/r7s9210.dtsi
@@ -12,8 +12,11 @@
 #include <dt-bindings/interrupt-controller/irq.h>
 #include <dt-bindings/clock/r7s9210-cpg-mssr.h>
 
-#define RZADMA_SLAVE_RSPI0_TX 1
-#define RZADMA_SLAVE_RSPI0_RX 2
+#define RZADMA_SLAVE_PCM_MEM_SSI0 1
+#define RZADMA_SLAVE_PCM_SSI0_MEM 2
+#define RZADMA_SLAVE_PCM_MAX 3
+#define RZADMA_SLAVE_RSPI0_TX 4
+#define RZADMA_SLAVE_RSPI0_RX 5
 
 / {
 	compatible = "renesas,r7s9210";
@@ -445,23 +448,23 @@
 		compatible = "renesas,rza-dma";
 		reg = <0xe8220000 0x720>,
 			  <0xfcfe1000 0x20>;
-		interrupts = <GIC_SPI 13 IRQ_TYPE_LEVEL_HIGH>,
-					 <GIC_SPI 14 IRQ_TYPE_LEVEL_HIGH>,
-					 <GIC_SPI 15 IRQ_TYPE_LEVEL_HIGH>,
-					 <GIC_SPI 16 IRQ_TYPE_LEVEL_HIGH>,
-					 <GIC_SPI 17 IRQ_TYPE_LEVEL_HIGH>,
-					 <GIC_SPI 18 IRQ_TYPE_LEVEL_HIGH>,
-					 <GIC_SPI 19 IRQ_TYPE_LEVEL_HIGH>,
-					 <GIC_SPI 20 IRQ_TYPE_LEVEL_HIGH>,
-					 <GIC_SPI 21 IRQ_TYPE_LEVEL_HIGH>,
-					 <GIC_SPI 22 IRQ_TYPE_LEVEL_HIGH>,
-					 <GIC_SPI 23 IRQ_TYPE_LEVEL_HIGH>,
-					 <GIC_SPI 24 IRQ_TYPE_LEVEL_HIGH>,
-					 <GIC_SPI 25 IRQ_TYPE_LEVEL_HIGH>,
-					 <GIC_SPI 26 IRQ_TYPE_LEVEL_HIGH>,
-					 <GIC_SPI 27 IRQ_TYPE_LEVEL_HIGH>,
-					 <GIC_SPI 28 IRQ_TYPE_LEVEL_HIGH>,
-					 <GIC_SPI 29 IRQ_TYPE_LEVEL_HIGH>;
+		interrupts = <GIC_SPI 13 IRQ_TYPE_EDGE_RISING>,
+					 <GIC_SPI 14 IRQ_TYPE_EDGE_RISING>,
+					 <GIC_SPI 15 IRQ_TYPE_EDGE_RISING>,
+					 <GIC_SPI 16 IRQ_TYPE_EDGE_RISING>,
+					 <GIC_SPI 17 IRQ_TYPE_EDGE_RISING>,
+					 <GIC_SPI 18 IRQ_TYPE_EDGE_RISING>,
+					 <GIC_SPI 19 IRQ_TYPE_EDGE_RISING>,
+					 <GIC_SPI 20 IRQ_TYPE_EDGE_RISING>,
+					 <GIC_SPI 21 IRQ_TYPE_EDGE_RISING>,
+					 <GIC_SPI 22 IRQ_TYPE_EDGE_RISING>,
+					 <GIC_SPI 23 IRQ_TYPE_EDGE_RISING>,
+					 <GIC_SPI 24 IRQ_TYPE_EDGE_RISING>,
+					 <GIC_SPI 25 IRQ_TYPE_EDGE_RISING>,
+					 <GIC_SPI 26 IRQ_TYPE_EDGE_RISING>,
+					 <GIC_SPI 27 IRQ_TYPE_EDGE_RISING>,
+					 <GIC_SPI 28 IRQ_TYPE_EDGE_RISING>,
+					 <GIC_SPI 29 IRQ_TYPE_EDGE_RISING>;
 		interrupt-names = "ch0", "ch1", "ch2", "ch3",
 						  "ch4", "ch5", "ch6", "ch7",
 						  "ch8", "ch9", "ch10", "ch11",
diff --git a/arch/arm/configs/rza2mevb_xip_defconfig b/arch/arm/configs/rza2mevb_xip_defconfig
old mode 100644
new mode 100755
index 429180774..8558b3724
--- a/arch/arm/configs/rza2mevb_xip_defconfig
+++ b/arch/arm/configs/rza2mevb_xip_defconfig
@@ -1,86 +1,1097 @@
+#
+# Automatically generated file; DO NOT EDIT.
+# Linux/arm 4.19.19 Kernel Configuration
+#
+
+#
+# Compiler: arm-linux-gnueabihf-gcc (Linaro GCC 7.2-2017.11) 7.2.1 20171011
+#
+CONFIG_CC_IS_GCC=y
+CONFIG_GCC_VERSION=70201
+CONFIG_CLANG_VERSION=0
+CONFIG_IRQ_WORK=y
+CONFIG_BUILDTIME_EXTABLE_SORT=y
+
+#
+# General setup
+#
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+# CONFIG_COMPILE_TEST is not set
+CONFIG_LOCALVERSION=""
+CONFIG_LOCALVERSION_AUTO=y
+CONFIG_BUILD_SALT=""
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_XZ=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_HAVE_KERNEL_LZ4=y
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_LZMA is not set
+# CONFIG_KERNEL_XZ is not set
+# CONFIG_KERNEL_LZO is not set
+# CONFIG_KERNEL_LZ4 is not set
+CONFIG_DEFAULT_HOSTNAME="(none)"
+CONFIG_SWAP=y
 CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+CONFIG_CROSS_MEMORY_ATTACH=y
+# CONFIG_USELIB is not set
+# CONFIG_AUDIT is not set
+CONFIG_HAVE_ARCH_AUDITSYSCALL=y
+
+#
+# IRQ subsystem
+#
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_GENERIC_IRQ_SHOW=y
+CONFIG_GENERIC_IRQ_SHOW_LEVEL=y
+CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_IRQ_DOMAIN=y
+CONFIG_IRQ_DOMAIN_HIERARCHY=y
+CONFIG_HANDLE_DOMAIN_IRQ=y
+CONFIG_IRQ_FORCED_THREADING=y
+CONFIG_SPARSE_IRQ=y
+CONFIG_GENERIC_IRQ_MULTI_HANDLER=y
+CONFIG_ARCH_CLOCKSOURCE_DATA=y
+CONFIG_GENERIC_CLOCKEVENTS=y
+
+#
+# Timers subsystem
+#
+CONFIG_TICK_ONESHOT=y
 CONFIG_HZ_PERIODIC=y
+# CONFIG_NO_HZ_IDLE is not set
 CONFIG_NO_HZ=y
 CONFIG_HIGH_RES_TIMERS=y
+CONFIG_PREEMPT_NONE=y
+# CONFIG_PREEMPT_VOLUNTARY is not set
+# CONFIG_PREEMPT is not set
+
+#
+# CPU/Task time and stats accounting
+#
+CONFIG_TICK_CPU_ACCOUNTING=y
+# CONFIG_VIRT_CPU_ACCOUNTING_GEN is not set
+# CONFIG_IRQ_TIME_ACCOUNTING is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_TINY_RCU=y
+# CONFIG_RCU_EXPERT is not set
+CONFIG_SRCU=y
+CONFIG_TINY_SRCU=y
+CONFIG_BUILD_BIN2C=y
 CONFIG_IKCONFIG=y
 CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=17
+CONFIG_PRINTK_SAFE_LOG_BUF_SHIFT=13
+CONFIG_GENERIC_SCHED_CLOCK=y
+# CONFIG_CGROUPS is not set
+# CONFIG_NAMESPACES is not set
+# CONFIG_CHECKPOINT_RESTORE is not set
+# CONFIG_SCHED_AUTOGROUP is not set
+# CONFIG_SYSFS_DEPRECATED is not set
+# CONFIG_RELAY is not set
 CONFIG_BLK_DEV_INITRD=y
+CONFIG_INITRAMFS_SOURCE=""
+CONFIG_RD_GZIP=y
+CONFIG_RD_BZIP2=y
+CONFIG_RD_LZMA=y
+CONFIG_RD_XZ=y
+CONFIG_RD_LZO=y
+CONFIG_RD_LZ4=y
+# CONFIG_CC_OPTIMIZE_FOR_PERFORMANCE is not set
 CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+CONFIG_HAVE_UID16=y
+CONFIG_BPF=y
+CONFIG_EXPERT=y
+CONFIG_UID16=y
+CONFIG_MULTIUSER=y
+# CONFIG_SGETMASK_SYSCALL is not set
+CONFIG_SYSFS_SYSCALL=y
 CONFIG_SYSCTL_SYSCALL=y
+CONFIG_FHANDLE=y
+CONFIG_POSIX_TIMERS=y
+CONFIG_PRINTK=y
+CONFIG_PRINTK_NMI=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_FUTEX_PI=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_ADVISE_SYSCALLS=y
+CONFIG_MEMBARRIER=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_ALL is not set
+CONFIG_KALLSYMS_BASE_RELATIVE=y
+# CONFIG_BPF_SYSCALL is not set
+# CONFIG_USERFAULTFD is not set
+CONFIG_ARCH_HAS_MEMBARRIER_SYNC_CORE=y
+CONFIG_RSEQ=y
+# CONFIG_DEBUG_RSEQ is not set
 CONFIG_EMBEDDED=y
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_PERF_USE_VMALLOC=y
+# CONFIG_PC104 is not set
+
+#
+# Kernel Performance Events And Counters
+#
+# CONFIG_PERF_EVENTS is not set
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_COMPAT_BRK=y
 CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+CONFIG_SLAB_MERGE_DEFAULT=y
+# CONFIG_SLAB_FREELIST_RANDOM is not set
+# CONFIG_PROFILING is not set
+CONFIG_ARM=y
+CONFIG_ARM_HAS_SG_CHAIN=y
+CONFIG_MIGHT_HAVE_PCI=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_HAVE_PROC_CPU=y
+CONFIG_NO_IOPORT_MAP=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+CONFIG_FIX_EARLYCON_MEM=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_ARCH_SUPPORTS_UPROBES=y
 CONFIG_PHYS_OFFSET=0x40000000
+CONFIG_GENERIC_BUG=y
+CONFIG_PGTABLE_LEVELS=2
+
+#
+# System Type
+#
+CONFIG_MMU=y
+CONFIG_ARCH_MMAP_RND_BITS_MIN=8
+CONFIG_ARCH_MMAP_RND_BITS_MAX=16
+CONFIG_ARCH_MULTIPLATFORM=y
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_DOVE is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_LPC32XX is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C24XX is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP1 is not set
+
+#
+# Multiple platform selection
+#
+
+#
+# CPU Core family selection
+#
+# CONFIG_ARCH_MULTI_V6 is not set
+CONFIG_ARCH_MULTI_V7=y
+CONFIG_ARCH_MULTI_V6_V7=y
+# CONFIG_ARCH_VIRT is not set
+# CONFIG_ARCH_ACTIONS is not set
+# CONFIG_ARCH_ALPINE is not set
+# CONFIG_ARCH_ARTPEC is not set
+# CONFIG_ARCH_AT91 is not set
+# CONFIG_ARCH_BCM is not set
+# CONFIG_ARCH_BERLIN is not set
+# CONFIG_ARCH_DIGICOLOR is not set
+# CONFIG_ARCH_EXYNOS is not set
+# CONFIG_ARCH_HIGHBANK is not set
+# CONFIG_ARCH_HISI is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_KEYSTONE is not set
+# CONFIG_ARCH_MEDIATEK is not set
+# CONFIG_ARCH_MESON is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_MVEBU is not set
+# CONFIG_ARCH_NPCM is not set
+
+#
+# TI OMAP/AM/DM/DRA Family
+#
+# CONFIG_ARCH_OMAP3 is not set
+# CONFIG_ARCH_OMAP4 is not set
+# CONFIG_SOC_OMAP5 is not set
+# CONFIG_SOC_AM33XX is not set
+# CONFIG_SOC_AM43XX is not set
+# CONFIG_SOC_DRA7XX is not set
+# CONFIG_ARCH_SIRF is not set
+# CONFIG_ARCH_QCOM is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_ROCKCHIP is not set
+# CONFIG_ARCH_S5PV210 is not set
+CONFIG_ARCH_SHMOBILE=y
 CONFIG_ARCH_RENESAS=y
+# CONFIG_ARCH_EMEV2 is not set
+# CONFIG_ARCH_R7S72100 is not set
 CONFIG_ARCH_R7S9210=y
+# CONFIG_ARCH_R8A73A4 is not set
+# CONFIG_ARCH_R8A7740 is not set
+# CONFIG_ARCH_R8A7743 is not set
+# CONFIG_ARCH_R8A7745 is not set
+# CONFIG_ARCH_R8A77470 is not set
+# CONFIG_ARCH_R8A7778 is not set
+# CONFIG_ARCH_R8A7779 is not set
+# CONFIG_ARCH_R8A7790 is not set
+# CONFIG_ARCH_R8A7791 is not set
+# CONFIG_ARCH_R8A7792 is not set
+# CONFIG_ARCH_R8A7793 is not set
+# CONFIG_ARCH_R8A7794 is not set
+# CONFIG_ARCH_R9A06G032 is not set
+# CONFIG_ARCH_RZN1 is not set
+# CONFIG_ARCH_SH73A0 is not set
+
+#
+# Renesas RZ/A Board Support
+#
 CONFIG_MACH_RZA2MEVB=y
+# CONFIG_ARCH_SOCFPGA is not set
+# CONFIG_PLAT_SPEAR is not set
+# CONFIG_ARCH_STI is not set
+# CONFIG_ARCH_STM32 is not set
+# CONFIG_ARCH_SUNXI is not set
+# CONFIG_ARCH_TANGO is not set
+# CONFIG_ARCH_TEGRA is not set
+# CONFIG_ARCH_UNIPHIER is not set
+# CONFIG_ARCH_U8500 is not set
+# CONFIG_ARCH_VEXPRESS is not set
+# CONFIG_ARCH_WM8850 is not set
+# CONFIG_ARCH_ZX is not set
+# CONFIG_ARCH_ZYNQ is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_V7=y
+CONFIG_CPU_THUMB_CAPABLE=y
+CONFIG_CPU_32v6K=y
+CONFIG_CPU_32v7=y
+CONFIG_CPU_ABRT_EV7=y
+CONFIG_CPU_PABRT_V7=y
+CONFIG_CPU_CACHE_V7=y
+CONFIG_CPU_CACHE_VIPT=y
+CONFIG_CPU_COPY_V6=y
+CONFIG_CPU_TLB_V7=y
+CONFIG_CPU_HAS_ASID=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+# CONFIG_ARM_LPAE is not set
+CONFIG_ARM_THUMB=y
+# CONFIG_ARM_THUMBEE is not set
+CONFIG_ARM_VIRT_EXT=y
+# CONFIG_SWP_EMULATE is not set
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_BPREDICT_DISABLE is not set
+CONFIG_CPU_SPECTRE=y
+CONFIG_HARDEN_BRANCH_PREDICTOR=y
+CONFIG_KUSER_HELPERS=y
+# CONFIG_VDSO is not set
+CONFIG_OUTER_CACHE=y
+CONFIG_OUTER_CACHE_SYNC=y
+CONFIG_MIGHT_HAVE_CACHE_L2X0=y
+CONFIG_CACHE_L2X0=y
 CONFIG_PL310_ERRATA_588369=y
+# CONFIG_PL310_ERRATA_727915 is not set
+# CONFIG_PL310_ERRATA_753970 is not set
+# CONFIG_PL310_ERRATA_769419 is not set
+CONFIG_ARM_L1_CACHE_SHIFT_6=y
+CONFIG_ARM_L1_CACHE_SHIFT=6
+CONFIG_ARM_DMA_MEM_BUFFERABLE=y
+CONFIG_ARM_HEAVY_MB=y
+# CONFIG_ARM_ERRATA_430973 is not set
+# CONFIG_ARM_ERRATA_720789 is not set
 CONFIG_ARM_ERRATA_754322=y
+# CONFIG_ARM_ERRATA_775420 is not set
+# CONFIG_ARM_ERRATA_773022 is not set
+# CONFIG_ARM_ERRATA_818325_852422 is not set
+# CONFIG_ARM_ERRATA_821420 is not set
+# CONFIG_ARM_ERRATA_825619 is not set
+# CONFIG_ARM_ERRATA_852421 is not set
+# CONFIG_ARM_ERRATA_852423 is not set
+
+#
+# Bus support
+#
+# CONFIG_PCI is not set
+
+#
+# PCI Endpoint
+#
+# CONFIG_PCI_ENDPOINT is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_HAVE_SMP=y
+# CONFIG_SMP is not set
+# CONFIG_HAVE_ARM_ARCH_TIMER is not set
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_3G_OPT is not set
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+# CONFIG_ARM_PSCI is not set
+CONFIG_ARCH_NR_GPIO=1024
+CONFIG_HZ_FIXED=0
+CONFIG_HZ_100=y
+# CONFIG_HZ_200 is not set
+# CONFIG_HZ_250 is not set
+# CONFIG_HZ_300 is not set
+# CONFIG_HZ_500 is not set
+# CONFIG_HZ_1000 is not set
+CONFIG_HZ=100
+CONFIG_SCHED_HRTICK=y
 CONFIG_THUMB2_KERNEL=y
+CONFIG_AEABI=y
+CONFIG_HAVE_ARCH_PFN_VALID=y
+# CONFIG_HIGHMEM is not set
+CONFIG_CPU_SW_DOMAIN_PAN=y
+CONFIG_ARCH_WANT_GENERAL_HUGETLB=y
+CONFIG_FORCE_MAX_ZONEORDER=11
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+# CONFIG_SECCOMP is not set
+# CONFIG_PARAVIRT is not set
+# CONFIG_PARAVIRT_TIME_ACCOUNTING is not set
+# CONFIG_XEN is not set
+
+#
+# Boot options
+#
+CONFIG_USE_OF=y
+CONFIG_ATAGS=y
+# CONFIG_DEPRECATED_PARAM_STRUCT is not set
 CONFIG_ZBOOT_ROM_TEXT=0x0
 CONFIG_ZBOOT_ROM_BSS=0x0
 CONFIG_ARM_APPENDED_DTB=y
+# CONFIG_ARM_ATAG_DTB_COMPAT is not set
+CONFIG_CMDLINE=""
 CONFIG_XIP_KERNEL=y
 CONFIG_XIP_PHYS_ADDR=0x20200000
+# CONFIG_XIP_DEFLATED_DATA is not set
 CONFIG_KEXEC=y
+CONFIG_ATAGS_PROC=y
+# CONFIG_CRASH_DUMP is not set
+CONFIG_AUTO_ZRELADDR=y
+
+#
+# CPU Power Management
+#
+
+#
+# CPU Frequency scaling
+#
 CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_GOV_ATTR_SET=y
+CONFIG_CPU_FREQ_GOV_COMMON=y
 CONFIG_CPU_FREQ_STAT=y
+CONFIG_CPU_FREQ_DEFAULT_GOV_PERFORMANCE=y
+# CONFIG_CPU_FREQ_DEFAULT_GOV_POWERSAVE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_USERSPACE is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_ONDEMAND is not set
+# CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE is not set
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
 CONFIG_CPU_FREQ_GOV_POWERSAVE=y
 CONFIG_CPU_FREQ_GOV_USERSPACE=y
 CONFIG_CPU_FREQ_GOV_ONDEMAND=y
 CONFIG_CPU_FREQ_GOV_CONSERVATIVE=y
+
+#
+# CPU frequency scaling drivers
+#
 CONFIG_CPUFREQ_DT=y
+CONFIG_CPUFREQ_DT_PLATDEV=y
+# CONFIG_QORIQ_CPUFREQ is not set
+
+#
+# CPU Idle
+#
+# CONFIG_CPU_IDLE is not set
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
 CONFIG_VFP=y
+CONFIG_VFPv3=y
 CONFIG_NEON=y
+# CONFIG_KERNEL_MODE_NEON is not set
+
+#
+# Power management options
+#
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+# CONFIG_SUSPEND_SKIP_SYNC is not set
+# CONFIG_HIBERNATION is not set
+CONFIG_PM_SLEEP=y
+# CONFIG_PM_AUTOSLEEP is not set
+# CONFIG_PM_WAKELOCKS is not set
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+# CONFIG_APM_EMULATION is not set
+CONFIG_PM_CLK=y
+CONFIG_PM_GENERIC_DOMAINS=y
+# CONFIG_WQ_POWER_EFFICIENT_DEFAULT is not set
+CONFIG_PM_GENERIC_DOMAINS_SLEEP=y
+CONFIG_PM_GENERIC_DOMAINS_OF=y
+CONFIG_CPU_PM=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_ARM_CPU_SUSPEND=y
+CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+
+#
+# Firmware Drivers
+#
+# CONFIG_FIRMWARE_MEMMAP is not set
+CONFIG_HAVE_ARM_SMCCC=y
+# CONFIG_GOOGLE_FIRMWARE is not set
+
+#
+# Tegra firmware driver
+#
+# CONFIG_ARM_CRYPTO is not set
+# CONFIG_VIRTUALIZATION is not set
+
+#
+# General architecture-dependent options
+#
+CONFIG_CRASH_CORE=y
+CONFIG_KEXEC_CORE=y
+CONFIG_HAVE_OPROFILE=y
+CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS=y
+CONFIG_ARCH_USE_BUILTIN_BSWAP=y
+CONFIG_HAVE_NMI=y
+CONFIG_HAVE_ARCH_TRACEHOOK=y
+CONFIG_HAVE_DMA_CONTIGUOUS=y
+CONFIG_GENERIC_SMP_IDLE_THREAD=y
+CONFIG_GENERIC_IDLE_POLL_SETUP=y
+CONFIG_ARCH_HAS_FORTIFY_SOURCE=y
+CONFIG_ARCH_HAS_SET_MEMORY=y
+CONFIG_HAVE_ARCH_THREAD_STRUCT_WHITELIST=y
+CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+CONFIG_HAVE_RSEQ=y
+CONFIG_HAVE_CLK=y
+CONFIG_HAVE_PERF_REGS=y
+CONFIG_HAVE_PERF_USER_STACK_DUMP=y
+CONFIG_ARCH_WANT_IPC_PARSE_VERSION=y
+CONFIG_HAVE_ARCH_SECCOMP_FILTER=y
+CONFIG_HAVE_STACKPROTECTOR=y
+CONFIG_CC_HAS_STACKPROTECTOR_NONE=y
+CONFIG_STACKPROTECTOR=y
+CONFIG_STACKPROTECTOR_STRONG=y
+CONFIG_HAVE_CONTEXT_TRACKING=y
+CONFIG_HAVE_VIRT_CPU_ACCOUNTING_GEN=y
+CONFIG_HAVE_IRQ_TIME_ACCOUNTING=y
+CONFIG_HAVE_MOD_ARCH_SPECIFIC=y
+CONFIG_MODULES_USE_ELF_REL=y
+CONFIG_ARCH_HAS_ELF_RANDOMIZE=y
+CONFIG_HAVE_ARCH_MMAP_RND_BITS=y
+CONFIG_HAVE_EXIT_THREAD=y
+CONFIG_ARCH_MMAP_RND_BITS=8
+CONFIG_CLONE_BACKWARDS=y
+CONFIG_OLD_SIGSUSPEND3=y
+CONFIG_OLD_SIGACTION=y
+CONFIG_ARCH_OPTIONAL_KERNEL_RWX_DEFAULT=y
+CONFIG_ARCH_HAS_STRICT_MODULE_RWX=y
+CONFIG_ARCH_HAS_PHYS_TO_DMA=y
+CONFIG_REFCOUNT_FULL=y
+
+#
+# GCOV-based kernel profiling
+#
+CONFIG_ARCH_HAS_GCOV_PROFILE_ALL=y
+CONFIG_PLUGIN_HOSTCC=""
+CONFIG_HAVE_GCC_PLUGINS=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+# CONFIG_MODULES is not set
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+CONFIG_BLK_SCSI_REQUEST=y
+CONFIG_BLK_DEV_BSG=y
+# CONFIG_BLK_DEV_BSGLIB is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+# CONFIG_BLK_DEV_ZONED is not set
+# CONFIG_BLK_CMDLINE_PARSER is not set
+# CONFIG_BLK_WBT is not set
+# CONFIG_BLK_SED_OPAL is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_EFI_PARTITION=y
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+CONFIG_IOSCHED_DEADLINE=y
+CONFIG_IOSCHED_CFQ=y
+# CONFIG_DEFAULT_DEADLINE is not set
+CONFIG_DEFAULT_CFQ=y
+# CONFIG_DEFAULT_NOOP is not set
+CONFIG_DEFAULT_IOSCHED="cfq"
+CONFIG_MQ_IOSCHED_DEADLINE=y
 # CONFIG_MQ_IOSCHED_KYBER is not set
+# CONFIG_IOSCHED_BFQ is not set
+CONFIG_ASN1=y
+CONFIG_INLINE_SPIN_UNLOCK_IRQ=y
+CONFIG_INLINE_READ_UNLOCK=y
+CONFIG_INLINE_READ_UNLOCK_IRQ=y
+CONFIG_INLINE_WRITE_UNLOCK=y
+CONFIG_INLINE_WRITE_UNLOCK_IRQ=y
+CONFIG_ARCH_SUPPORTS_ATOMIC_RMW=y
+CONFIG_FREEZER=y
+
+#
+# Executable file formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_BINFMT_ELF_FDPIC is not set
+CONFIG_ELFCORE=y
 # CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_BINFMT_SCRIPT=y
+# CONFIG_BINFMT_FLAT is not set
+# CONFIG_BINFMT_MISC is not set
+CONFIG_COREDUMP=y
+
+#
+# Memory Management options
+#
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_HAVE_MEMBLOCK=y
+CONFIG_NO_BOOTMEM=y
+CONFIG_SPLIT_PTLOCK_CPUS=4
+CONFIG_COMPACTION=y
+CONFIG_MIGRATION=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_NEED_PER_CPU_KM=y
+# CONFIG_CLEANCACHE is not set
+# CONFIG_FRONTSWAP is not set
+# CONFIG_CMA is not set
+# CONFIG_ZPOOL is not set
+# CONFIG_ZBUD is not set
+# CONFIG_ZSMALLOC is not set
+CONFIG_GENERIC_EARLY_IOREMAP=y
+# CONFIG_IDLE_PAGE_TRACKING is not set
+# CONFIG_PERCPU_STATS is not set
+# CONFIG_GUP_BENCHMARK is not set
 CONFIG_NET=y
+
+#
+# Networking options
+#
 CONFIG_PACKET=y
+# CONFIG_PACKET_DIAG is not set
 CONFIG_UNIX=y
+# CONFIG_UNIX_DIAG is not set
+# CONFIG_TLS is not set
+CONFIG_XFRM=y
+# CONFIG_XFRM_USER is not set
+# CONFIG_XFRM_INTERFACE is not set
+# CONFIG_XFRM_SUB_POLICY is not set
+# CONFIG_XFRM_MIGRATE is not set
+# CONFIG_XFRM_STATISTICS is not set
+# CONFIG_NET_KEY is not set
 CONFIG_INET=y
+# CONFIG_IP_MULTICAST is not set
+# CONFIG_IP_ADVANCED_ROUTER is not set
 CONFIG_IP_PNP=y
 CONFIG_IP_PNP_DHCP=y
+# CONFIG_IP_PNP_BOOTP is not set
+# CONFIG_IP_PNP_RARP is not set
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE_DEMUX is not set
+CONFIG_NET_IP_TUNNEL=y
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_NET_IPVTI is not set
+# CONFIG_NET_FOU is not set
+# CONFIG_NET_FOU_IP_TUNNELS is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+CONFIG_INET_TUNNEL=y
+CONFIG_INET_XFRM_MODE_TRANSPORT=y
+CONFIG_INET_XFRM_MODE_TUNNEL=y
+CONFIG_INET_XFRM_MODE_BEET=y
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_INET_UDP_DIAG is not set
+# CONFIG_INET_RAW_DIAG is not set
+# CONFIG_INET_DIAG_DESTROY is not set
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+CONFIG_IPV6=y
+# CONFIG_IPV6_ROUTER_PREF is not set
+# CONFIG_IPV6_OPTIMISTIC_DAD is not set
+# CONFIG_INET6_AH is not set
+# CONFIG_INET6_ESP is not set
+# CONFIG_INET6_IPCOMP is not set
+# CONFIG_IPV6_MIP6 is not set
+CONFIG_INET6_XFRM_MODE_TRANSPORT=y
+CONFIG_INET6_XFRM_MODE_TUNNEL=y
+CONFIG_INET6_XFRM_MODE_BEET=y
+# CONFIG_INET6_XFRM_MODE_ROUTEOPTIMIZATION is not set
+# CONFIG_IPV6_VTI is not set
+CONFIG_IPV6_SIT=y
+# CONFIG_IPV6_SIT_6RD is not set
+CONFIG_IPV6_NDISC_NODETYPE=y
+# CONFIG_IPV6_TUNNEL is not set
+# CONFIG_IPV6_MULTIPLE_TABLES is not set
+# CONFIG_IPV6_MROUTE is not set
+# CONFIG_IPV6_SEG6_LWTUNNEL is not set
+# CONFIG_IPV6_SEG6_HMAC is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_BPFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+# CONFIG_BRIDGE is not set
+CONFIG_HAVE_NET_DSA=y
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_PHONET is not set
+# CONFIG_6LOWPAN is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
 CONFIG_DNS_RESOLVER=y
+# CONFIG_BATMAN_ADV is not set
+# CONFIG_OPENVSWITCH is not set
+# CONFIG_VSOCKETS is not set
+# CONFIG_NETLINK_DIAG is not set
+# CONFIG_MPLS is not set
+# CONFIG_NET_NSH is not set
+# CONFIG_HSR is not set
+# CONFIG_NET_SWITCHDEV is not set
+# CONFIG_NET_L3_MASTER_DEV is not set
+# CONFIG_NET_NCSI is not set
+CONFIG_NET_RX_BUSY_POLL=y
+CONFIG_BQL=y
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+# CONFIG_AF_KCM is not set
+CONFIG_WIRELESS=y
 CONFIG_CFG80211=y
+# CONFIG_NL80211_TESTMODE is not set
+# CONFIG_CFG80211_DEVELOPER_WARNINGS is not set
 CONFIG_CFG80211_CERTIFICATION_ONUS=y
 # CONFIG_CFG80211_REQUIRE_SIGNED_REGDB is not set
+# CONFIG_CFG80211_REG_CELLULAR_HINTS is not set
+# CONFIG_CFG80211_REG_RELAX_NO_IR is not set
+CONFIG_CFG80211_DEFAULT_PS=y
 # CONFIG_CFG80211_CRDA_SUPPORT is not set
+# CONFIG_CFG80211_WEXT is not set
+# CONFIG_MAC80211 is not set
+CONFIG_MAC80211_STA_HASH_MAX_SIZE=0
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+# CONFIG_CAIF is not set
+# CONFIG_CEPH_LIB is not set
+# CONFIG_NFC is not set
+# CONFIG_PSAMPLE is not set
+# CONFIG_NET_IFE is not set
+# CONFIG_LWTUNNEL is not set
+CONFIG_DST_CACHE=y
+CONFIG_GRO_CELLS=y
+# CONFIG_NET_DEVLINK is not set
+CONFIG_MAY_USE_DEVLINK=y
+# CONFIG_FAILOVER is not set
+CONFIG_HAVE_EBPF_JIT=y
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER=y
 CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
 CONFIG_DEVTMPFS=y
 CONFIG_DEVTMPFS_MOUNT=y
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+
+#
+# Firmware loader
+#
+CONFIG_FW_LOADER=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_FW_LOADER_USER_HELPER is not set
+CONFIG_ALLOW_DEV_COREDUMP=y
+# CONFIG_DEBUG_DRIVER is not set
+# CONFIG_DEBUG_DEVRES is not set
+# CONFIG_DEBUG_TEST_DRIVER_REMOVE is not set
+CONFIG_GENERIC_CPU_AUTOPROBE=y
+CONFIG_SOC_BUS=y
+CONFIG_REGMAP=y
+CONFIG_REGMAP_I2C=y
+CONFIG_REGMAP_SPI=y
+CONFIG_REGMAP_IRQ=y
+
+#
+# Bus devices
+#
+# CONFIG_BRCMSTB_GISB_ARB is not set
 CONFIG_SIMPLE_PM_BUS=y
+# CONFIG_VEXPRESS_CONFIG is not set
+# CONFIG_CONNECTOR is not set
+# CONFIG_GNSS is not set
 CONFIG_MTD=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+# CONFIG_MTD_CMDLINE_PARTS is not set
+# CONFIG_MTD_AFS_PARTS is not set
+CONFIG_MTD_OF_PARTS=y
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# Partition parsers
+#
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_BLKDEVS=y
 CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_SM_FTL is not set
+# CONFIG_MTD_OOPS is not set
+# CONFIG_MTD_SWAP is not set
+# CONFIG_MTD_PARTITIONED_MASTER is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
 CONFIG_MTD_CFI=y
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_GEN_PROBE=y
+# CONFIG_MTD_CFI_ADV_OPTIONS is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_INTELEXT is not set
 CONFIG_MTD_CFI_AMDSTD=y
+# CONFIG_MTD_CFI_STAA is not set
+CONFIG_MTD_CFI_UTIL=y
+# CONFIG_MTD_RAM is not set
 CONFIG_MTD_ROM=y
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
 CONFIG_MTD_PHYSMAP=y
+# CONFIG_MTD_PHYSMAP_COMPAT is not set
 CONFIG_MTD_PHYSMAP_OF=y
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_DATAFLASH is not set
 CONFIG_MTD_M25P80=y
+# CONFIG_MTD_MCHP23K256 is not set
+# CONFIG_MTD_SST25L is not set
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOCG3 is not set
+# CONFIG_MTD_ONENAND is not set
+# CONFIG_MTD_NAND is not set
+# CONFIG_MTD_SPI_NAND is not set
+
+#
+# LPDDR & LPDDR2 PCM memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+# CONFIG_MTD_LPDDR2_NVM is not set
 CONFIG_MTD_SPI_NOR=y
+# CONFIG_MTD_MT81xx_NOR is not set
+CONFIG_MTD_SPI_NOR_USE_4K_SECTORS=y
+# CONFIG_SPI_CADENCE_QUADSPI is not set
+# CONFIG_MTD_UBI is not set
+CONFIG_DTC=y
+CONFIG_OF=y
+# CONFIG_OF_UNITTEST is not set
+CONFIG_OF_FLATTREE=y
+CONFIG_OF_EARLY_FLATTREE=y
+CONFIG_OF_KOBJ=y
+CONFIG_OF_DYNAMIC=y
+CONFIG_OF_ADDRESS=y
+CONFIG_OF_IRQ=y
+CONFIG_OF_NET=y
+CONFIG_OF_MDIO=y
+CONFIG_OF_RESERVED_MEM=y
+# CONFIG_OF_OVERLAY is not set
+CONFIG_ARCH_MIGHT_HAVE_PC_PARPORT=y
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_NULL_BLK is not set
+# CONFIG_BLK_DEV_LOOP is not set
+# CONFIG_BLK_DEV_DRBD is not set
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_RAM is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_BLK_DEV_RBD is not set
+
+#
+# NVME Support
+#
+# CONFIG_NVME_FC is not set
+# CONFIG_NVME_TARGET is not set
+
+#
+# Misc devices
+#
+# CONFIG_AD525X_DPOT is not set
+# CONFIG_DUMMY_IRQ is not set
+# CONFIG_ICS932S401 is not set
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_APDS9802ALS is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_ISL29020 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_SENSORS_BH1770 is not set
+# CONFIG_SENSORS_APDS990X is not set
+# CONFIG_HMC6352 is not set
+# CONFIG_DS1682 is not set
+# CONFIG_USB_SWITCH_FSA9480 is not set
+# CONFIG_LATTICE_ECP3_CONFIG is not set
+# CONFIG_SRAM is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
 CONFIG_EEPROM_AT24=y
 CONFIG_EEPROM_AT25=y
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_EEPROM_93XX46 is not set
+# CONFIG_EEPROM_IDT_89HPESX is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+# CONFIG_TI_ST is not set
+# CONFIG_SENSORS_LIS3_SPI is not set
+# CONFIG_SENSORS_LIS3_I2C is not set
+# CONFIG_ALTERA_STAPL is not set
+
+#
+# Intel MIC & related support
+#
+
+#
+# Intel MIC Bus Driver
+#
+
+#
+# SCIF Bus Driver
+#
+
+#
+# VOP Bus Driver
+#
+
+#
+# Intel MIC Host Driver
+#
+
+#
+# Intel MIC Card Driver
+#
+
+#
+# SCIF Driver
+#
+
+#
+# Intel MIC Coprocessor State Management (COSM) Drivers
+#
+
+#
+# VOP Driver
+#
+# CONFIG_ECHO is not set
+# CONFIG_MISC_RTSX_USB is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_RAID_ATTRS is not set
 CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
 # CONFIG_SCSI_MQ_DEFAULT is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
 CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+CONFIG_SCSI_LOWLEVEL=y
+# CONFIG_ISCSI_TCP is not set
+# CONFIG_ISCSI_BOOT_SYSFS is not set
+# CONFIG_SCSI_UFSHCD is not set
+# CONFIG_SCSI_DEBUG is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+# CONFIG_TARGET_CORE is not set
 CONFIG_NETDEVICES=y
+CONFIG_MII=y
+CONFIG_NET_CORE=y
+# CONFIG_BONDING is not set
+# CONFIG_DUMMY is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_NET_TEAM is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_VXLAN is not set
+# CONFIG_MACSEC is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_TUN is not set
+# CONFIG_TUN_VNET_CROSS_LE is not set
+# CONFIG_VETH is not set
+# CONFIG_NLMON is not set
+
+#
+# CAIF transport drivers
+#
+
+#
+# Distributed Switch Architecture drivers
+#
+CONFIG_ETHERNET=y
+CONFIG_NET_VENDOR_ALACRITECH=y
+# CONFIG_ALTERA_TSE is not set
 # CONFIG_NET_VENDOR_AMAZON is not set
 # CONFIG_NET_VENDOR_AQUANTIA is not set
 # CONFIG_NET_VENDOR_ARC is not set
 # CONFIG_NET_VENDOR_AURORA is not set
 # CONFIG_NET_VENDOR_BROADCOM is not set
+CONFIG_NET_VENDOR_CADENCE=y
+# CONFIG_MACB is not set
+CONFIG_NET_VENDOR_CAVIUM=y
 # CONFIG_NET_VENDOR_CIRRUS is not set
 # CONFIG_NET_VENDOR_CORTINA is not set
+# CONFIG_DM9000 is not set
+# CONFIG_DNET is not set
 # CONFIG_NET_VENDOR_EZCHIP is not set
 # CONFIG_NET_VENDOR_FARADAY is not set
 # CONFIG_NET_VENDOR_HISILICON is not set
+CONFIG_NET_VENDOR_HUAWEI=y
 # CONFIG_NET_VENDOR_INTEL is not set
 # CONFIG_NET_VENDOR_MARVELL is not set
+CONFIG_NET_VENDOR_MELLANOX=y
+# CONFIG_MLXSW_CORE is not set
+# CONFIG_MLXFW is not set
 # CONFIG_NET_VENDOR_MICREL is not set
 # CONFIG_NET_VENDOR_MICROCHIP is not set
+CONFIG_NET_VENDOR_MICROSEMI=y
 # CONFIG_NET_VENDOR_NATSEMI is not set
 # CONFIG_NET_VENDOR_NETRONOME is not set
+CONFIG_NET_VENDOR_NI=y
+# CONFIG_ETHOC is not set
 # CONFIG_NET_VENDOR_QUALCOMM is not set
+CONFIG_NET_VENDOR_RENESAS=y
 CONFIG_SH_ETH=y
+# CONFIG_RAVB is not set
 # CONFIG_NET_VENDOR_ROCKER is not set
 # CONFIG_NET_VENDOR_SAMSUNG is not set
 # CONFIG_NET_VENDOR_SEEQ is not set
@@ -91,97 +1102,2080 @@ CONFIG_SH_ETH=y
 # CONFIG_NET_VENDOR_SYNOPSYS is not set
 # CONFIG_NET_VENDOR_VIA is not set
 # CONFIG_NET_VENDOR_WIZNET is not set
+CONFIG_MDIO_DEVICE=y
+CONFIG_MDIO_BUS=y
+# CONFIG_MDIO_BCM_UNIMAC is not set
+CONFIG_MDIO_BITBANG=y
+# CONFIG_MDIO_BUS_MUX_GPIO is not set
+# CONFIG_MDIO_BUS_MUX_MMIOREG is not set
+# CONFIG_MDIO_GPIO is not set
+# CONFIG_MDIO_HISI_FEMAC is not set
+# CONFIG_MDIO_MSCC_MIIM is not set
+CONFIG_PHYLIB=y
+CONFIG_SWPHY=y
+
+#
+# MII PHY device drivers
+#
+# CONFIG_AMD_PHY is not set
+# CONFIG_AQUANTIA_PHY is not set
+# CONFIG_ASIX_PHY is not set
+# CONFIG_AT803X_PHY is not set
+# CONFIG_BCM7XXX_PHY is not set
+# CONFIG_BCM87XX_PHY is not set
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_CORTINA_PHY is not set
+# CONFIG_DAVICOM_PHY is not set
+# CONFIG_DP83822_PHY is not set
+# CONFIG_DP83TC811_PHY is not set
+# CONFIG_DP83848_PHY is not set
+# CONFIG_DP83867_PHY is not set
+CONFIG_FIXED_PHY=y
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_INTEL_XWAY_PHY is not set
+# CONFIG_LSI_ET1011C_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_MARVELL_PHY is not set
+# CONFIG_MARVELL_10G_PHY is not set
 CONFIG_MICREL_PHY=y
+# CONFIG_MICROCHIP_PHY is not set
+# CONFIG_MICROCHIP_T1_PHY is not set
+# CONFIG_MICROSEMI_PHY is not set
+# CONFIG_NATIONAL_PHY is not set
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_REALTEK_PHY is not set
 CONFIG_RENESAS_PHY=y
+# CONFIG_ROCKCHIP_PHY is not set
 CONFIG_SMSC_PHY=y
+# CONFIG_STE10XP is not set
+# CONFIG_TERANETICS_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+# CONFIG_XILINX_GMII2RGMII is not set
+# CONFIG_MICREL_KS8995MA is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+CONFIG_USB_NET_DRIVERS=y
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_RTL8152 is not set
+# CONFIG_USB_LAN78XX is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_IPHETH is not set
 # CONFIG_WLAN is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+# CONFIG_WAN is not set
+# CONFIG_NET_FAILOVER is not set
+# CONFIG_ISDN is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+CONFIG_INPUT_LEDS=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+# CONFIG_INPUT_SPARSEKMAP is not set
+# CONFIG_INPUT_MATRIXKMAP is not set
+
+#
+# Userland interfaces
+#
+# CONFIG_INPUT_MOUSEDEV is not set
+# CONFIG_INPUT_JOYDEV is not set
 CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
 # CONFIG_INPUT_KEYBOARD is not set
 # CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
 CONFIG_INPUT_TOUCHSCREEN=y
+CONFIG_TOUCHSCREEN_PROPERTIES=y
+# CONFIG_TOUCHSCREEN_ADS7846 is not set
+# CONFIG_TOUCHSCREEN_AD7877 is not set
+# CONFIG_TOUCHSCREEN_AD7879 is not set
+# CONFIG_TOUCHSCREEN_AR1021_I2C is not set
+# CONFIG_TOUCHSCREEN_ATMEL_MXT is not set
+# CONFIG_TOUCHSCREEN_AUO_PIXCIR is not set
+# CONFIG_TOUCHSCREEN_BU21013 is not set
+# CONFIG_TOUCHSCREEN_BU21029 is not set
+# CONFIG_TOUCHSCREEN_CHIPONE_ICN8318 is not set
+# CONFIG_TOUCHSCREEN_CY8CTMG110 is not set
+# CONFIG_TOUCHSCREEN_CYTTSP_CORE is not set
+# CONFIG_TOUCHSCREEN_CYTTSP4_CORE is not set
+# CONFIG_TOUCHSCREEN_DYNAPRO is not set
+# CONFIG_TOUCHSCREEN_HAMPSHIRE is not set
+# CONFIG_TOUCHSCREEN_EETI is not set
+# CONFIG_TOUCHSCREEN_EGALAX is not set
+# CONFIG_TOUCHSCREEN_EGALAX_SERIAL is not set
+# CONFIG_TOUCHSCREEN_EXC3000 is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_GOODIX is not set
+# CONFIG_TOUCHSCREEN_HIDEEP is not set
+# CONFIG_TOUCHSCREEN_ILI210X is not set
+# CONFIG_TOUCHSCREEN_S6SY761 is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_EKTF2127 is not set
+# CONFIG_TOUCHSCREEN_ELAN is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+# CONFIG_TOUCHSCREEN_WACOM_I2C is not set
+# CONFIG_TOUCHSCREEN_MAX11801 is not set
+# CONFIG_TOUCHSCREEN_MCS5000 is not set
+# CONFIG_TOUCHSCREEN_MMS114 is not set
+# CONFIG_TOUCHSCREEN_MELFAS_MIP4 is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_IMX6UL_TSC is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_EDT_FT5X06 is not set
 CONFIG_TOUCHSCREEN_FT5X06=y
 CONFIG_TOUCHSCREEN_FT5X06_SINGLE_TOUCH=y
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+# CONFIG_TOUCHSCREEN_PIXCIR is not set
+# CONFIG_TOUCHSCREEN_WDT87XX_I2C is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TSC_SERIO is not set
+# CONFIG_TOUCHSCREEN_TSC2004 is not set
+# CONFIG_TOUCHSCREEN_TSC2005 is not set
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+# CONFIG_TOUCHSCREEN_RM_TS is not set
+# CONFIG_TOUCHSCREEN_SILEAD is not set
+# CONFIG_TOUCHSCREEN_SIS_I2C is not set
+# CONFIG_TOUCHSCREEN_ST1232 is not set
+# CONFIG_TOUCHSCREEN_STMFTS is not set
+# CONFIG_TOUCHSCREEN_SURFACE3_SPI is not set
+# CONFIG_TOUCHSCREEN_SX8654 is not set
+# CONFIG_TOUCHSCREEN_TPS6507X is not set
+# CONFIG_TOUCHSCREEN_ZET6223 is not set
+# CONFIG_TOUCHSCREEN_ZFORCE is not set
+# CONFIG_TOUCHSCREEN_ROHM_BU21023 is not set
 CONFIG_INPUT_MISC=y
+# CONFIG_INPUT_AD714X is not set
+# CONFIG_INPUT_ATMEL_CAPTOUCH is not set
+# CONFIG_INPUT_BMA150 is not set
+# CONFIG_INPUT_E3X0_BUTTON is not set
+# CONFIG_INPUT_MMA8450 is not set
+# CONFIG_INPUT_GP2A is not set
+# CONFIG_INPUT_GPIO_BEEPER is not set
+# CONFIG_INPUT_GPIO_DECODER is not set
+# CONFIG_INPUT_ATI_REMOTE2 is not set
+# CONFIG_INPUT_KEYSPAN_REMOTE is not set
+# CONFIG_INPUT_KXTJ9 is not set
+# CONFIG_INPUT_POWERMATE is not set
+# CONFIG_INPUT_YEALINK is not set
+# CONFIG_INPUT_CM109 is not set
+# CONFIG_INPUT_REGULATOR_HAPTIC is not set
+# CONFIG_INPUT_UINPUT is not set
+# CONFIG_INPUT_PCF8574 is not set
+# CONFIG_INPUT_GPIO_ROTARY_ENCODER is not set
+# CONFIG_INPUT_DA9063_ONKEY is not set
+# CONFIG_INPUT_ADXL34X is not set
+# CONFIG_INPUT_IMS_PCU is not set
+# CONFIG_INPUT_CMA3000 is not set
+# CONFIG_INPUT_DRV260X_HAPTICS is not set
+# CONFIG_INPUT_DRV2665_HAPTICS is not set
+# CONFIG_INPUT_DRV2667_HAPTICS is not set
+# CONFIG_RMI4_CORE is not set
+
+#
+# Hardware I/O ports
+#
 # CONFIG_SERIO is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_TTY=y
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_VT_CONSOLE_SLEEP=y
+CONFIG_HW_CONSOLE=y
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_UNIX98_PTYS=y
 # CONFIG_LEGACY_PTYS is not set
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_N_GSM is not set
+# CONFIG_TRACE_SINK is not set
+CONFIG_DEVMEM=y
 CONFIG_DEVKMEM=y
+
+#
+# Serial drivers
+#
+CONFIG_SERIAL_EARLYCON=y
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+# CONFIG_SERIAL_EARLYCON_ARM_SEMIHOST is not set
+# CONFIG_SERIAL_MAX3100 is not set
+# CONFIG_SERIAL_MAX310X is not set
+# CONFIG_SERIAL_UARTLITE is not set
 CONFIG_SERIAL_SH_SCI=y
 CONFIG_SERIAL_SH_SCI_NR_UARTS=10
-# CONFIG_SERIAL_SH_SCI_DMA is not set
+CONFIG_SERIAL_SH_SCI_CONSOLE=y
+CONFIG_SERIAL_SH_SCI_EARLYCON=y
+CONFIG_SERIAL_SH_SCI_DMA=y
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_SCCNXP is not set
+# CONFIG_SERIAL_SC16IS7XX is not set
+# CONFIG_SERIAL_BCM63XX is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+# CONFIG_SERIAL_IFX6X60 is not set
+# CONFIG_SERIAL_XILINX_PS_UART is not set
+# CONFIG_SERIAL_ARC is not set
+# CONFIG_SERIAL_FSL_LPUART is not set
+# CONFIG_SERIAL_CONEXANT_DIGICOLOR is not set
+# CONFIG_SERIAL_ST_ASC is not set
+CONFIG_SERIAL_MCTRL_GPIO=y
+# CONFIG_SERIAL_DEV_BUS is not set
+# CONFIG_TTY_PRINTK is not set
+# CONFIG_HVC_DCC is not set
+# CONFIG_IPMI_HANDLER is not set
 # CONFIG_HW_RANDOM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_XILLYBUS is not set
+
+#
+# I2C support
+#
 CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_COMPAT=y
 CONFIG_I2C_CHARDEV=y
 CONFIG_I2C_MUX=y
+
+#
+# Multiplexer I2C Chip support
+#
+# CONFIG_I2C_ARB_GPIO_CHALLENGE is not set
+# CONFIG_I2C_MUX_GPIO is not set
+# CONFIG_I2C_MUX_GPMUX is not set
+# CONFIG_I2C_MUX_LTC4306 is not set
+# CONFIG_I2C_MUX_PCA9541 is not set
+# CONFIG_I2C_MUX_PCA954x is not set
+# CONFIG_I2C_MUX_PINCTRL is not set
+# CONFIG_I2C_MUX_REG is not set
 CONFIG_I2C_DEMUX_PINCTRL=y
+# CONFIG_I2C_MUX_MLXCPLD is not set
+CONFIG_I2C_HELPER_AUTO=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_CBUS_GPIO is not set
+# CONFIG_I2C_DESIGNWARE_PLATFORM is not set
+# CONFIG_I2C_EMEV2 is not set
+# CONFIG_I2C_GPIO is not set
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
 CONFIG_I2C_RIIC=y
+# CONFIG_I2C_RK3X is not set
+# CONFIG_I2C_SH_MOBILE is not set
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_XILINX is not set
+# CONFIG_I2C_RCAR is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_DIOLAN_U2C is not set
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_ROBOTFUZZ_OSIF is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
 CONFIG_I2C_SLAVE=y
 CONFIG_I2C_SLAVE_EEPROM=y
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
 CONFIG_SPI=y
+# CONFIG_SPI_DEBUG is not set
+CONFIG_SPI_MASTER=y
+CONFIG_SPI_MEM=y
+
+#
+# SPI Master Controller Drivers
+#
+# CONFIG_SPI_ALTERA is not set
+# CONFIG_SPI_AXI_SPI_ENGINE is not set
+# CONFIG_SPI_BITBANG is not set
+# CONFIG_SPI_CADENCE is not set
+# CONFIG_SPI_DESIGNWARE is not set
+# CONFIG_SPI_GPIO is not set
+# CONFIG_SPI_FSL_SPI is not set
+# CONFIG_SPI_OC_TINY is not set
+# CONFIG_SPI_ROCKCHIP is not set
 CONFIG_SPI_RSPI=y
+# CONFIG_SPI_SC18IS602 is not set
+# CONFIG_SPI_SH_MSIOF is not set
+# CONFIG_SPI_SH_HSPI is not set
+# CONFIG_SPI_XCOMM is not set
+# CONFIG_SPI_XILINX is not set
+# CONFIG_SPI_ZYNQMP_GQSPI is not set
+
+#
+# SPI Protocol Masters
+#
 CONFIG_SPI_SPIDEV=y
+# CONFIG_SPI_TLE62X0 is not set
+# CONFIG_SPI_SLAVE is not set
+# CONFIG_SPMI is not set
+# CONFIG_HSI is not set
+# CONFIG_PPS is not set
+
+#
+# PTP clock support
+#
+# CONFIG_PTP_1588_CLOCK is not set
+
+#
+# Enable PHYLIB and NETWORK_PHY_TIMESTAMPING to see the additional clocks.
+#
+CONFIG_PINCTRL=y
+CONFIG_GENERIC_PINCTRL_GROUPS=y
+CONFIG_PINMUX=y
+CONFIG_GENERIC_PINMUX_FUNCTIONS=y
+CONFIG_PINCONF=y
+CONFIG_GENERIC_PINCONF=y
+# CONFIG_DEBUG_PINCTRL is not set
+# CONFIG_PINCTRL_AMD is not set
+# CONFIG_PINCTRL_MCP23S08 is not set
 CONFIG_PINCTRL_RZA2=y
+# CONFIG_PINCTRL_SINGLE is not set
+# CONFIG_PINCTRL_SX150X is not set
+CONFIG_PINCTRL_SH_PFC=y
+CONFIG_ARCH_HAVE_CUSTOM_GPIO_H=y
+CONFIG_GPIOLIB=y
+CONFIG_GPIOLIB_FASTPATH_LIMIT=512
+CONFIG_OF_GPIO=y
+CONFIG_GPIOLIB_IRQCHIP=y
+# CONFIG_DEBUG_GPIO is not set
 CONFIG_GPIO_SYSFS=y
+
+#
+# Memory mapped GPIO drivers
+#
+# CONFIG_GPIO_74XX_MMIO is not set
+# CONFIG_GPIO_ALTERA is not set
+# CONFIG_GPIO_DWAPB is not set
+# CONFIG_GPIO_FTGPIO010 is not set
+# CONFIG_GPIO_GENERIC_PLATFORM is not set
+# CONFIG_GPIO_GRGPIO is not set
+# CONFIG_GPIO_HLWD is not set
+# CONFIG_GPIO_MB86S7X is not set
+# CONFIG_GPIO_MOCKUP is not set
+# CONFIG_GPIO_MPC8XXX is not set
+# CONFIG_GPIO_RCAR is not set
+# CONFIG_GPIO_XILINX is not set
+# CONFIG_GPIO_ZEVIO is not set
+
+#
+# I2C GPIO expanders
+#
+# CONFIG_GPIO_ADP5588 is not set
+# CONFIG_GPIO_ADNP is not set
+# CONFIG_GPIO_MAX7300 is not set
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCA953X is not set
 CONFIG_GPIO_PCF857X=y
+# CONFIG_GPIO_TPIC2810 is not set
+
+#
+# MFD GPIO expanders
+#
+# CONFIG_HTC_EGPIO is not set
+
+#
+# SPI GPIO expanders
+#
+# CONFIG_GPIO_74X164 is not set
+# CONFIG_GPIO_MAX3191X is not set
+# CONFIG_GPIO_MAX7301 is not set
+# CONFIG_GPIO_MC33880 is not set
+# CONFIG_GPIO_PISOSR is not set
+# CONFIG_GPIO_XRA1403 is not set
+
+#
+# USB GPIO expanders
+#
+# CONFIG_W1 is not set
+# CONFIG_POWER_AVS is not set
 CONFIG_POWER_RESET=y
+# CONFIG_POWER_RESET_BRCMKONA is not set
+# CONFIG_POWER_RESET_GPIO is not set
+# CONFIG_POWER_RESET_GPIO_RESTART is not set
+# CONFIG_POWER_RESET_LTC2952 is not set
+# CONFIG_POWER_RESET_RESTART is not set
+# CONFIG_POWER_RESET_SYSCON is not set
+# CONFIG_POWER_RESET_SYSCON_POWEROFF is not set
 CONFIG_POWER_SUPPLY=y
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+# CONFIG_PDA_POWER is not set
+# CONFIG_TEST_POWER is not set
+# CONFIG_CHARGER_ADP5061 is not set
+# CONFIG_BATTERY_DS2780 is not set
+# CONFIG_BATTERY_DS2781 is not set
+# CONFIG_BATTERY_DS2782 is not set
+# CONFIG_BATTERY_SBS is not set
+# CONFIG_CHARGER_SBS is not set
+# CONFIG_MANAGER_SBS is not set
+# CONFIG_BATTERY_BQ27XXX is not set
+# CONFIG_BATTERY_MAX17040 is not set
+# CONFIG_BATTERY_MAX17042 is not set
+# CONFIG_CHARGER_MAX8903 is not set
+# CONFIG_CHARGER_LP8727 is not set
+# CONFIG_CHARGER_GPIO is not set
+# CONFIG_CHARGER_MANAGER is not set
+# CONFIG_CHARGER_LTC3651 is not set
+# CONFIG_CHARGER_DETECTOR_MAX14656 is not set
+# CONFIG_CHARGER_BQ2415X is not set
+# CONFIG_CHARGER_BQ24257 is not set
+# CONFIG_CHARGER_BQ24735 is not set
+# CONFIG_CHARGER_BQ25890 is not set
+# CONFIG_CHARGER_SMB347 is not set
+# CONFIG_BATTERY_GAUGE_LTC2941 is not set
+# CONFIG_CHARGER_RT9455 is not set
 # CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
 CONFIG_WATCHDOG=y
+CONFIG_WATCHDOG_CORE=y
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+CONFIG_WATCHDOG_HANDLE_BOOT_ENABLED=y
+# CONFIG_WATCHDOG_SYSFS is not set
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+# CONFIG_DA9063_WATCHDOG is not set
+# CONFIG_GPIO_WATCHDOG is not set
+# CONFIG_XILINX_WATCHDOG is not set
+# CONFIG_ZIIRAVE_WATCHDOG is not set
+# CONFIG_CADENCE_WATCHDOG is not set
+# CONFIG_FTWDT010_WATCHDOG is not set
+# CONFIG_DW_WATCHDOG is not set
+# CONFIG_MAX63XX_WATCHDOG is not set
+# CONFIG_RENESAS_WDT is not set
 CONFIG_RENESAS_RZAWDT=y
+# CONFIG_MEN_A21_WDT is not set
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+
+#
+# Watchdog Pretimeout Governors
+#
+# CONFIG_WATCHDOG_PRETIMEOUT_GOV is not set
+CONFIG_SSB_POSSIBLE=y
+# CONFIG_SSB is not set
+CONFIG_BCMA_POSSIBLE=y
+# CONFIG_BCMA is not set
+
+#
+# Multifunction device drivers
+#
+CONFIG_MFD_CORE=y
+# CONFIG_MFD_ACT8945A is not set
 CONFIG_MFD_AS3711=y
+# CONFIG_MFD_AS3722 is not set
+# CONFIG_PMIC_ADP5520 is not set
+# CONFIG_MFD_AAT2870_CORE is not set
+# CONFIG_MFD_ATMEL_FLEXCOM is not set
+# CONFIG_MFD_ATMEL_HLCDC is not set
+# CONFIG_MFD_BCM590XX is not set
+# CONFIG_MFD_BD9571MWV is not set
+# CONFIG_MFD_AXP20X_I2C is not set
+# CONFIG_MFD_CROS_EC is not set
+# CONFIG_MFD_MADERA is not set
+# CONFIG_MFD_ASIC3 is not set
+# CONFIG_PMIC_DA903X is not set
+# CONFIG_MFD_DA9052_SPI is not set
+# CONFIG_MFD_DA9052_I2C is not set
+# CONFIG_MFD_DA9055 is not set
+# CONFIG_MFD_DA9062 is not set
 CONFIG_MFD_DA9063=y
+# CONFIG_MFD_DA9150 is not set
+# CONFIG_MFD_DLN2 is not set
+# CONFIG_MFD_MC13XXX_SPI is not set
+# CONFIG_MFD_MC13XXX_I2C is not set
+# CONFIG_MFD_HI6421_PMIC is not set
+# CONFIG_HTC_PASIC3 is not set
+# CONFIG_HTC_I2CPLD is not set
+# CONFIG_MFD_KEMPLD is not set
+# CONFIG_MFD_88PM800 is not set
+# CONFIG_MFD_88PM805 is not set
+# CONFIG_MFD_88PM860X is not set
+# CONFIG_MFD_MAX14577 is not set
+# CONFIG_MFD_MAX77620 is not set
+# CONFIG_MFD_MAX77686 is not set
+# CONFIG_MFD_MAX77693 is not set
+# CONFIG_MFD_MAX77843 is not set
+# CONFIG_MFD_MAX8907 is not set
+# CONFIG_MFD_MAX8925 is not set
+# CONFIG_MFD_MAX8997 is not set
+# CONFIG_MFD_MAX8998 is not set
+# CONFIG_MFD_MT6397 is not set
+# CONFIG_MFD_MENF21BMC is not set
+# CONFIG_EZX_PCAP is not set
+# CONFIG_MFD_CPCAP is not set
+# CONFIG_MFD_VIPERBOARD is not set
+# CONFIG_MFD_RETU is not set
+# CONFIG_MFD_PCF50633 is not set
+# CONFIG_MFD_PM8XXX is not set
+# CONFIG_MFD_RT5033 is not set
+# CONFIG_MFD_RC5T583 is not set
+# CONFIG_MFD_RK808 is not set
+# CONFIG_MFD_RN5T618 is not set
+# CONFIG_MFD_SEC_CORE is not set
+# CONFIG_MFD_SI476X_CORE is not set
+# CONFIG_MFD_SM501 is not set
+# CONFIG_MFD_SKY81452 is not set
+# CONFIG_MFD_SMSC is not set
+# CONFIG_ABX500_CORE is not set
+# CONFIG_MFD_STMPE is not set
+# CONFIG_MFD_SYSCON is not set
+# CONFIG_MFD_TI_AM335X_TSCADC is not set
+# CONFIG_MFD_LP3943 is not set
+# CONFIG_MFD_LP8788 is not set
+# CONFIG_MFD_TI_LMU is not set
+# CONFIG_MFD_PALMAS is not set
+# CONFIG_TPS6105X is not set
+# CONFIG_TPS65010 is not set
+# CONFIG_TPS6507X is not set
+# CONFIG_MFD_TPS65086 is not set
+# CONFIG_MFD_TPS65090 is not set
+# CONFIG_MFD_TPS65217 is not set
+# CONFIG_MFD_TI_LP873X is not set
+# CONFIG_MFD_TI_LP87565 is not set
+# CONFIG_MFD_TPS65218 is not set
+# CONFIG_MFD_TPS6586X is not set
+# CONFIG_MFD_TPS65910 is not set
+# CONFIG_MFD_TPS65912_I2C is not set
+# CONFIG_MFD_TPS65912_SPI is not set
+# CONFIG_MFD_TPS80031 is not set
+# CONFIG_TWL4030_CORE is not set
+# CONFIG_TWL6040_CORE is not set
+# CONFIG_MFD_WL1273_CORE is not set
+# CONFIG_MFD_LM3533 is not set
+# CONFIG_MFD_TC3589X is not set
+# CONFIG_MFD_T7L66XB is not set
+# CONFIG_MFD_TC6387XB is not set
+# CONFIG_MFD_TC6393XB is not set
+# CONFIG_MFD_ARIZONA_I2C is not set
+# CONFIG_MFD_ARIZONA_SPI is not set
+# CONFIG_MFD_WM8400 is not set
+# CONFIG_MFD_WM831X_I2C is not set
+# CONFIG_MFD_WM831X_SPI is not set
+# CONFIG_MFD_WM8350_I2C is not set
+# CONFIG_MFD_WM8994 is not set
+# CONFIG_MFD_ROHM_BD718XX is not set
 CONFIG_REGULATOR=y
+# CONFIG_REGULATOR_DEBUG is not set
 CONFIG_REGULATOR_FIXED_VOLTAGE=y
+# CONFIG_REGULATOR_VIRTUAL_CONSUMER is not set
+# CONFIG_REGULATOR_USERSPACE_CONSUMER is not set
+# CONFIG_REGULATOR_88PG86X is not set
+# CONFIG_REGULATOR_ACT8865 is not set
+# CONFIG_REGULATOR_AD5398 is not set
+# CONFIG_REGULATOR_AS3711 is not set
+# CONFIG_REGULATOR_DA9063 is not set
+# CONFIG_REGULATOR_DA9210 is not set
+# CONFIG_REGULATOR_DA9211 is not set
+# CONFIG_REGULATOR_FAN53555 is not set
 CONFIG_REGULATOR_GPIO=y
+# CONFIG_REGULATOR_ISL9305 is not set
+# CONFIG_REGULATOR_ISL6271A is not set
+# CONFIG_REGULATOR_LP3971 is not set
+# CONFIG_REGULATOR_LP3972 is not set
+# CONFIG_REGULATOR_LP872X is not set
+# CONFIG_REGULATOR_LP8755 is not set
+# CONFIG_REGULATOR_LTC3589 is not set
+# CONFIG_REGULATOR_LTC3676 is not set
+# CONFIG_REGULATOR_MAX1586 is not set
+# CONFIG_REGULATOR_MAX8649 is not set
+# CONFIG_REGULATOR_MAX8660 is not set
+# CONFIG_REGULATOR_MAX8952 is not set
+# CONFIG_REGULATOR_MT6311 is not set
+# CONFIG_REGULATOR_PFUZE100 is not set
+# CONFIG_REGULATOR_PV88060 is not set
+# CONFIG_REGULATOR_PV88080 is not set
+# CONFIG_REGULATOR_PV88090 is not set
+# CONFIG_REGULATOR_SY8106A is not set
+# CONFIG_REGULATOR_TPS51632 is not set
+# CONFIG_REGULATOR_TPS62360 is not set
+# CONFIG_REGULATOR_TPS65023 is not set
+# CONFIG_REGULATOR_TPS6507X is not set
+# CONFIG_REGULATOR_TPS65132 is not set
+# CONFIG_REGULATOR_TPS6524X is not set
+# CONFIG_REGULATOR_VCTRL is not set
+# CONFIG_RC_CORE is not set
+# CONFIG_MEDIA_SUPPORT is not set
+
+#
+# Graphics support
+#
+# CONFIG_IMX_IPUV3_CORE is not set
+# CONFIG_DRM is not set
+# CONFIG_DRM_DP_CEC is not set
+
+#
+# ACP (Audio CoProcessor) Configuration
+#
+
+#
+# AMD Library routines
+#
+
+#
+# Frame buffer Devices
+#
 CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+CONFIG_FB_CMDLINE=y
+CONFIG_FB_NOTIFY=y
+CONFIG_FB_SYS_FILLRECT=y
+CONFIG_FB_SYS_COPYAREA=y
+CONFIG_FB_SYS_IMAGEBLIT=y
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+CONFIG_FB_SYS_FOPS=y
+CONFIG_FB_MODE_HELPERS=y
+# CONFIG_FB_TILEBLITTING is not set
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_OPENCORES is not set
+# CONFIG_FB_S1D13XXX is not set
+# CONFIG_FB_SH_MOBILE_LCDC is not set
+# CONFIG_FB_SMSCUFX is not set
+# CONFIG_FB_UDL is not set
+# CONFIG_FB_IBM_GXT4500 is not set
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_BROADSHEET is not set
+# CONFIG_FB_SIMPLE is not set
 CONFIG_FB_VDC5=y
+# CONFIG_FB_SSD1307 is not set
+# CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+CONFIG_VIDEOMODE_HELPERS=y
+
+#
+# Console display driver support
+#
+CONFIG_DUMMY_CONSOLE=y
 CONFIG_FRAMEBUFFER_CONSOLE=y
 CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY=y
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+# CONFIG_FRAMEBUFFER_CONSOLE_DEFERRED_TAKEOVER is not set
 CONFIG_LOGO=y
+CONFIG_LOGO_LINUX_MONO=y
+CONFIG_LOGO_LINUX_VGA16=y
+CONFIG_LOGO_LINUX_CLUT224=y
+CONFIG_SOUND=y
+CONFIG_SOUND_OSS_CORE=y
+CONFIG_SOUND_OSS_CORE_PRECLAIM=y
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+CONFIG_SND_JACK=y
+CONFIG_SND_JACK_INPUT_DEV=y
+CONFIG_SND_OSSEMUL=y
+CONFIG_SND_MIXER_OSS=y
+CONFIG_SND_PCM_OSS=y
+CONFIG_SND_PCM_OSS_PLUGINS=y
+CONFIG_SND_PCM_TIMER=y
+# CONFIG_SND_HRTIMER is not set
+# CONFIG_SND_DYNAMIC_MINORS is not set
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_SND_PROC_FS=y
+CONFIG_SND_VERBOSE_PROCFS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+# CONFIG_SND_SEQUENCER is not set
+CONFIG_SND_DRIVERS=y
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_ALOOP is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+
+#
+# HD-Audio
+#
+CONFIG_SND_HDA_PREALLOC_SIZE=64
+CONFIG_SND_ARM=y
+CONFIG_SND_SPI=y
+CONFIG_SND_USB=y
+# CONFIG_SND_USB_AUDIO is not set
+# CONFIG_SND_USB_UA101 is not set
+# CONFIG_SND_USB_CAIAQ is not set
+# CONFIG_SND_USB_6FIRE is not set
+# CONFIG_SND_USB_HIFACE is not set
+# CONFIG_SND_BCD2000 is not set
+# CONFIG_SND_USB_POD is not set
+# CONFIG_SND_USB_PODHD is not set
+# CONFIG_SND_USB_TONEPORT is not set
+# CONFIG_SND_USB_VARIAX is not set
+CONFIG_SND_SOC=y
+# CONFIG_SND_SOC_AMD_ACP is not set
+# CONFIG_SND_ATMEL_SOC is not set
+# CONFIG_SND_DESIGNWARE_I2S is not set
+
+#
+# SoC Audio for Freescale CPUs
+#
+
+#
+# Common SoC Audio options for Freescale CPUs:
+#
+# CONFIG_SND_SOC_FSL_ASRC is not set
+# CONFIG_SND_SOC_FSL_SAI is not set
+# CONFIG_SND_SOC_FSL_SSI is not set
+# CONFIG_SND_SOC_FSL_SPDIF is not set
+# CONFIG_SND_SOC_FSL_ESAI is not set
+# CONFIG_SND_SOC_IMX_AUDMUX is not set
+# CONFIG_SND_I2S_HI6210_I2S is not set
+# CONFIG_SND_SOC_IMG is not set
+
+#
+# SoC Audio support for Renesas SoCs
+#
+# CONFIG_SND_SOC_SH4_FSI is not set
+# CONFIG_SND_SOC_RCAR is not set
+CONFIG_SND_SOC_RZA2=y
+CONFIG_SND_RZA2MEVB=y
+
+#
+# STMicroelectronics STM32 SOC audio support
+#
+# CONFIG_SND_SOC_XTFPGA_I2S is not set
+# CONFIG_ZX_TDM is not set
+CONFIG_SND_SOC_I2C_AND_SPI=y
+
+#
+# CODEC drivers
+#
+# CONFIG_SND_SOC_AC97_CODEC is not set
+# CONFIG_SND_SOC_ADAU1701 is not set
+# CONFIG_SND_SOC_ADAU1761_I2C is not set
+# CONFIG_SND_SOC_ADAU1761_SPI is not set
+# CONFIG_SND_SOC_ADAU7002 is not set
+# CONFIG_SND_SOC_AK4104 is not set
+# CONFIG_SND_SOC_AK4458 is not set
+# CONFIG_SND_SOC_AK4554 is not set
+# CONFIG_SND_SOC_AK4613 is not set
+# CONFIG_SND_SOC_AK4642 is not set
+# CONFIG_SND_SOC_AK5386 is not set
+# CONFIG_SND_SOC_AK5558 is not set
+# CONFIG_SND_SOC_ALC5623 is not set
+# CONFIG_SND_SOC_BD28623 is not set
+# CONFIG_SND_SOC_BT_SCO is not set
+# CONFIG_SND_SOC_CS35L32 is not set
+# CONFIG_SND_SOC_CS35L33 is not set
+# CONFIG_SND_SOC_CS35L34 is not set
+# CONFIG_SND_SOC_CS35L35 is not set
+# CONFIG_SND_SOC_CS42L42 is not set
+# CONFIG_SND_SOC_CS42L51_I2C is not set
+# CONFIG_SND_SOC_CS42L52 is not set
+# CONFIG_SND_SOC_CS42L56 is not set
+# CONFIG_SND_SOC_CS42L73 is not set
+# CONFIG_SND_SOC_CS4265 is not set
+# CONFIG_SND_SOC_CS4270 is not set
+# CONFIG_SND_SOC_CS4271_I2C is not set
+# CONFIG_SND_SOC_CS4271_SPI is not set
+# CONFIG_SND_SOC_CS42XX8_I2C is not set
+# CONFIG_SND_SOC_CS43130 is not set
+# CONFIG_SND_SOC_CS4349 is not set
+# CONFIG_SND_SOC_CS53L30 is not set
+# CONFIG_SND_SOC_ES7134 is not set
+# CONFIG_SND_SOC_ES7241 is not set
+# CONFIG_SND_SOC_ES8316 is not set
+# CONFIG_SND_SOC_ES8328_I2C is not set
+# CONFIG_SND_SOC_ES8328_SPI is not set
+# CONFIG_SND_SOC_GTM601 is not set
+# CONFIG_SND_SOC_INNO_RK3036 is not set
+# CONFIG_SND_SOC_MAX98504 is not set
+# CONFIG_SND_SOC_MAX9867 is not set
+# CONFIG_SND_SOC_MAX98927 is not set
+# CONFIG_SND_SOC_MAX98373 is not set
+# CONFIG_SND_SOC_MAX9860 is not set
+# CONFIG_SND_SOC_MSM8916_WCD_DIGITAL is not set
+# CONFIG_SND_SOC_PCM1681 is not set
+# CONFIG_SND_SOC_PCM1789_I2C is not set
+# CONFIG_SND_SOC_PCM179X_I2C is not set
+# CONFIG_SND_SOC_PCM179X_SPI is not set
+# CONFIG_SND_SOC_PCM186X_I2C is not set
+# CONFIG_SND_SOC_PCM186X_SPI is not set
+# CONFIG_SND_SOC_PCM3168A_I2C is not set
+# CONFIG_SND_SOC_PCM3168A_SPI is not set
+# CONFIG_SND_SOC_PCM512x_I2C is not set
+# CONFIG_SND_SOC_PCM512x_SPI is not set
+# CONFIG_SND_SOC_RT5616 is not set
+# CONFIG_SND_SOC_RT5631 is not set
+# CONFIG_SND_SOC_SGTL5000 is not set
+# CONFIG_SND_SOC_SIMPLE_AMPLIFIER is not set
+# CONFIG_SND_SOC_SIRF_AUDIO_CODEC is not set
+# CONFIG_SND_SOC_SPDIF is not set
+# CONFIG_SND_SOC_SSM2305 is not set
+# CONFIG_SND_SOC_SSM2602_SPI is not set
+# CONFIG_SND_SOC_SSM2602_I2C is not set
+# CONFIG_SND_SOC_SSM4567 is not set
+# CONFIG_SND_SOC_STA32X is not set
+# CONFIG_SND_SOC_STA350 is not set
+# CONFIG_SND_SOC_STI_SAS is not set
+# CONFIG_SND_SOC_TAS2552 is not set
+# CONFIG_SND_SOC_TAS5086 is not set
+# CONFIG_SND_SOC_TAS571X is not set
+# CONFIG_SND_SOC_TAS5720 is not set
+# CONFIG_SND_SOC_TAS6424 is not set
+# CONFIG_SND_SOC_TDA7419 is not set
+# CONFIG_SND_SOC_TFA9879 is not set
+# CONFIG_SND_SOC_TLV320AIC23_I2C is not set
+# CONFIG_SND_SOC_TLV320AIC23_SPI is not set
+# CONFIG_SND_SOC_TLV320AIC31XX is not set
+# CONFIG_SND_SOC_TLV320AIC32X4_I2C is not set
+# CONFIG_SND_SOC_TLV320AIC32X4_SPI is not set
+# CONFIG_SND_SOC_TLV320AIC3X is not set
+# CONFIG_SND_SOC_TS3A227E is not set
+# CONFIG_SND_SOC_TSCS42XX is not set
+# CONFIG_SND_SOC_TSCS454 is not set
+# CONFIG_SND_SOC_WM8510 is not set
+# CONFIG_SND_SOC_WM8523 is not set
+# CONFIG_SND_SOC_WM8524 is not set
+# CONFIG_SND_SOC_WM8580 is not set
+# CONFIG_SND_SOC_WM8711 is not set
+# CONFIG_SND_SOC_WM8728 is not set
+# CONFIG_SND_SOC_WM8731 is not set
+# CONFIG_SND_SOC_WM8737 is not set
+# CONFIG_SND_SOC_WM8741 is not set
+# CONFIG_SND_SOC_WM8750 is not set
+# CONFIG_SND_SOC_WM8753 is not set
+# CONFIG_SND_SOC_WM8770 is not set
+# CONFIG_SND_SOC_WM8776 is not set
+# CONFIG_SND_SOC_WM8782 is not set
+# CONFIG_SND_SOC_WM8804_I2C is not set
+# CONFIG_SND_SOC_WM8804_SPI is not set
+# CONFIG_SND_SOC_WM8903 is not set
+# CONFIG_SND_SOC_WM8960 is not set
+# CONFIG_SND_SOC_WM8962 is not set
+# CONFIG_SND_SOC_WM8974 is not set
+# CONFIG_SND_SOC_WM8978 is not set
+CONFIG_SND_SOC_WM8978_SPI=y
+# CONFIG_SND_SOC_WM8985 is not set
+# CONFIG_SND_SOC_ZX_AUD96P22 is not set
+# CONFIG_SND_SOC_MAX9759 is not set
+# CONFIG_SND_SOC_MT6351 is not set
+# CONFIG_SND_SOC_NAU8540 is not set
+# CONFIG_SND_SOC_NAU8810 is not set
+# CONFIG_SND_SOC_NAU8824 is not set
+# CONFIG_SND_SOC_TPA6130A2 is not set
+# CONFIG_SND_SIMPLE_CARD is not set
+# CONFIG_SND_SIMPLE_SCU_CARD is not set
+# CONFIG_SND_AUDIO_GRAPH_CARD is not set
+# CONFIG_SND_AUDIO_GRAPH_SCU_CARD is not set
+
+#
+# HID support
+#
+CONFIG_HID=y
+# CONFIG_HID_BATTERY_STRENGTH is not set
+# CONFIG_HIDRAW is not set
+# CONFIG_UHID is not set
+CONFIG_HID_GENERIC=y
+
+#
+# Special HID drivers
+#
+# CONFIG_HID_A4TECH is not set
+# CONFIG_HID_ACCUTOUCH is not set
+# CONFIG_HID_ACRUX is not set
+# CONFIG_HID_APPLE is not set
+# CONFIG_HID_APPLEIR is not set
+# CONFIG_HID_ASUS is not set
+# CONFIG_HID_AUREAL is not set
+# CONFIG_HID_BELKIN is not set
+# CONFIG_HID_BETOP_FF is not set
+# CONFIG_HID_CHERRY is not set
+# CONFIG_HID_CHICONY is not set
+# CONFIG_HID_CORSAIR is not set
+# CONFIG_HID_COUGAR is not set
+# CONFIG_HID_PRODIKEYS is not set
+# CONFIG_HID_CMEDIA is not set
+# CONFIG_HID_CYPRESS is not set
+# CONFIG_HID_DRAGONRISE is not set
+# CONFIG_HID_EMS_FF is not set
+# CONFIG_HID_ELAN is not set
+# CONFIG_HID_ELECOM is not set
+# CONFIG_HID_ELO is not set
+# CONFIG_HID_EZKEY is not set
+# CONFIG_HID_GEMBIRD is not set
+# CONFIG_HID_GFRM is not set
+# CONFIG_HID_HOLTEK is not set
+# CONFIG_HID_GOOGLE_HAMMER is not set
+# CONFIG_HID_GT683R is not set
+# CONFIG_HID_KEYTOUCH is not set
+# CONFIG_HID_KYE is not set
+# CONFIG_HID_UCLOGIC is not set
+# CONFIG_HID_WALTOP is not set
+# CONFIG_HID_GYRATION is not set
+# CONFIG_HID_ICADE is not set
+# CONFIG_HID_ITE is not set
+# CONFIG_HID_JABRA is not set
+# CONFIG_HID_TWINHAN is not set
+# CONFIG_HID_KENSINGTON is not set
+# CONFIG_HID_LCPOWER is not set
+# CONFIG_HID_LED is not set
+# CONFIG_HID_LENOVO is not set
+# CONFIG_HID_LOGITECH is not set
+# CONFIG_HID_MAGICMOUSE is not set
+# CONFIG_HID_MAYFLASH is not set
+# CONFIG_HID_REDRAGON is not set
+# CONFIG_HID_MICROSOFT is not set
+# CONFIG_HID_MONTEREY is not set
+# CONFIG_HID_MULTITOUCH is not set
+# CONFIG_HID_NTI is not set
+# CONFIG_HID_NTRIG is not set
+# CONFIG_HID_ORTEK is not set
+# CONFIG_HID_PANTHERLORD is not set
+# CONFIG_HID_PENMOUNT is not set
+# CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_PICOLCD is not set
+# CONFIG_HID_PLANTRONICS is not set
+# CONFIG_HID_PRIMAX is not set
+# CONFIG_HID_RETRODE is not set
+# CONFIG_HID_ROCCAT is not set
+# CONFIG_HID_SAITEK is not set
+# CONFIG_HID_SAMSUNG is not set
+# CONFIG_HID_SONY is not set
+# CONFIG_HID_SPEEDLINK is not set
+# CONFIG_HID_STEAM is not set
+# CONFIG_HID_STEELSERIES is not set
+# CONFIG_HID_SUNPLUS is not set
+# CONFIG_HID_RMI is not set
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_TIVO is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_THINGM is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_UDRAW_PS3 is not set
+# CONFIG_HID_WACOM is not set
+# CONFIG_HID_WIIMOTE is not set
+# CONFIG_HID_XINMO is not set
+# CONFIG_HID_ZEROPLUS is not set
+# CONFIG_HID_ZYDACRON is not set
+# CONFIG_HID_SENSOR_HUB is not set
+# CONFIG_HID_ALPS is not set
+
+#
+# USB HID support
+#
+CONFIG_USB_HID=y
+# CONFIG_HID_PID is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# I2C HID support
+#
+# CONFIG_I2C_HID is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_COMMON=y
+CONFIG_USB_ARCH_HAS_HCD=y
 CONFIG_USB=y
 CONFIG_USB_ANNOUNCE_NEW_DEVICES=y
+
+#
+# Miscellaneous USB options
+#
+CONFIG_USB_DEFAULT_PERSIST=y
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_OTG is not set
+# CONFIG_USB_OTG_WHITELIST is not set
+# CONFIG_USB_OTG_BLACKLIST_HUB is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+# CONFIG_USB_XHCI_HCD is not set
 CONFIG_USB_EHCI_HCD=y
+# CONFIG_USB_EHCI_ROOT_HUB_TT is not set
+CONFIG_USB_EHCI_TT_NEWSCHED=y
 CONFIG_USB_EHCI_HCD_PLATFORM=y
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_FOTG210_HCD is not set
+# CONFIG_USB_MAX3421_HCD is not set
+# CONFIG_USB_OHCI_HCD is not set
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_RENESAS_USBHS_HCD is not set
+# CONFIG_USB_HCD_TEST_MODE is not set
 CONFIG_USB_RENESAS_USBHS=y
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
 CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_REALTEK is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_STORAGE_ENE_UB6250 is not set
+# CONFIG_USB_UAS is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+# CONFIG_USBIP_CORE is not set
+# CONFIG_USB_MUSB_HDRC is not set
+# CONFIG_USB_DWC3 is not set
+# CONFIG_USB_DWC2 is not set
+# CONFIG_USB_CHIPIDEA is not set
+# CONFIG_USB_ISP1760 is not set
+
+#
+# USB port drivers
+#
+# CONFIG_USB_SERIAL is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_EHSET_TEST_FIXTURE is not set
+# CONFIG_USB_ISIGHTFW is not set
+# CONFIG_USB_YUREX is not set
+# CONFIG_USB_EZUSB_FX2 is not set
+# CONFIG_USB_HUB_USB251XB is not set
+# CONFIG_USB_HSIC_USB3503 is not set
+# CONFIG_USB_HSIC_USB4604 is not set
+# CONFIG_USB_LINK_LAYER_TEST is not set
+
+#
+# USB Physical Layer drivers
+#
+# CONFIG_NOP_USB_XCEIV is not set
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_USB_ISP1301 is not set
+# CONFIG_USB_ULPI is not set
 CONFIG_USB_GADGET=y
+# CONFIG_USB_GADGET_DEBUG is not set
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_USB_GADGET_STORAGE_NUM_BUFFERS=2
+
+#
+# USB Peripheral Controller
+#
+# CONFIG_USB_FUSB300 is not set
+# CONFIG_USB_FOTG210_UDC is not set
+# CONFIG_USB_GR_UDC is not set
+# CONFIG_USB_R8A66597 is not set
 CONFIG_USB_RENESAS_USBHS_UDC=y
-CONFIG_USB_ETH=y
+# CONFIG_USB_PXA27X is not set
+# CONFIG_USB_MV_UDC is not set
+# CONFIG_USB_MV_U3D is not set
+# CONFIG_USB_SNP_UDC_PLAT is not set
+# CONFIG_USB_M66592 is not set
+# CONFIG_USB_BDC_UDC is not set
+# CONFIG_USB_NET2272 is not set
+# CONFIG_USB_GADGET_XILINX is not set
+# CONFIG_USB_DUMMY_HCD is not set
+# CONFIG_USB_CONFIGFS is not set
+# CONFIG_TYPEC is not set
+# CONFIG_USB_ROLE_SWITCH is not set
+# CONFIG_USB_ULPI_BUS is not set
+# CONFIG_UWB is not set
 CONFIG_MMC=y
+CONFIG_PWRSEQ_EMMC=y
+CONFIG_PWRSEQ_SIMPLE=y
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_MINORS=8
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+# CONFIG_MMC_DEBUG is not set
+# CONFIG_MMC_SDHCI is not set
+# CONFIG_MMC_SPI is not set
+CONFIG_MMC_TMIO_CORE=y
 CONFIG_MMC_SDHI=y
 # CONFIG_MMC_SDHI_SYS_DMAC is not set
+CONFIG_MMC_SDHI_INTERNAL_DMAC=y
+# CONFIG_MMC_DW is not set
 CONFIG_MMC_SH_MMCIF=y
+# CONFIG_MMC_VUB300 is not set
+# CONFIG_MMC_USHC is not set
+# CONFIG_MMC_USDHI6ROL0 is not set
+# CONFIG_MMC_CQHCI is not set
+# CONFIG_MMC_MTK is not set
+# CONFIG_MEMSTICK is not set
 CONFIG_NEW_LEDS=y
 CONFIG_LEDS_CLASS=y
+# CONFIG_LEDS_CLASS_FLASH is not set
+# CONFIG_LEDS_BRIGHTNESS_HW_CHANGED is not set
+
+#
+# LED drivers
+#
+# CONFIG_LEDS_BCM6328 is not set
+# CONFIG_LEDS_BCM6358 is not set
+# CONFIG_LEDS_CR0014114 is not set
+# CONFIG_LEDS_LM3530 is not set
+# CONFIG_LEDS_LM3642 is not set
+# CONFIG_LEDS_LM3692X is not set
+# CONFIG_LEDS_PCA9532 is not set
 CONFIG_LEDS_GPIO=y
+# CONFIG_LEDS_LP3944 is not set
+# CONFIG_LEDS_LP3952 is not set
+# CONFIG_LEDS_LP5521 is not set
+# CONFIG_LEDS_LP5523 is not set
+# CONFIG_LEDS_LP5562 is not set
+# CONFIG_LEDS_LP8501 is not set
+# CONFIG_LEDS_LP8860 is not set
+# CONFIG_LEDS_PCA955X is not set
+# CONFIG_LEDS_PCA963X is not set
+# CONFIG_LEDS_DAC124S085 is not set
+# CONFIG_LEDS_REGULATOR is not set
+# CONFIG_LEDS_BD2802 is not set
+# CONFIG_LEDS_LT3593 is not set
+# CONFIG_LEDS_TCA6507 is not set
+# CONFIG_LEDS_TLC591XX is not set
+# CONFIG_LEDS_LM355x is not set
+# CONFIG_LEDS_IS31FL319X is not set
+# CONFIG_LEDS_IS31FL32XX is not set
+
+#
+# LED driver for blink(1) USB RGB LED is under Special HID drivers (HID_THINGM)
+#
+# CONFIG_LEDS_BLINKM is not set
+# CONFIG_LEDS_MLXREG is not set
+# CONFIG_LEDS_USER is not set
+
+#
+# LED Triggers
+#
+# CONFIG_LEDS_TRIGGERS is not set
+# CONFIG_ACCESSIBILITY is not set
+# CONFIG_INFINIBAND is not set
+CONFIG_EDAC_ATOMIC_SCRUB=y
+CONFIG_EDAC_SUPPORT=y
+CONFIG_RTC_LIB=y
 CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+CONFIG_RTC_SYSTOHC=y
+CONFIG_RTC_SYSTOHC_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
 # CONFIG_RTC_NVMEM is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_ABB5ZES3 is not set
+# CONFIG_RTC_DRV_ABX80X is not set
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_HYM8563 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_ISL12022 is not set
+# CONFIG_RTC_DRV_ISL12026 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8523 is not set
+# CONFIG_RTC_DRV_PCF85063 is not set
+# CONFIG_RTC_DRV_PCF85363 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_BQ32K is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8010 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+# CONFIG_RTC_DRV_EM3027 is not set
+# CONFIG_RTC_DRV_RV8803 is not set
+
+#
+# SPI RTC drivers
+#
+# CONFIG_RTC_DRV_M41T93 is not set
+# CONFIG_RTC_DRV_M41T94 is not set
+# CONFIG_RTC_DRV_DS1302 is not set
+# CONFIG_RTC_DRV_DS1305 is not set
+# CONFIG_RTC_DRV_DS1343 is not set
+# CONFIG_RTC_DRV_DS1347 is not set
+# CONFIG_RTC_DRV_DS1390 is not set
+# CONFIG_RTC_DRV_MAX6916 is not set
+# CONFIG_RTC_DRV_R9701 is not set
+# CONFIG_RTC_DRV_RX4581 is not set
+# CONFIG_RTC_DRV_RX6110 is not set
+# CONFIG_RTC_DRV_RS5C348 is not set
+# CONFIG_RTC_DRV_MAX6902 is not set
+# CONFIG_RTC_DRV_PCF2123 is not set
+# CONFIG_RTC_DRV_MCP795 is not set
+CONFIG_RTC_I2C_AND_SPI=y
+
+#
+# SPI and I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS3232 is not set
+# CONFIG_RTC_DRV_PCF2127 is not set
+# CONFIG_RTC_DRV_RV3029C2 is not set
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1685_FAMILY is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_DS2404 is not set
+# CONFIG_RTC_DRV_DA9063 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+# CONFIG_RTC_DRV_ZYNQMP is not set
+
+#
+# on-CPU RTC drivers
+#
 CONFIG_RTC_DRV_SH=y
+# CONFIG_RTC_DRV_FTRTC010 is not set
+# CONFIG_RTC_DRV_SNVS is not set
+# CONFIG_RTC_DRV_R7301 is not set
+
+#
+# HID Sensor RTC drivers
+#
+# CONFIG_RTC_DRV_HID_SENSOR_TIME is not set
 CONFIG_DMADEVICES=y
-# CONFIG_SH_DMAE_BASE is not set
-CONFIG_RENESAS_USB_DMAC=y
+# CONFIG_DMADEVICES_DEBUG is not set
+
+#
+# DMA Devices
+#
+CONFIG_DMA_ENGINE=y
+CONFIG_DMA_OF=y
+# CONFIG_ALTERA_MSGDMA is not set
+# CONFIG_DW_AXI_DMAC is not set
+# CONFIG_FSL_EDMA is not set
+# CONFIG_INTEL_IDMA64 is not set
+# CONFIG_NBPFAXI_DMA is not set
+CONFIG_RZA_DMA=y
+# CONFIG_QCOM_HIDMA_MGMT is not set
+# CONFIG_QCOM_HIDMA is not set
+# CONFIG_DW_DMAC is not set
+CONFIG_RENESAS_DMA=y
+CONFIG_SH_DMAE_BASE=y
+# CONFIG_SH_DMAE is not set
+# CONFIG_RCAR_DMAC is not set
+# CONFIG_RENESAS_USB_DMAC is not set
+# CONFIG_SUDMAC is not set
+
+#
+# DMA Clients
+#
+# CONFIG_ASYNC_TX_DMA is not set
+# CONFIG_DMATEST is not set
+
+#
+# DMABUF options
+#
+# CONFIG_SYNC_FILE is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+# CONFIG_VIRT_DRIVERS is not set
 # CONFIG_VIRTIO_MENU is not set
+
+#
+# Microsoft Hyper-V guest support
+#
+# CONFIG_STAGING is not set
+# CONFIG_GOLDFISH is not set
+# CONFIG_CHROME_PLATFORMS is not set
+# CONFIG_MELLANOX_PLATFORM is not set
+CONFIG_CLKDEV_LOOKUP=y
+CONFIG_HAVE_CLK_PREPARE=y
+CONFIG_COMMON_CLK=y
+
+#
+# Common Clock Framework
+#
+# CONFIG_CLK_HSDK is not set
+# CONFIG_COMMON_CLK_MAX9485 is not set
+# CONFIG_COMMON_CLK_SI5351 is not set
+# CONFIG_COMMON_CLK_SI514 is not set
+# CONFIG_COMMON_CLK_SI544 is not set
+# CONFIG_COMMON_CLK_SI570 is not set
+# CONFIG_COMMON_CLK_CDCE706 is not set
+# CONFIG_COMMON_CLK_CDCE925 is not set
+# CONFIG_COMMON_CLK_CS2000_CP is not set
+# CONFIG_CLK_QORIQ is not set
+# CONFIG_COMMON_CLK_VC5 is not set
+CONFIG_CLK_RENESAS=y
+CONFIG_CLK_R7S9210=y
+# CONFIG_CLK_R9A06G032 is not set
+# CONFIG_CLK_RCAR_USB2_CLOCK_SEL is not set
+CONFIG_CLK_RENESAS_CPG_MSSR=y
+CONFIG_CLK_RENESAS_DIV6=y
+# CONFIG_HWSPINLOCK is not set
+
+#
+# Clock Source drivers
+#
+CONFIG_TIMER_OF=y
+CONFIG_TIMER_PROBE=y
+CONFIG_CLKSRC_MMIO=y
+# CONFIG_ARM_TIMER_SP804 is not set
+CONFIG_RENESAS_OSTM=y
+# CONFIG_MAILBOX is not set
 # CONFIG_IOMMU_SUPPORT is not set
+
+#
+# Remoteproc drivers
+#
+# CONFIG_REMOTEPROC is not set
+
+#
+# Rpmsg drivers
+#
+# CONFIG_RPMSG_VIRTIO is not set
+# CONFIG_SOUNDWIRE is not set
+
+#
+# SOC (System On Chip) specific Drivers
+#
+
+#
+# Amlogic SoC drivers
+#
+
+#
+# Broadcom SoC drivers
+#
+# CONFIG_SOC_BRCMSTB is not set
+
+#
+# NXP/Freescale QorIQ SoC drivers
+#
+
+#
+# i.MX SoC drivers
+#
+
+#
+# Qualcomm SoC drivers
+#
+CONFIG_SOC_RENESAS=y
+# CONFIG_SOC_TI is not set
+
+#
+# Xilinx SoC drivers
+#
+# CONFIG_XILINX_VCU is not set
+# CONFIG_PM_DEVFREQ is not set
+# CONFIG_EXTCON is not set
+# CONFIG_MEMORY is not set
+# CONFIG_IIO is not set
+# CONFIG_PWM is not set
+
+#
+# IRQ chip support
+#
+CONFIG_IRQCHIP=y
+CONFIG_ARM_GIC=y
+CONFIG_ARM_GIC_MAX_NR=1
+# CONFIG_IPACK_BUS is not set
+# CONFIG_RESET_CONTROLLER is not set
+# CONFIG_FMC is not set
+
+#
+# PHY Subsystem
+#
+CONFIG_GENERIC_PHY=y
+# CONFIG_BCM_KONA_USB2_PHY is not set
+# CONFIG_PHY_PXA_28NM_HSIC is not set
+# CONFIG_PHY_PXA_28NM_USB2 is not set
+# CONFIG_PHY_MAPPHONE_MDM6600 is not set
+# CONFIG_PHY_RCAR_GEN2 is not set
+# CONFIG_PHY_RCAR_GEN3_PCIE is not set
 CONFIG_PHY_RCAR_GEN3_USB2=y
+# CONFIG_PHY_RCAR_GEN3_USB3 is not set
+# CONFIG_POWERCAP is not set
+# CONFIG_MCB is not set
+# CONFIG_RAS is not set
+
+#
+# Android
+#
+# CONFIG_ANDROID is not set
+# CONFIG_DAX is not set
+CONFIG_NVMEM=y
+
+#
+# HW tracing support
+#
+# CONFIG_STM is not set
+# CONFIG_INTEL_TH is not set
+# CONFIG_FPGA is not set
+# CONFIG_FSI is not set
+# CONFIG_TEE is not set
+CONFIG_PM_OPP=y
+# CONFIG_SIOX is not set
+# CONFIG_SLIMBUS is not set
+
+#
+# File systems
+#
+CONFIG_DCACHE_WORD_ACCESS=y
+# CONFIG_EXT2_FS is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+# CONFIG_F2FS_FS is not set
+CONFIG_EXPORTFS=y
+# CONFIG_EXPORTFS_BLOCK_OPS is not set
+CONFIG_FILE_LOCKING=y
+CONFIG_MANDATORY_FILE_LOCKING=y
+# CONFIG_FS_ENCRYPTION is not set
+CONFIG_FSNOTIFY=y
 # CONFIG_DNOTIFY is not set
+CONFIG_INOTIFY_USER=y
+# CONFIG_FANOTIFY is not set
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_FUSE_FS is not set
+# CONFIG_OVERLAY_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
 CONFIG_MSDOS_FS=y
 CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_FAT_DEFAULT_UTF8 is not set
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+# CONFIG_PROC_CHILDREN is not set
+CONFIG_KERNFS=y
+CONFIG_SYSFS=y
 CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_TMPFS_XATTR is not set
+CONFIG_MEMFD_CREATE=y
+CONFIG_CONFIGFS_FS=y
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ORANGEFS_FS is not set
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_ECRYPT_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
 CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+# CONFIG_JFFS2_SUMMARY is not set
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+CONFIG_JFFS2_RTIME=y
 CONFIG_CRAMFS=y
+CONFIG_CRAMFS_BLOCKDEV=y
 CONFIG_CRAMFS_MTD=y
 CONFIG_SQUASHFS=y
+# CONFIG_SQUASHFS_FILE_CACHE is not set
 CONFIG_SQUASHFS_FILE_DIRECT=y
+CONFIG_SQUASHFS_DECOMP_SINGLE=y
+# CONFIG_SQUASHFS_DECOMP_MULTI is not set
+# CONFIG_SQUASHFS_DECOMP_MULTI_PERCPU is not set
+# CONFIG_SQUASHFS_XATTR is not set
+CONFIG_SQUASHFS_ZLIB=y
+# CONFIG_SQUASHFS_LZ4 is not set
+# CONFIG_SQUASHFS_LZO is not set
+# CONFIG_SQUASHFS_XZ is not set
+# CONFIG_SQUASHFS_ZSTD is not set
+# CONFIG_SQUASHFS_4K_DEVBLK_SIZE is not set
+# CONFIG_SQUASHFS_EMBEDDED is not set
+CONFIG_SQUASHFS_FRAGMENT_CACHE_SIZE=3
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_QNX6FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_PSTORE is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
 CONFIG_AXFS=y
 CONFIG_AXFS_PROFILING=y
+# CONFIG_AXFS_FIRST_MOUNT_AXFS_AS_ROOTFS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+# CONFIG_NFS_FS is not set
+# CONFIG_NFSD is not set
+# CONFIG_CEPH_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
 CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+# CONFIG_NLS_CODEPAGE_850 is not set
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
 CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+# CONFIG_NLS_ISO8859_15 is not set
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+# CONFIG_NLS_MAC_ROMAN is not set
+# CONFIG_NLS_MAC_CELTIC is not set
+# CONFIG_NLS_MAC_CENTEURO is not set
+# CONFIG_NLS_MAC_CROATIAN is not set
+# CONFIG_NLS_MAC_CYRILLIC is not set
+# CONFIG_NLS_MAC_GAELIC is not set
+# CONFIG_NLS_MAC_GREEK is not set
+# CONFIG_NLS_MAC_ICELAND is not set
+# CONFIG_NLS_MAC_INUIT is not set
+# CONFIG_NLS_MAC_ROMANIAN is not set
+# CONFIG_NLS_MAC_TURKISH is not set
+# CONFIG_NLS_UTF8 is not set
+# CONFIG_DLM is not set
+
+#
+# Security options
+#
 CONFIG_KEYS=y
+# CONFIG_PERSISTENT_KEYRINGS is not set
+# CONFIG_BIG_KEYS is not set
+# CONFIG_ENCRYPTED_KEYS is not set
+# CONFIG_KEY_DH_OPERATIONS is not set
+# CONFIG_SECURITY_DMESG_RESTRICT is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+CONFIG_HAVE_HARDENED_USERCOPY_ALLOCATOR=y
+# CONFIG_HARDENED_USERCOPY is not set
+# CONFIG_FORTIFY_SOURCE is not set
+# CONFIG_STATIC_USERMODEHELPER is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG=y
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_RNG_DEFAULT=y
+CONFIG_CRYPTO_AKCIPHER2=y
+CONFIG_CRYPTO_AKCIPHER=y
+CONFIG_CRYPTO_KPP2=y
+CONFIG_CRYPTO_ACOMP2=y
 CONFIG_CRYPTO_RSA=y
+# CONFIG_CRYPTO_DH is not set
+# CONFIG_CRYPTO_ECDH is not set
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_USER is not set
+CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
+# CONFIG_CRYPTO_GF128MUL is not set
+CONFIG_CRYPTO_NULL=y
+CONFIG_CRYPTO_NULL2=y
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_MCRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_CHACHA20POLY1305 is not set
+# CONFIG_CRYPTO_AEGIS128 is not set
+# CONFIG_CRYPTO_AEGIS128L is not set
+# CONFIG_CRYPTO_AEGIS256 is not set
+# CONFIG_CRYPTO_MORUS640 is not set
+# CONFIG_CRYPTO_MORUS1280 is not set
+# CONFIG_CRYPTO_SEQIV is not set
+CONFIG_CRYPTO_ECHAINIV=y
+
+#
+# Block modes
+#
+# CONFIG_CRYPTO_CBC is not set
+# CONFIG_CRYPTO_CFB is not set
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+# CONFIG_CRYPTO_ECB is not set
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+# CONFIG_CRYPTO_KEYWRAP is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_CMAC is not set
+CONFIG_CRYPTO_HMAC=y
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_CRC32 is not set
+# CONFIG_CRYPTO_CRCT10DIF is not set
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_POLY1305 is not set
+# CONFIG_CRYPTO_MD4 is not set
+# CONFIG_CRYPTO_MD5 is not set
+# CONFIG_CRYPTO_MICHAEL_MIC is not set
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+CONFIG_CRYPTO_SHA256=y
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_SHA3 is not set
+# CONFIG_CRYPTO_SM3 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_AES_TI is not set
+# CONFIG_CRYPTO_ANUBIS is not set
+# CONFIG_CRYPTO_ARC4 is not set
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+# CONFIG_CRYPTO_CAST5 is not set
+# CONFIG_CRYPTO_CAST6 is not set
+# CONFIG_CRYPTO_DES is not set
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_CHACHA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_SM4 is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+# CONFIG_CRYPTO_DEFLATE is not set
+# CONFIG_CRYPTO_LZO is not set
+# CONFIG_CRYPTO_842 is not set
+# CONFIG_CRYPTO_LZ4 is not set
+# CONFIG_CRYPTO_LZ4HC is not set
+# CONFIG_CRYPTO_ZSTD is not set
+
+#
+# Random Number Generation
+#
+# CONFIG_CRYPTO_ANSI_CPRNG is not set
+CONFIG_CRYPTO_DRBG_MENU=y
+CONFIG_CRYPTO_DRBG_HMAC=y
+# CONFIG_CRYPTO_DRBG_HASH is not set
+CONFIG_CRYPTO_DRBG=y
+CONFIG_CRYPTO_JITTERENTROPY=y
+# CONFIG_CRYPTO_USER_API_HASH is not set
+# CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+# CONFIG_CRYPTO_USER_API_RNG is not set
+# CONFIG_CRYPTO_USER_API_AEAD is not set
+CONFIG_CRYPTO_HASH_INFO=y
+CONFIG_CRYPTO_HW=y
+# CONFIG_CRYPTO_DEV_CCREE is not set
 CONFIG_ASYMMETRIC_KEY_TYPE=y
 CONFIG_ASYMMETRIC_PUBLIC_KEY_SUBTYPE=y
 CONFIG_X509_CERTIFICATE_PARSER=y
 CONFIG_PKCS7_MESSAGE_PARSER=y
+
+#
+# Certificates for signature checking
+#
+# CONFIG_SYSTEM_TRUSTED_KEYRING is not set
+# CONFIG_SYSTEM_BLACKLIST_KEYRING is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_HAVE_ARCH_BITREVERSE=y
+CONFIG_RATIONAL=y
+CONFIG_GENERIC_STRNCPY_FROM_USER=y
+CONFIG_GENERIC_STRNLEN_USER=y
+CONFIG_GENERIC_NET_UTILS=y
+CONFIG_GENERIC_PCI_IOMAP=y
+CONFIG_ARCH_USE_CMPXCHG_LOCKREF=y
+# CONFIG_CRC_CCITT is not set
+# CONFIG_CRC16 is not set
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC32_SELFTEST is not set
+CONFIG_CRC32_SLICEBY8=y
+# CONFIG_CRC32_SLICEBY4 is not set
+# CONFIG_CRC32_SARWATE is not set
+# CONFIG_CRC32_BIT is not set
+# CONFIG_CRC64 is not set
+# CONFIG_CRC4 is not set
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+# CONFIG_CRC8 is not set
+# CONFIG_RANDOM32_SELFTEST is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_LZ4_DECOMPRESS=y
+CONFIG_XZ_DEC=y
+CONFIG_XZ_DEC_X86=y
+CONFIG_XZ_DEC_POWERPC=y
+CONFIG_XZ_DEC_IA64=y
+CONFIG_XZ_DEC_ARM=y
+CONFIG_XZ_DEC_ARMTHUMB=y
+CONFIG_XZ_DEC_SPARC=y
+CONFIG_XZ_DEC_BCJ=y
+# CONFIG_XZ_DEC_TEST is not set
+CONFIG_DECOMPRESS_GZIP=y
+CONFIG_DECOMPRESS_BZIP2=y
+CONFIG_DECOMPRESS_LZMA=y
+CONFIG_DECOMPRESS_XZ=y
+CONFIG_DECOMPRESS_LZO=y
+CONFIG_DECOMPRESS_LZ4=y
+CONFIG_GENERIC_ALLOCATOR=y
+CONFIG_ASSOCIATIVE_ARRAY=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_DMA=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SGL_ALLOC=y
+CONFIG_DQL=y
+CONFIG_GLOB=y
+# CONFIG_GLOB_SELFTEST is not set
+CONFIG_NLATTR=y
+CONFIG_CLZ_TAB=y
+# CONFIG_CORDIC is not set
+# CONFIG_DDR is not set
+# CONFIG_IRQ_POLL is not set
+CONFIG_MPILIB=y
+CONFIG_LIBFDT=y
+CONFIG_OID_REGISTRY=y
+CONFIG_FONT_SUPPORT=y
+# CONFIG_FONTS is not set
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+CONFIG_SG_POOL=y
+CONFIG_ARCH_HAS_SG_CHAIN=y
+CONFIG_SBITMAP=y
+# CONFIG_STRING_SELFTEST is not set
+
+#
+# Kernel hacking
+#
+
+#
+# printk and dmesg options
+#
 CONFIG_PRINTK_TIME=y
+CONFIG_CONSOLE_LOGLEVEL_DEFAULT=7
+CONFIG_CONSOLE_LOGLEVEL_QUIET=4
+CONFIG_MESSAGE_LOGLEVEL_DEFAULT=4
+# CONFIG_BOOT_PRINTK_DELAY is not set
+
+#
+# Compile-time checks and compiler options
+#
 CONFIG_DEBUG_INFO=y
+# CONFIG_DEBUG_INFO_REDUCED is not set
+# CONFIG_DEBUG_INFO_SPLIT is not set
+# CONFIG_DEBUG_INFO_DWARF4 is not set
+# CONFIG_GDB_SCRIPTS is not set
 # CONFIG_ENABLE_MUST_CHECK is not set
+CONFIG_FRAME_WARN=1024
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_READABLE_ASM is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_PAGE_OWNER is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_SECTION_MISMATCH is not set
+CONFIG_SECTION_MISMATCH_WARN_ONLY=y
+# CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+# CONFIG_MAGIC_SYSRQ is not set
+CONFIG_DEBUG_KERNEL=y
+
+#
+# Memory Debugging
+#
+# CONFIG_PAGE_EXTENSION is not set
+# CONFIG_DEBUG_PAGEALLOC is not set
+# CONFIG_PAGE_POISONING is not set
+# CONFIG_DEBUG_OBJECTS is not set
+# CONFIG_DEBUG_SLAB is not set
+CONFIG_HAVE_DEBUG_KMEMLEAK=y
+# CONFIG_DEBUG_KMEMLEAK is not set
+# CONFIG_DEBUG_STACK_USAGE is not set
+# CONFIG_DEBUG_VM is not set
+CONFIG_ARCH_HAS_DEBUG_VIRTUAL=y
+# CONFIG_DEBUG_VIRTUAL is not set
+# CONFIG_DEBUG_MEMORY_INIT is not set
+CONFIG_ARCH_HAS_KCOV=y
+CONFIG_CC_HAS_SANCOV_TRACE_PC=y
+# CONFIG_KCOV is not set
+# CONFIG_DEBUG_SHIRQ is not set
+
+#
+# Debug Lockups and Hangs
+#
+# CONFIG_SOFTLOCKUP_DETECTOR is not set
+# CONFIG_DETECT_HUNG_TASK is not set
+# CONFIG_WQ_WATCHDOG is not set
+# CONFIG_PANIC_ON_OOPS is not set
+CONFIG_PANIC_ON_OOPS_VALUE=0
+CONFIG_PANIC_TIMEOUT=0
+CONFIG_SCHED_DEBUG=y
+# CONFIG_SCHEDSTATS is not set
+# CONFIG_SCHED_STACK_END_CHECK is not set
+# CONFIG_DEBUG_TIMEKEEPING is not set
+
+#
+# Lock Debugging (spinlocks, mutexes, etc...)
+#
+CONFIG_LOCK_DEBUGGING_SUPPORT=y
+# CONFIG_PROVE_LOCKING is not set
+# CONFIG_LOCK_STAT is not set
+# CONFIG_DEBUG_RT_MUTEXES is not set
+# CONFIG_DEBUG_SPINLOCK is not set
+# CONFIG_DEBUG_MUTEXES is not set
+# CONFIG_DEBUG_WW_MUTEX_SLOWPATH is not set
+# CONFIG_DEBUG_LOCK_ALLOC is not set
+# CONFIG_DEBUG_ATOMIC_SLEEP is not set
+# CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+# CONFIG_LOCK_TORTURE_TEST is not set
+# CONFIG_WW_MUTEX_SELFTEST is not set
+# CONFIG_STACKTRACE is not set
+# CONFIG_WARN_ALL_UNSEEDED_RANDOM is not set
+# CONFIG_DEBUG_KOBJECT is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+# CONFIG_DEBUG_LIST is not set
+# CONFIG_DEBUG_PI_LIST is not set
+# CONFIG_DEBUG_SG is not set
+# CONFIG_DEBUG_NOTIFIERS is not set
+# CONFIG_DEBUG_CREDENTIALS is not set
+
+#
+# RCU Debugging
+#
+# CONFIG_RCU_PERF_TEST is not set
+# CONFIG_RCU_TORTURE_TEST is not set
+# CONFIG_RCU_TRACE is not set
+# CONFIG_RCU_EQS_DEBUG is not set
+# CONFIG_DEBUG_WQ_FORCE_RR_CPU is not set
+# CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+# CONFIG_NOTIFIER_ERROR_INJECTION is not set
+# CONFIG_FAULT_INJECTION is not set
+# CONFIG_LATENCYTOP is not set
+CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+CONFIG_HAVE_C_RECORDMCOUNT=y
+CONFIG_TRACING_SUPPORT=y
+CONFIG_FTRACE=y
+# CONFIG_PREEMPTIRQ_EVENTS is not set
+# CONFIG_IRQSOFF_TRACER is not set
+# CONFIG_SCHED_TRACER is not set
+# CONFIG_HWLAT_TRACER is not set
+# CONFIG_ENABLE_DEFAULT_TRACERS is not set
+# CONFIG_FTRACE_SYSCALLS is not set
+# CONFIG_TRACER_SNAPSHOT is not set
+CONFIG_BRANCH_PROFILE_NONE=y
+# CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
+# CONFIG_PROFILE_ALL_BRANCHES is not set
+# CONFIG_BLK_DEV_IO_TRACE is not set
+# CONFIG_TRACEPOINT_BENCHMARK is not set
+CONFIG_TRACING_EVENTS_GPIO=y
+# CONFIG_DMA_API_DEBUG is not set
 # CONFIG_RUNTIME_TESTING_MENU is not set
+# CONFIG_MEMTEST is not set
+# CONFIG_BUG_ON_DATA_CORRUPTION is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+# CONFIG_KGDB is not set
+# CONFIG_UBSAN is not set
+CONFIG_ARCH_HAS_DEVMEM_IS_ALLOWED=y
+# CONFIG_STRICT_DEVMEM is not set
+# CONFIG_ARM_PTDUMP_DEBUGFS is not set
+# CONFIG_DEBUG_WX is not set
+CONFIG_ARM_UNWIND=y
+# CONFIG_DEBUG_USER is not set
+# CONFIG_DEBUG_LL is not set
+CONFIG_DEBUG_LL_INCLUDE="mach/debug-macro.S"
+CONFIG_UNCOMPRESS_INCLUDE="debug/uncompress.h"
+# CONFIG_PID_IN_CONTEXTIDR is not set
+# CONFIG_CORESIGHT is not set
diff --git a/drivers/clk/renesas/r7s9210-cpg-mssr.c b/drivers/clk/renesas/r7s9210-cpg-mssr.c
old mode 100644
new mode 100755
index 8bad69a21..9053f223c
--- a/drivers/clk/renesas/r7s9210-cpg-mssr.c
+++ b/drivers/clk/renesas/r7s9210-cpg-mssr.c
@@ -92,6 +92,8 @@ static const struct mssr_mod_clk r7s9210_mod_clks[] __initconst = {
 	DEF_MOD_STB("ether1",	 64,	R7S9210_CLK_B),
 	DEF_MOD_STB("ether0",	 65,	R7S9210_CLK_B),
 
+//	DEF_MOD_STB("audio0",	73,	R7S9210_CLK_P1),
+
 	DEF_MOD_STB("vdc6",	 81,	R7S9210_CLK_P1),
 	DEF_MOD_STB("i2c3",	 84,	R7S9210_CLK_P1),
 	DEF_MOD_STB("i2c2",	 85,	R7S9210_CLK_P1),
diff --git a/drivers/dma/rza-dma.c b/drivers/dma/rza-dma.c
index 3ff02a237..0afe4d14d 100644
--- a/drivers/dma/rza-dma.c
+++ b/drivers/dma/rza-dma.c
@@ -429,7 +429,7 @@ static bool dma_irq_handle_channel(struct dmac_channel *channel)
 
 	chctrl = rzadma_ch_readl(channel, CHCTRL, 1);
 	rzadma_ch_writel(channel,
-			chctrl | CHCTRL_CLREND | CHCTRL_CLRRQ,
+			chctrl | CHCTRL_CLREND,
 			CHCTRL, 1);
 schedule:
 #ifndef THREADED_CALLBACK
diff --git a/include/sound/sh_rza2.h b/include/sound/sh_rza2.h
new file mode 100755
index 000000000..46d7dc7fc
--- /dev/null
+++ b/include/sound/sh_rza2.h
@@ -0,0 +1,1358 @@
+/*
+ * include/sound/sh_scux.h
+ *     This file is header file for SCUX peripheral.
+ *
+ * Copyright (C) 2013 Renesas Electronics Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+#ifndef SH_SCUX_H
+#define SH_SCUX_H
+
+#include <linux/dmaengine.h>
+#include <linux/list.h>
+#include <linux/types.h>
+#include <sound/soc.h>
+
+/************************************************************************
+	ALSA
+************************************************************************/
+/* buffer information */
+#define SCU_BUFFER_BYTES_MAX	(32 * 1024)
+#define SCU_PERIOD_BYTES_MIN	512
+#define SCU_PERIOD_BYTES_MAX	8192
+#define SCU_PERIODS_MIN		(SCU_BUFFER_BYTES_MAX / SCU_PERIOD_BYTES_MAX)
+#define SCU_PERIODS_MAX		(SCU_BUFFER_BYTES_MAX / SCU_PERIOD_BYTES_MIN)
+
+/* scux dapm route playback route */
+#define	W_SSI0			0x00000001
+#define	W_SRC1			0x00000002
+#define	W_DVC1			0x00000004
+#define RP_MEM_SSI0		W_SSI0
+#define RP_MEM_SRC1_SSI0	(W_SSI0 | W_SRC1)
+#define RP_MEM_SRC1_DVC1_SSI0	(W_SSI0 | W_SRC1 | W_DVC1)
+/* scux dapm route capture route */
+#define	W_SSI0_CAP		0x00010000
+#define	W_SRC0			0x00020000
+#define	RC_SSI0_MEM		W_SSI0_CAP
+#define RC_SSI0_SRC0_MEM	(W_SSI0_CAP | W_SRC0)
+/* dma direction */
+#define	DMA_DIR(d)	((d == 0) ? DMA_TO_DEVICE : DMA_FROM_DEVICE)
+
+/* IP channel */
+#define	MAXCH_SSIF	6
+#define	MAXCH_SRC	2
+#define	MAXCH_DVU	4
+#define MAXCH_DMA	5 /* DMA slave IDs .ex:RP_MEM_SRC1_DVC1_SSI0 */
+
+/* dai Control */
+#define CTRL_PLAYBACK	0
+#define CTRL_CAPTURE	1
+
+/* clock */
+#define AUDIO_X1	11289600	/* 11.2896Mhz */
+
+/*  rate  */
+#define	RATE_MAX	0x7fffffff
+
+/*  volume  */
+#define	VOLUME_MAX_DVC	0x007fffff
+#define	VOLUME_DEFAULT	0x00100000
+
+/* SRC channel */
+enum {
+	SRC0,
+	SRC1,
+	SRC2,
+	SRC3,
+};
+#define	SCUX_2SRC0_0			(0)
+#define	SCUX_2SRC0_1			(1)
+
+/* SRC_BSDSR */
+#define	SRC_BSD012349_BUFDATA_1_6	(0x180 << 16)
+#define	SRC_BSD012349_BUFDATA_1_4	(0x100 << 16)
+#define	SRC_BSD012349_BUFDATA_1_3	(0x0c0 << 16)
+#define	SRC_BSD012349_BUFDATA_1_2	(0x080 << 16)
+#define	SRC_BSD012349_BUFDATA_2_3	(0x060 << 16)
+#define	SRC_BSD012349_BUFDATA_1_1	(0x040 << 16)
+#define	SRC_BSD5678_BUFDATA_1_6		(0x240 << 16)
+#define	SRC_BSD5678_BUFDATA_1_4		(0x180 << 16)
+#define	SRC_BSD5678_BUFDATA_1_3		(0x120 << 16)
+#define	SRC_BSD5678_BUFDATA_1_2		(0x0c0 << 16)
+#define	SRC_BSD5678_BUFDATA_2_3		(0x090 << 16)
+#define	SRC_BSD5678_BUFDATA_1_1		(0x060 << 16)
+
+/* SRC_BSISR */
+#define	SRC_BSI_IJECPREC		(0x10 << 16)
+#define	SRC_BSI_IJECSIZE_1_6		0x60
+#define	SRC_BSI_IJECSIZE_1_4		0x40
+#define	SRC_BSI_IJECSIZE_1_3		0x30
+#define	SRC_BSI_IJECSIZE_1_2		0x20
+#define	SRC_BSI_IJECSIZE_2_3		0x20
+#define	SRC_BSI_IJECSIZE_1_1		0x20
+
+/* BUFIJEC bit */
+#define BUFIJEC_LOW_DELAY_OFF		(0uL)
+#define BUFIJEC_LOW_DELAY_ON		(5uL)
+#define	BFSSR_BIT_BUFDATA_16BYTE	(16<<16)
+
+/* DVC channel */
+enum {
+	DVC0,
+	DVC1,
+};
+
+/* SSI channel */
+enum {
+	SSI0,
+	SSI1,
+	SSI2,
+	SSI3,
+	SSI4,
+	SSI5,
+	SSI6,
+	SSI7,
+	SSI8,
+	SSI9,
+};
+
+/* SSI input/output */
+#define	SSI_OUT		0
+#define	SSI_IN		1
+
+/* SSI mode */
+enum {
+	SSI_MASTER,
+	SSI_SLAVE,
+};
+
+/* SSI dependant/independat transfer */
+enum {
+	SSI_DEPENDANT,
+	SSI_INDEPENDANT,
+};
+
+/************************************************************************
+	structure
+************************************************************************/
+struct scu_pcm_callback {
+	void (*init_ssi)(int, int, int, int, int);
+	void (*init_src)(int, unsigned int, unsigned int);
+	void (*init_dvc)(int);
+	void (*deinit_ssi)(int, int, int, int);
+	void (*deinit_src)(int);
+	void (*deinit_dvc)(int);
+};
+struct scu_route_info {
+	int p_route;		/* playback route */
+	int c_route;		/* capture route */
+	/* snd_kcontrol */
+	int route_ssi[MAXCH_SSIF];
+	int route_src[MAXCH_SRC];
+	int route_mix[1];
+	int route_dvc[MAXCH_DVU];
+	/* playback callback */
+	struct scu_pcm_callback pcb;
+	/* capture callback */
+	struct scu_pcm_callback ccb;
+};
+
+struct scu_clock_info {
+	struct clk *adg_clk;
+	struct clk *scu_clk;
+	struct clk *src0_clk;
+	struct clk *src1_clk;
+	struct clk *dvc0_clk;
+	struct clk *dvc1_clk;
+	struct clk *ssiu_clk;
+	struct clk *ssi0_clk;
+	struct clk *ssi1_clk;
+};
+
+struct scu_config {
+	int label;
+	int value;
+};
+
+struct scu_platform_data {
+	int ssi_master;
+	int ssi_slave;
+	struct scu_config *ssi_ch;
+	int ssi_ch_num;
+	struct scu_config *src_ch;
+	int src_ch_num;
+	struct scu_config *dvc_ch;
+	int dvc_ch_num;
+	int dma_slave_maxnum;
+	struct scu_config *audma_slave;
+	int audma_slave_num;
+	struct scu_config *ssi_depend;
+	int ssi_depend_num;
+	struct scu_config *ssi_mode;
+	int ssi_mode_num;
+	struct scu_config *src_mode;
+	int src_mode_num;
+};
+
+struct scu_pcm_info {
+	int flag_first;			/* for PCM 1st process */
+	int flag_start;			/* for DMA control */
+	unsigned int buf_offset;	/* for buffer control */
+	unsigned int tran_size;		/* total size of transferred frame */
+	unsigned int period_piece;	/* piece of period to transfer */
+	unsigned int tran_period_piece;	/* transferred piece of period */
+	spinlock_t pcm_lock;		/* for trigger process */
+	struct dma_chan **de_chan;
+	struct rza1_dma_slave *de_param;
+	struct work_struct work;
+	struct workqueue_struct *workq;
+	struct scu_route_info *routeinfo;
+	struct snd_pcm_substream *ss;
+	struct scu_platform_data *pdata;
+};
+
+/************************************************************************
+	inline function
+************************************************************************/
+static inline int scu_find_data(int val, struct scu_config *data, int size)
+{
+	int i;
+	struct scu_config *data_p = data;
+
+	for (i = 0; i < size; data_p++, i++) {
+		if (val == data_p->label)
+			return data_p->value;
+	}
+
+	return -1;
+}
+/******************************************************************************
+ ==== SCUX ====
+******************************************************************************/
+enum scux_ch {
+	SCUX_CH_0,
+	SCUX_CH_1,
+	SCUX_CH_2,
+	SCUX_CH_3,
+	NUM_SCUX_CH,	/* 4ch */
+};
+/******************************************************************************
+ ==== SCUX register value list ====
+******************************************************************************/
+/* IPCIR Register Value */
+#define IPCIR_INIT_ON		(1uL)	/* Set INIT of IPC */
+
+/* IPSLR Register Value */
+#define IPSLR_SSIF_IPC_ASYNC	(1uL)
+#define IPSLR_FFD_IPC_ASYNC	(3uL)
+#define IPSLR_FFD_IPC_SYNC	(4uL)
+
+/* OPCIR Register Value */
+#define OPCIR_INIT_ON		(1uL)	/* Set INIT of OPC */
+
+/* OPSLR Register Value */
+#define OPSLR_ASYNC_OPC_DVU	(1uL)
+#define OPSLR_ASYNC_OPC_FFU	(3uL)
+#define OPSLR_SYNC_OPC_FFU	(4uL)
+
+/* FFDIR Register Value */
+#define FFDIR_INIT_OFF		(0uL)	/* Set INIT of FFD */
+#define FFDIR_INIT_ON		(1uL)	/* Set INIT of FFD */
+
+/* FDAIR Register Value */
+#define FDAIR_AUDIO_CH_NONE	(0uL)
+#define FDAIR_AUDIO_CH_1	(1uL)
+#define FDAIR_AUDIO_CH_2	(2uL)
+#define FDAIR_AUDIO_CH_4	(4uL)
+#define FDAIR_AUDIO_CH_6	(6uL)
+#define FDAIR_AUDIO_CH_8	(8uL)
+
+/* DRQSR Register Value */
+#define DRQSR_REQ_SIZE_256	(0uL)	/* 256data (FFU0_0 and FFU0_1 Only) */
+#define DRQSR_REQ_SIZE_128	(1uL)	/* 128data (FFU0_0 and FFU0_1 Only) */
+#define DRQSR_REQ_SIZE_64	(2uL)	/* 64data   */
+#define DRQSR_REQ_SIZE_32	(3uL)	/* 32data   */
+#define DRQSR_REQ_SIZE_16	(4uL)	/* 16data   */
+#define DRQSR_REQ_SIZE_8	(5uL)	/* 8data    */
+#define DRQSR_REQ_SIZE_4	(6uL)	/* 4data    */
+#define DRQSR_REQ_SIZE_2	(7uL)	/* 2data    */
+#define DRQSR_REQ_SIZE_1	(8uL)	/* 1data    */
+
+/* FFDPR Register Value */
+#define FFDPR_NO_PASS_SELECT	(0uL)
+#define FFDPR_CIM_FFD_IPC_ASYNC	(1uL)
+#define FFDPR_CIM_FFD_IPC_SYNC	(2uL)
+
+/* FFDBR Register Value */
+#define FFDBR_HALT_ON		(0uL)
+#define FFDBR_BOOT_ON		(1uL)
+
+/* DEVMR Register Value */
+/* Configure SCUX
+DEVMR_FFD0_n - FFD0_n FIFO Download Event Mask Register(n=0,1,2,3)
+b31   DEVMUF - FFD Underflow Mask - Interrupt enabled
+b30   DEVMOF - FFD Overflow Mask - Interrupt enabled
+b29   DEVMOL - FFD Overlap Mask - Interrupt enabled
+b28   DEVMIUF - FFD Initialization Underflow Mask - Interrupt enabled
+b15   DEVMRQ - FFD Request Packet Mask - Interrupt disabled
+Other Reserved - The write value should always be 0 */
+/* Initial value of DEVMR_FFD0_n Register */
+#define DEVMR_VALUE         (0xF0000000uL)
+
+/* DEVCR Register Value */
+/* Request ON bits make 0, Other bits make 1 */
+#define DEVCR_REG_MASK      (0xF0008000uL)
+
+/* FFUIR Register Value */
+#define FFUIR_INIT_OFF		(0uL)		/* Set INIT of FFU */
+#define FFUIR_INIT_ON		(1uL)		/* Set INIT of FFU */
+
+/* FUAIR Register Value */
+#define FUAIR_AUDIO_CH_NONE	(0uL)
+#define FUAIR_AUDIO_CH_1	(1uL)
+#define FUAIR_AUDIO_CH_2	(2uL)
+#define FUAIR_AUDIO_CH_4	(4uL)
+#define FUAIR_AUDIO_CH_6	(6uL)
+#define FUAIR_AUDIO_CH_8	(8uL)
+
+/* URQSR Register Value */
+/*URQSR_FFU0_n - FFU0_n FIFO Upload Request Size Register(n=0,1,2,3)
+b3:b0 SIZE - Request size data - Set parameter
+Other Reserved - The write value should always be 0 */
+#define URQSR_CH0CH1_REQ_SIZE_256	(0uL)	/* 256data (FFU0_0,0_1 Only) */
+#define URQSR_CH0CH1_REQ_SIZE_128	(1uL)	/* 128data (FFU0_0,0_1 Only) */
+#define URQSR_CH0CH1_REQ_SIZE_64	(2uL)	/* 64data   */
+#define URQSR_CH0CH1_REQ_SIZE_32	(3uL)	/* 32data   */
+#define URQSR_CH0CH1_REQ_SIZE_16	(4uL)	/* 16data   */
+#define URQSR_CH0CH1_REQ_SIZE_8		(5uL)	/* 8data    */
+#define URQSR_CH0CH1_REQ_SIZE_4		(6uL)	/* 4data    */
+#define URQSR_CH0CH1_REQ_SIZE_2		(7uL)	/* 2data    */
+#define URQSR_CH0CH1_REQ_SIZE_1		(8uL)	/* 1data    */
+/* In the case of SCUX Channel 2 or 3, a value of 64 data is 0.*/
+#define URQSR_CH2CH3_REQ_SIZE_64	(0uL)	/* 64data   */
+#define URQSR_CH2CH3_REQ_SIZE_32	(1uL)	/* 32data   */
+#define URQSR_CH2CH3_REQ_SIZE_16	(2uL)	/* 16data   */
+#define URQSR_CH2CH3_REQ_SIZE_8		(3uL)	/* 8data    */
+#define URQSR_CH2CH3_REQ_SIZE_4		(4uL)	/* 4data    */
+#define URQSR_CH2CH3_REQ_SIZE_2		(5uL)	/* 2data    */
+#define URQSR_CH2CH3_REQ_SIZE_1		(6uL)	/* 1data    */
+
+/* FFUPR Register Value */
+#define FFUPR_NO_PASS_SELECT	(0uL)
+#define FFUPR_CIM_FFU_OPC_ASYNC	(1uL)
+#define FFUPR_CIM_FFU_OPC_SYNC	(2uL)
+
+/* UEVMR Register Value */
+/* Initial value of UEVMR_FFU0_n Register */
+#define UEVMR_VALUE         (0xE0000000uL)
+
+/* UEVCR Register Value */
+#define UEVCR_REG_MASK		(0xE0008000uL)
+#define UEVCR_BIT_UEVCUF	(0x80000000uL)
+#define UEVCR_BIT_UEVCOF	(0x40000000uL)
+#define UEVCR_BIT_UEVCOL	(0x20000000uL)
+#define UEVCR_BIT_UEVCRQ	(0x00008000uL)
+
+/* SRCIR Register Value */
+#define INIT_OFF		(0uL)	/* Clear INIT of SRC */
+#define SRCIR_INIT_ON		(1uL)	/* Set INIT of SRC */
+
+/* SRC_ADINR */
+#define	SRCADIN_OTBL_24BIT	(0<<16)
+#define	SRCADIN_OTBL_22BIT	(2<<16)
+#define	SRCADIN_OTBL_20BIT	(4<<16)
+#define	SRCADIN_OTBL_18BIT	(6<<16)
+#define	SRCADIN_OTBL_16BIT	(8<<16)
+#define	SRCADIN_OTBL_8BIT	(16<<16)
+#define	SRCADIN_CHNUM_0		(0<<0)
+#define	SRCADIN_CHNUM_1		(1<<0)
+#define	SRCADIN_CHNUM_2		(2<<0)
+#define	SRCADIN_CHNUM_4		(4<<0)
+#define	SRCADIN_CHNUM_6		(6<<0)
+#define	SRCADIN_CHNUM_8		(8<<0)
+
+/* SADIR Register Value */
+/* bit 3-0 */
+#define SADIR_AUDIO_CH_NONE	(0uL)
+#define SADIR_AUDIO_CH_1	(1uL)
+#define SADIR_AUDIO_CH_2	(2uL)
+#define SADIR_AUDIO_CH_4	(4uL)
+#define SADIR_AUDIO_CH_6	(6uL)
+#define SADIR_AUDIO_CH_8	(8uL)
+/*bit 20-16*/
+#define SADIR_OTBL_24BIT	(0<<16)
+#define SADIR_OTBL_16BIT	(8<<16)
+
+/* SRCBR Register Value */
+/*SRCBRp_2SRC0_m - 2SRC0_m Bypass Register p(m=0,1 p=0,1)
+b0    BYPASS - Bypass Mode - Set parameter
+Other Reserved - The write value should always be 0 */
+#define SRCBR_BYPASS_OFF	(0uL)
+#define SRCBR_BYPASS_ON		(1uL)
+
+/* IFSCR Register Value */
+/* IFSCRp_2SRC0_m - 2SRC0_m IFS Control Register p(m=0,1 p=0,1)
+b0    INTIFSEN - INTIFS value setting enable - Initial value enabled
+Other Reserved - The write value should always be 0 */
+/* Value of IFSCRp_2SRC0_m Register */
+#define IFSCR_VALUE		(1uL)
+
+
+/* IFSVR Register Value */
+#define IFSVR_INTIFS_NOIFSVR	(0uL)
+#define NUM_OUTPUT_FS		(7uL)
+#define NUM_INPUT_FS		(12uL)
+#define	SRC_IFS_FSO		(0x00400000uL)	/* 2^22 */
+#define	SRC_IFS_8KHZ		(8000uL)
+#define	SRC_IFS_11KHZ		(11025uL)
+#define	SRC_IFS_12KHZ		(12000uL)
+#define	SRC_IFS_16KHZ		(16000uL)
+#define	SRC_IFS_22KHZ		(22050uL)
+#define	SRC_IFS_24KHZ		(24000uL)
+#define	SRC_IFS_32KHZ		(32000uL)
+#define	SRC_IFS_44KHZ		(44100uL)
+#define	SRC_IFS_48KHZ		(48000uL)
+#define INTIFS_IN44K_OUT8K	0x160cccc;	/* IFSVRp_2SRC0_0 INTIFS */
+#define INTIFS_IN44K_OUT11K	0x1000000;	/* IFSVRp_2SRC0_0 INTIFS */
+#define INTIFS_IN44K_OUT12K	0x0EB3333;	/* IFSVRp_2SRC0_0 INTIFS */
+#define INTIFS_IN44K_OUT16K	0x0b06666;	/* IFSVRp_2SRC0_0 INTIFS */
+#define INTIFS_IN44K_OUT22K	0x0802531;	/* IFSVRp_2SRC0_0 INTIFS */
+#define INTIFS_IN44K_OUT24K	0x0759999;	/* IFSVRp_2SRC0_0 INTIFS */
+#define INTIFS_IN44K_OUT32K	0x0583333;	/* IFSVRp_2SRC0_0 INTIFS */
+#define INTIFS_IN44K_OUT44K	0x0400000;	/* IFSVRp_2SRC0_0 INTIFS */
+#define INTIFS_IN44K_OUT48K	0x03acccc;	/* IFSVRp_2SRC0_0 INTIFS */
+
+#define INTIFS_IN8K_OUT44K	0x00b9c27;	/* IFSVRp_2SRC0_0 INTIFS */
+#define INTIFS_IN11K_OUT44K	0x0100000;	/* IFSVRp_2SRC0_0 INTIFS */
+#define INTIFS_IN12K_OUT44K	0x0116a3b;	/* IFSVRp_2SRC0_0 INTIFS */
+#define INTIFS_IN16K_OUT44K	0x017384e;	/* IFSVRp_2SRC0_0 INTIFS */
+#define INTIFS_IN22K_OUT44K	0x0200000;	/* IFSVRp_2SRC0_0 INTIFS */
+#define INTIFS_IN24K_OUT44K	0x022d476;	/* IFSVRp_2SRC0_0 INTIFS */
+#define INTIFS_IN32K_OUT44K	0x02e709d;	/* IFSVRp_2SRC0_0 INTIFS */
+#define INTIFS_IN44K_OUT44K	0x0400000;	/* IFSVRp_2SRC0_0 INTIFS */
+#define INTIFS_IN48K_OUT44K	0x045a8ec;	/* IFSVRp_2SRC0_0 INTIFS */
+
+/* SRCCR Register Value */
+/* SRCCRp_2SRC0_m - 2SRC0_m Control Register p(m=0,1 p=0,1)
+b20     WATMD - Wait Time Control of SRC - Set parameter
+b12     BUFMD - Low Delay Control by Buffer Size of SRC - Set parameter
+b0      SRCMD - Select SRC Mode of SRCI - Set parameter
+b16,8,4 Reserved - These bits should be set to 1
+Other   Reserved - The write value should always be 0 */
+#define	SRC_CR_BIT16		(1<<16)
+#define	SRC_CR_BIT12		(1<<12)
+#define	SRC_CR_LOW_DELAY_NON	(0<<12)
+#define	SRC_CR_BIT8		(1<<8)
+#define	SRC_CR_BIT4		(1<<4)
+#define	SRC_CR_SYNC		(1<<0)
+#define	SRC_CR_ASYNC		(0<<0)
+
+/* MNFSR Register Value */
+/*MNFSRp_2SRC0_m - 2SRC0_m Minimum FS Setting Register p(m=0,1 p=0,1)
+b27:b0 MINFS - Set the minimum FS ratio - Set parameter
+Other  Reserved - The write value should always be 0 */
+/* value of min_fs_ratio */
+#define MIN_FS_RATIO_90			(90)	/* 90% */
+#define MIN_FS_RATIO_98			(98)	/* 98% */
+#define MIN_FS_RATIO_100		(100)	/* 100 */
+#define MIN_FS_RATIO_DECIMAL_DIGITS	(24uL)	/* digits of min_fs_ratio */
+
+/* BFSSR Register Value */
+/* BFSSRp_2SRC0_m - 2SRC0_m Buffer Size Setting Register p(m=0,1 p=0,1)
+b25:b16 BUFDATA - Set the buffer size of 1 channel in DATA RAM - Set parameter
+b3:b0   BUFIJEC - Set the buffer size of 1 channel in IJEC RAM -
+	Sets 0x5 for low delay mode
+Other   Reserved - The write value should always be 0 */
+/* Sets 0x80 for low delay mode.1 */
+#define BFSSR_BUFDATA_MODE1 (0x80uL << 16)
+/* Sets 0x40 for low delay mode.2 */
+#define BFSSR_BUFDATA_MODE2 (0x40uL << 16)
+#define BFSSR_BUFIN_LOW_DELAY_OFF	(0uL)
+#define BFSSR_BUFIN_LOW_DELAY_ON	(5uL)	/* Sets 0x5 for low delay mode*/
+
+/* SC2SR Register Value */
+/* ALL Bit is ReadOnly */
+#define BFSSR_SRCWSTS			(1<<31) /* 1:Reached to wait time */
+#define BFSSR_SC2MUTE			(1<<30) /* 1:Output data of sampling
+						   rate conversion is stable. */
+#define BFSSR_SRCWSTS_REST		(0<<28) /* 00:SRC is resetting */
+#define BFSSR_SRCWSTS_INIT		(1<<28) /* 01:SRC is initialized */
+#define BFSSR_SRCWSTS_OPER		(2<<28) /* 10:SRC is operating */
+
+/* WATSR Register Value */
+/*WATSRp_2SRC0_m - 2SRC0_m Wait Time Setting Register p(m=0,1 p=0,1)
+b23:b0 WTIME - wait time - Set parameter
+Other  Reserved - The write value should always be 0 */
+/* SCUX SRC wait time */
+#define SCUX_MIN_WAIT		(0x00000000L)
+#define SCUX_MAX_WAIT		(0x00FFFFFFL)
+#define SCUX_NO_WAIT		(-1L)
+
+/* SEVMR Register Value */
+/* SEVMRp_2SRC0_m - 2SRC0_m Event Mask Register p(m=0,1 p=0,1)
+b31 EVMUF - Sampling Rate Converter Underflow Mask - Interrupt enabled
+b30 EVMOF - Sampling Rate Converter Overflow Mask - Interrupt enabled
+b14 EVMWAIT - Sampling Rate Converter Wait Time Mask - Interrupt enabled
+Other  Reserved - The write value should always be 0 */
+/* Value of SEVMRp_2SRC0_m Register */
+#define SEVMR_VALUE           (0xc0004000uL)
+
+/* SEVCR Register Value */
+#define SEVCR_REG_MASK		(0xC0004000uL)
+#define SEVCR_EVCUF		(0x80000000uL)
+#define SEVCR_EVCOF		(0x40000000uL)
+#define SEVCR_EVCWAIT		(0x00004000uL)
+
+/* SRCIRR Register Value */
+#define SRCIRR_INIT_ON		(1uL)		/* Set INIT of SRC */
+
+/* DVUIR Register Value */
+#define DVUIR_INIT_ON		(1uL)		/* Set INIT of DVU */
+
+/* VADIR Register Value */
+/* VADIR_DVU0_n - DVU0_n Audio Information Register(n=0,1,2,3)
+b20:b16 OTBL - Bit Length of Output Audio Data - Set parameter
+b3:b0   CHNUM - Channel Number - Set parameter
+Other   Reserved - The write value should always be 0 */
+/*bit 20-16*/
+#define VADIR_OTBL_24BIT	(0<<16)
+#define VADIR_OTBL_16BIT	(8<<16)
+/* bit 3-0 */
+#define VADIR_CHNUM_CH_NONE	(0uL)
+#define VADIR_CHNUM_CH_1	(1uL)
+#define VADIR_CHNUM_CH_2	(2uL)
+#define VADIR_CHNUM_CH_4	(4uL)
+#define VADIR_CHNUM_CH_6	(6uL)
+#define VADIR_CHNUM_CH_8	(8uL)
+
+/* DVUBR Register Value */
+#define DVUBR_BYPASS_OFF	(0uL)
+#define DVUBR_BYPASS_ON		(1uL)
+
+/* DVUCR Register Value */
+#define	DVUCR_VVMD_SLEEP	(0<<8)
+#define	DVUCR_VVMD_USE		(1<<8)
+#define	DVUCR_VRMD_SLEEP	(0<<4)
+#define	DVUCR_VRMD_USE		(1<<4)
+#define	DVUCR_ZCMD_SLEEP	(0<<0)
+#define	DVUCR_ZCMD_USE		(1<<0)
+
+/* ZCMCR Register Value */
+#define ZCMCR_ZCEN0_EN		(1<<0)
+#define ZCMCR_ZCEN1_EN		(1<<1)
+#define ZCMCR_ZCEN2_EN		(1<<2)
+#define ZCMCR_ZCEN3_EN		(1<<3)
+#define ZCMCR_ZCEN4_EN		(1<<4)
+#define ZCMCR_ZCEN5_EN		(1<<5)
+#define ZCMCR_ZCEN6_EN		(1<<6)
+#define ZCMCR_ZCEN7_EN		(1<<7)
+
+/* VRCTR Register Value */
+/* VRCTR_DVU0_n - DVU0_n Volume Ramp Control Register(n=0,1,2,3)
+b7:b0 VREN7:VREN0 - Volume Ramp Enable for Channel 7 to 0 - Set parameter
+Other Reserved - The write value should always be 0 */
+#define VRCTR_VREN0_EN		(1<<0)
+#define VRCTR_VREN1_EN		(1<<1)
+#define VRCTR_VREN2_EN		(1<<2)
+#define VRCTR_VREN3_EN		(1<<3)
+#define VRCTR_VREN4_EN		(1<<4)
+#define VRCTR_VREN5_EN		(1<<5)
+#define VRCTR_VREN6_EN		(1<<6)
+#define VRCTR_VREN7_EN		(1<<7)
+
+/* VRPDR Register Value */
+enum scux_ramp_period {
+	/*                vol_up , vol_down             */
+	DVU_PERIOD_1,		/*       1sample (  128dB,   -128dB/1step)   */
+	DVU_PERIOD_2,		/*       2sample (   64dB,    -64dB/1step)   */
+	DVU_PERIOD_4,		/*       4sample (   32dB,    -32dB/1step)   */
+	DVU_PERIOD_8,		/*       8sample (   16dB,    -16dB/1step)   */
+	DVU_PERIOD_16,		/*      16sample (    8dB,     -8dB/1step)   */
+	DVU_PERIOD_32,		/*      32sample (    4dB,     -4dB/1step)   */
+	DVU_PERIOD_64,		/*      64sample (    2dB,     -2dB/1step)   */
+	DVU_PERIOD_128,		/*     128sample (    1dB,     -1dB/1step)   */
+	DVU_PERIOD_256,		/*     256sample (  0.5dB,   -0.5dB/1step)   */
+	DVU_PERIOD_512,		/*     512sample ( 0.25dB,  -0.25dB/1step)   */
+	DVU_PERIOD_1024,	/*    1024sample (0.125dB, -0.125dB/1step)   */
+	DVU_PERIOD_2048,	/*    2048sample (0.125dB, -0.125dB/2step)   */
+	DVU_PERIOD_4096,	/*    4096sample (0.125dB, -0.125dB/4step)   */
+	DVU_PERIOD_8192,	/*    8192sample (0.125dB, -0.125dB/8step)   */
+	DVU_PERIOD_16384,	/*   16384sample (0.125dB, -0.125dB/16step)  */
+	DVU_PERIOD_32768,	/*   32768sample (0.125dB, -0.125dB/32step)  */
+	DVU_PERIOD_65536,	/*   65536sample (0.125dB, -0.125dB/64step)  */
+	DVU_PERIOD_131072,	/*  131072sample (0.125dB, -0.125dB/128step) */
+	DVU_PERIOD_262144,	/*  262144sample (0.125dB, -0.125dB/256step) */
+	DVU_PERIOD_524288,	/*  524288sample (0.125dB, -0.125dB/512step) */
+	DVU_PERIOD_1048576,	/* 1048576sample (0.125dB, -0.125dB/1024step)*/
+	DVU_PERIOD_2097152,	/* 2097152sample (0.125dB, -0.125dB/2048step)*/
+	DVU_PERIOD_4194304,	/* 4194304sample (0.125dB, -0.125dB/4096step)*/
+	DVU_PERIOD_8388608,	/* 8388608sample (0.125dB, -0.125dB/8192step)*/
+};
+#define VRPDR_VRPDUP_PERIOD_1       (DVU_PERIOD_1       << 8)
+#define VRPDR_VRPDUP_PERIOD_2       (DVU_PERIOD_2       << 8)
+#define VRPDR_VRPDUP_PERIOD_4       (DVU_PERIOD_4       << 8)
+#define VRPDR_VRPDUP_PERIOD_8       (DVU_PERIOD_8       << 8)
+#define VRPDR_VRPDUP_PERIOD_16      (DVU_PERIOD_16      << 8)
+#define VRPDR_VRPDUP_PERIOD_32      (DVU_PERIOD_32      << 8)
+#define VRPDR_VRPDUP_PERIOD_64      (DVU_PERIOD_64      << 8)
+#define VRPDR_VRPDUP_PERIOD_128     (DVU_PERIOD_128     << 8)
+#define VRPDR_VRPDUP_PERIOD_256     (DVU_PERIOD_256     << 8)
+#define VRPDR_VRPDUP_PERIOD_512     (DVU_PERIOD_512     << 8)
+#define VRPDR_VRPDUP_PERIOD_1024    (DVU_PERIOD_1024    << 8)
+#define VRPDR_VRPDUP_PERIOD_2048    (DVU_PERIOD_2048    << 8)
+#define VRPDR_VRPDUP_PERIOD_4096    (DVU_PERIOD_4096    << 8)
+#define VRPDR_VRPDUP_PERIOD_8192    (DVU_PERIOD_8192    << 8)
+#define VRPDR_VRPDUP_PERIOD_16384   (DVU_PERIOD_16384   << 8)
+#define VRPDR_VRPDUP_PERIOD_32768   (DVU_PERIOD_32768   << 8)
+#define VRPDR_VRPDUP_PERIOD_65536   (DVU_PERIOD_65536   << 8)
+#define VRPDR_VRPDUP_PERIOD_131072  (DVU_PERIOD_131072  << 8)
+#define VRPDR_VRPDUP_PERIOD_262144  (DVU_PERIOD_262144  << 8)
+#define VRPDR_VRPDUP_PERIOD_524288  (DVU_PERIOD_524288  << 8)
+#define VRPDR_VRPDUP_PERIOD_1048576 (DVU_PERIOD_1048576 << 8)
+#define VRPDR_VRPDUP_PERIOD_2097152 (DVU_PERIOD_2097152 << 8)
+#define VRPDR_VRPDUP_PERIOD_4194304 (DVU_PERIOD_4194304 << 8)
+#define VRPDR_VRPDUP_PERIOD_8388608 (DVU_PERIOD_8388608 << 8)
+
+#define VRPDR_VRPDDW_PERIOD_1       (DVU_PERIOD_1)
+#define VRPDR_VRPDDW_PERIOD_2       (DVU_PERIOD_2)
+#define VRPDR_VRPDDW_PERIOD_4       (DVU_PERIOD_4)
+#define VRPDR_VRPDDW_PERIOD_8       (DVU_PERIOD_8)
+#define VRPDR_VRPDDW_PERIOD_16      (DVU_PERIOD_16)
+#define VRPDR_VRPDDW_PERIOD_32      (DVU_PERIOD_32)
+#define VRPDR_VRPDDW_PERIOD_64      (DVU_PERIOD_64)
+#define VRPDR_VRPDDW_PERIOD_128     (DVU_PERIOD_128)
+#define VRPDR_VRPDDW_PERIOD_256     (DVU_PERIOD_256)
+#define VRPDR_VRPDDW_PERIOD_512     (DVU_PERIOD_512)
+#define VRPDR_VRPDDW_PERIOD_1024    (DVU_PERIOD_1024)
+#define VRPDR_VRPDDW_PERIOD_2048    (DVU_PERIOD_2048)
+#define VRPDR_VRPDDW_PERIOD_4096    (DVU_PERIOD_4096)
+#define VRPDR_VRPDDW_PERIOD_8192    (DVU_PERIOD_8192)
+#define VRPDR_VRPDDW_PERIOD_16384   (DVU_PERIOD_16384)
+#define VRPDR_VRPDDW_PERIOD_32768   (DVU_PERIOD_32768)
+#define VRPDR_VRPDDW_PERIOD_65536   (DVU_PERIOD_65536)
+#define VRPDR_VRPDDW_PERIOD_131072  (DVU_PERIOD_131072)
+#define VRPDR_VRPDDW_PERIOD_262144  (DVU_PERIOD_262144)
+#define VRPDR_VRPDDW_PERIOD_524288  (DVU_PERIOD_524288)
+#define VRPDR_VRPDDW_PERIOD_1048576 (DVU_PERIOD_1048576)
+#define VRPDR_VRPDDW_PERIOD_2097152 (DVU_PERIOD_2097152)
+#define VRPDR_VRPDDW_PERIOD_4194304 (DVU_PERIOD_4194304)
+#define VRPDR_VRPDDW_PERIOD_8388608 (DVU_PERIOD_8388608)
+
+/* VRDBR Register Value */
+#define VRDBR_VRDB_MUTE		(0x000003FFuL)
+#define VRDBR_VRDB_0DB		(0x00000000uL)
+
+/* VRWTR Register Value */
+#define VRWTR_VRWT		(0x00FFFFFFuL)
+
+/* VOL0R~VOL7R Register Value */
+#define SCUX_MAX_VOL_VALUE  (0x007FFFFFuL) /* SCUX DVU digital volume level */
+
+/* DVUER Register Value */
+#define DVUER_DVUEN_DI		(0uL)
+#define DVUER_DVUEN_EN (1uL) /* Set DVUER_DVU0_n register - DVUEN bit */
+
+/* DVUSR Register Value */
+#define DVUSR_VRSTS_MUTE (0uL)
+#define DVUSR_VRSTS_VOLRAMPDOWN	(1uL)
+#define DVUSR_VRSTS_VOLRAMPUP	(2uL)
+#define DVUSR_VRSTS_VRDBRREG	(3uL)
+#define DVUSR_VRSTS_VOLINDATA	(4uL)
+
+#define DVUSR_ZSTS0_MUTE	(1<<16)
+#define DVUSR_ZSTS1_MUTE	(1<<17)
+#define DVUSR_ZSTS2_MUTE	(1<<18)
+#define DVUSR_ZSTS3_MUTE	(1<<19)
+#define DVUSR_ZSTS4_MUTE	(1<<20)
+#define DVUSR_ZSTS5_MUTE	(1<<21)
+#define DVUSR_ZSTS6_MUTE	(1<<22)
+#define DVUSR_ZSTS7_MUTE	(1<<23)
+
+/* VEVMR Register Value */
+#define VEVMR_VEVMZCM7_EN	(1<<31)
+#define VEVMR_VEVMZCM6_EN	(1<<30)
+#define VEVMR_VEVMZCM5_EN	(1<<29)
+#define VEVMR_VEVMZCM4_EN	(1<<28)
+#define VEVMR_VEVMZCM3_EN	(1<<27)
+#define VEVMR_VEVMZCM2_EN	(1<<26)
+#define VEVMR_VEVMZCM1_EN	(1<<25)
+#define VEVMR_VEVMZCM0_EN	(1<<24)
+#define VEVMR_VEVMVR_EN		(1<<15)
+
+/* VEVCR Register Value */
+#define VEVCR_VEVCZCM7_EN	(1<<31)
+#define VEVCR_VEVCZCM6_EN	(1<<30)
+#define VEVCR_VEVCZCM5_EN	(1<<29)
+#define VEVCR_VEVCZCM4_EN	(1<<28)
+#define VEVCR_VEVCZCM3_EN	(1<<27)
+#define VEVCR_VEVCZCM2_EN	(1<<26)
+#define VEVCR_VEVCZCM1_EN	(1<<25)
+#define VEVCR_VEVCZCM0_EN	(1<<24)
+#define VEVCR_VEVCVR_EN		(1<<15)
+
+/* SWRSR Register Value */
+#define SWRSR_SWRST_RST		(0uL)
+#define SWRSR_SWRST_OPE		(1uL)
+
+/* DMACR Register Value */
+#define DMACR_DMAMDFFD0_EN	(1<<0)
+#define DMACR_DMAMDFFD1_EN	(1<<1)
+#define DMACR_DMAMDFFD2_EN	(1<<2)
+#define DMACR_DMAMDFFD3_EN	(1<<3)
+#define DMACR_DMAMDFFU0_EN	(1<<4)
+#define DMACR_DMAMDFFU1_EN	(1<<5)
+#define DMACR_DMAMDFFU2_EN	(1<<6)
+#define DMACR_DMAMDFFU3_EN	(1<<7)
+
+/* SSIRSEL Register Value */
+/* SSIRSEL_CIM - SSI Route Select Register
+b31:b30 SISEL3 - SRC3 SSIF Input Select - Set parameter
+b29:b28 SISEL2 - SRC2 SSIF Input Select - Set parameter
+b27:b26 SISEL1 - SRC1 SSIF Input Select - Input from SSIF3
+b25:b24 SISEL0 - SRC0 SSIF Input Select - input from SSIF0
+b21:b20 SOSEL5 - SSIF5 Output Select - Output from SRC3 (DVU0_3)
+b17:b16 SOSEL4 - SSIF4 Output Select - Output from SRC2 (DVU0_2)
+b13:b12 SOSEL3 - SSIF3 Output Select - Set parameter
+b9:b8   SOSEL2 - SSIF2 Output Select - Output from SRC3 (DVU0_3)
+b5:b4   SOSEL1 - SSIF1 Output Select - Output from SRC2 (DVU0_2)
+b1:b0   SOSEL0 - SSIF0 Output Select - Set parameter
+Other Reserved - The write value should always be 0 */
+#define SSIRSEL_SISEL3_USE_SSIF2	(0<<30)
+#define SSIRSEL_SISEL3_USE_SSIF5	(1<<30)
+#define SSIRSEL_SISEL2_USE_SSIF1	(0<<28)
+#define SSIRSEL_SISEL2_USE_SSIF4	(1<<28)
+#define SSIRSEL_SISEL1_USE_SSIF3	(0<<26)
+#define SSIRSEL_SISEL1_USE_SSIF345	(1<<26)
+#define SSIRSEL_SISEL0_USE_SSIF0	(0<<24)
+#define SSIRSEL_SISEL0_USE_SSIF012	(1<<24)
+#define SSIRSEL_SOSEL5_USE_SRC3		(0<<20)
+#define SSIRSEL_SOSEL5_USE_SRC1		(1<<20)
+#define SSIRSEL_SOSEL5_USE_SRC0		(2<<20)
+#define SSIRSEL_SOSEL4_USE_SRC2		(0<<16)
+#define SSIRSEL_SOSEL4_USE_SRC1		(1<<16)
+#define SSIRSEL_SOSEL4_USE_SRC0		(2<<16)
+#define SSIRSEL_SOSEL3_USE_SRC1		(0<<12)
+#define SSIRSEL_SOSEL3_USE_SRC0		(1<<12)
+#define SSIRSEL_SOSEL2_USE_SRC3		(0<<8)
+#define SSIRSEL_SOSEL2_USE_SRC0		(1<<8)
+#define SSIRSEL_SOSEL2_USE_SRC1		(2<<8)
+#define SSIRSEL_SOSEL1_USE_SRC2		(0<<4)
+#define SSIRSEL_SOSEL1_USE_SRC0		(1<<4)
+#define SSIRSEL_SOSEL1_USE_SRC1		(2<<4)
+#define SSIRSEL_SOSEL0_USE_SRC0		(0)
+#define SSIRSEL_SOSEL0_USE_SRC1		(1)
+
+/* FDTSEL Register Value */
+/* Configure SCUX
+FDTSELn_CIM - FFD0_n Timing Select Register(n=0,1,2,3)
+b26:16 SCKDIV - Division Ratio
+b8     DIVEN - Division Enable - Division disabled
+b3:0   SCKSEL - Clock Select
+Other Reserved - The write value should always be 0 */
+
+#define FDTSEL_SCKSEL_AUDIO_CLK		(0x0uL)
+#define FDTSEL_SCKSEL_AUIDIO_X1		(0x1uL)
+#define FDTSEL_SCKSEL_MLB_CLK		(0x2uL)
+#define FDTSEL_SCKSEL_USB_X1		(0x3uL)
+#define FDTSEL_SCKSEL_CLKP1_PHY_DIV2	(0x4uL)
+#define FDTSEL_SCKSEL_SSIF0_WS		(0x8uL)
+#define FDTSEL_SCKSEL_SSIF1_WS		(0x9uL)
+#define FDTSEL_SCKSEL_SSIF2_WS		(0xAuL)
+#define FDTSEL_SCKSEL_SSIF3_WS		(0xBuL)
+#define FDTSEL_SCKSEL_SSIF4_WS		(0xCuL)
+#define FDTSEL_SCKSEL_SSIF5_WS		(0xDuL)
+
+#define SCUX_FDTSEL_BIT_DIVEN		(0x00000100uL)
+
+#define FDTSEL_CH_0_SCKDIV		(0<<16)
+#define FDTSEL_CH_1_SCKDIV		(694uL)	/* P1PHY(66.67MHz)/2/48KHz */
+#define FDTSEL_CH_2_SCKDIV		(694uL)	/* P1PHY(66.67MHz)/2/48KHz */
+#define FDTSEL_CH_3_SCKDIV		(694uL)	/* P1PHY(66.67MHz)/2/48KHz */
+
+/* FUTSEL Register Value */
+#define FUTSEL_SCKSEL_AUDIO_CLK		(0x0uL)
+#define FUTSEL_SCKSEL_AUIDIO_X1		(0x1uL)
+#define FUTSEL_SCKSEL_MLB_CLK		(0x2uL)
+#define FUTSEL_SCKSEL_USB_X1		(0x3uL)
+#define FUTSEL_SCKSEL_CLKP1_PHY_DIV2	(0x4uL)
+#define FUTSEL_SCKSEL_SSIF0_WS		(0x8uL)
+#define FUTSEL_SCKSEL_SSIF1_WS		(0x9uL)
+#define FUTSEL_SCKSEL_SSIF2_WS		(0xAuL)
+#define FUTSEL_SCKSEL_SSIF3_WS		(0xBuL)
+#define FUTSEL_SCKSEL_SSIF4_WS		(0xCuL)
+#define FUTSEL_SCKSEL_SSIF5_WS		(0xDuL)
+
+#define FUTSEL_DIVEN_START		(0x00000100uL)
+
+#define FUTSEL_CH_0_SCKDIV		(0<<16)
+#define FUTSEL_CH_1_SCKDIV		(0<<16)
+#define FUTSEL_CH_2_SCKDIV		(0<<16)
+#define FUTSEL_CH_3_SCKDIV		(0<<16)
+
+#define SCKDIV_MAX			(2047)
+
+/* ==== SCUX SSIPMD_CIM register setting ==== */
+#define THIS_CH_NOT_USED		(0uL)
+
+/* SSIPMD Register Value */
+#define SSIPMD_SSI5CKS			(0<<21)
+#define SSIPMD_SSI4CKS			(0<<20)
+#define SSIPMD_SSI3CKS			(0<<19)
+#define SSIPMD_SSI2CKS			(0<<18)
+#define SSIPMD_SSI1CKS			(0<<17)
+#define SSIPMD_SSI0CKS			(0<<16)
+#define SSIPMD_SSI5PMD			(0<<8)
+#define SSIPMD_SSI4PMD			(0<<10)
+#define SSIPMD_SSI3PMD			(0<<14)
+#define SSIPMD_SSI2PMD			(0<<2)
+#define SSIPMD_SSI1PMD			(0)
+#define SSIPMD_INDEPENDENCE		(0x0uL)
+#define SSIPMD_COMMON_SLAVE		(0x1uL)
+#define SSIPMD_COMMON_MASTER_SLAVE	(0x2uL)
+
+/* SSICTRL Register Value */
+/* SSICTRL_CIM - SSI Control Register
+b30:28 SSI3TX,SSI4TX,SSI5TX - SSIF3,4,5 Direct Transmission - Set parameter
+b26:24 SSI3RX,SSI4RX,SSI5RX - SSIF3,4,5 Direct Reception - Set parameter
+b17    SSI345TEN - SSIF345 Transmission Enable - Transmission disabled
+b16    SSI345REN - SSIF345 Reception Enable - Reception disabled
+b14:12 SSI0TX,SSI1TX,SSI2TX - SSIF0,1,2 Direct Transmission - Set parameter
+b11:9  SSI0RX,SSI1RX,SSI2RX - SSIF0,1,2 Direct Reception - Set parameter
+b1     SSI012TEN - SSIF012 Transmission Enable - Transmission disabled
+b0     SSI012REN - SSIF012 Reception Enable - Reception disabled
+Other Reserved - The write value should always be 0 */
+#define SSICTRL_SSI3TX_EN	(1<<30)
+#define SSICTRL_SSI4TX_EN	(1<<29)
+#define SSICTRL_SSI5TX_EN	(1<<28)
+#define SSICTRL_SSI3RX_EN	(1<<26)
+#define SSICTRL_SSI4RX_EN	(1<<25)
+#define SSICTRL_SSI5RX_EN	(1<<24)
+#define SSICTRL_SSI345TEN	(1<<17)
+#define SSICTRL_SSI345REN	(1<<16)
+#define SSICTRL_SSI0TX_EN	(1<<14)
+#define SSICTRL_SSI1TX_EN	(1<<13)
+#define SSICTRL_SSI2TX_EN	(1<<12)
+#define SSICTRL_SSI0RX_EN	(1<<10)
+#define SSICTRL_SSI1RX_EN	(1<<9)
+#define SSICTRL_SSI2RX_EN	(1<<8)
+#define SSICTRL_SSI012TEN	(1<<1)
+#define SSICTRL_SSI012REN	(1)
+
+/* SRCRSEL Register Value */
+/* RSEL_INIT_VALUE:Initial value of SRCRSELn_CIM and MIXRSEL_CIM Register */
+#define RSEL_INIT_VALUE		(0x76543210uL)
+#define SRCRSEL_PLACE0		(7)
+#define SRCRSEL_PLACE1		(7<<4)
+#define SRCRSEL_PLACE2		(7<<8)
+#define SRCRSEL_PLACE3		(7<<12)
+#define SRCRSEL_PLACE4		(7<<16)
+#define SRCRSEL_PLACE5		(7<<20)
+#define SRCRSEL_PLACE6		(7<<24)
+#define SRCRSEL_PLACE7		(7<<28)
+
+/* MIXRSEL Register Value */
+#define MIXRSEL_INIT_VALUE	(0x76543210uL)
+#define MIXRSEL_PLACE0		(7)
+#define MIXRSEL_PLACE1		(7<<4)
+#define MIXRSEL_PLACE2		(7<<8)
+#define MIXRSEL_PLACE3		(7<<12)
+#define MIXRSEL_PLACE4		(7<<16)
+#define MIXRSEL_PLACE5		(7<<20)
+#define MIXRSEL_PLACE6		(7<<24)
+#define MIXRSEL_PLACE7		(7<<28)
+
+/* MIXBR Register Value */
+#define MIXBR_BYPASS_OFF	(0uL)
+#define MIXBR_BYPASS_ON		(1uL)
+#define MIXBR_BPSYS_B		(1<<16)
+
+/* CHCTRL Register */
+#define DMA_CHCTRL_SWRST_BIT	(0x00000008uL)
+#define DMA_CHCTRL_SETEN_BIT	(0x00000001uL)
+
+/************************************************************************
+	SCUX Register Structure
+************************************************************************/
+struct scux_ipc_regs {
+	u32	ipcir;
+	u32	ipslr;
+	unsigned char  dummy_ipc[248];
+};
+
+struct scux_opc_regs {
+	u32	opcir;
+	u32	opslr;
+	unsigned char  dummy_opc[248];
+};
+
+struct scux_ffd_regs {
+	u32	ffdir;
+	u32	fdair;
+	u32	drqsr;
+	u32	ffdpr;
+	u32	ffdbr;
+	u32	devmr;
+	unsigned char  dummy_ffd[4];
+	u32	devcr;
+	unsigned char  dummy2_ffd[224];
+};
+
+struct scux_ffu_regs {
+	u32	ffuir;
+	u32	fuair;
+	u32	urqsr;
+	u32	ffupr;
+	u32	uevmr;
+	unsigned char  dummy_ffu[4];
+	u32	uevcr;
+	unsigned char  dummy2_ffu[228];
+};
+
+struct scux_src_regs {
+	u32	srcir0;
+	u32	sadir0;
+	u32	srcbr0;
+	u32	ifscr0;
+	u32	ifsvr0;
+	u32	srccr0;
+	u32	mnfsr0;
+	u32	bfssr0;
+	u32	sc2sr0;
+	u32	watsr0;
+	u32	sevmr0;
+	unsigned char  dummy_src0[4];
+	u32	sevcr0;
+	u32	srcir1;
+	u32	sadir1;
+	u32	srcbr1;
+	u32	ifscr1;
+	u32	ifsvr1;
+	u32	srccr1;
+	u32	mnfsr1;
+	u32	bfssr1;
+	u32	sc2sr1;
+	u32	watsr1;
+	u32	sevmr1;
+	unsigned char  dummy_src1[4];
+	u32	sevcr1;
+	u32	srcirr1;
+	unsigned char  dummy_src[148];
+};
+
+struct scux_dvu_regs {
+	u32	dvuir;
+	u32	vadir;
+	u32	dvubr;
+	u32	dvucr;
+	u32	zcmcr;
+	u32	vrctr;
+	u32	vrpdr;
+	u32	vrdbr;
+	u32	vrwtr;
+	u32	vol0r;
+	u32	vol1r;
+	u32	vol2r;
+	u32	vol3r;
+	u32	vol4r;
+	u32	vol5r;
+	u32	vol6r;
+	u32	vol7r;
+	u32	dvuer;
+	u32	dvusr;
+	u32	vevmr;
+	unsigned char  dummy_dvu[4];
+	u32	vevcr;
+	unsigned char  dummy2_dvu[168];
+};
+
+struct scux_mix_regs {
+	u32	mixir;
+	u32	madir;
+	u32	mixbr;
+	u32	mixmr;
+	u32	mvpdr;
+	u32	mdbar;
+	u32	mdbbr;
+	u32	mdbcr;
+	u32	mdbdr;
+	u32	mdber;
+	u32	mixsr;
+	unsigned char  dummy_mix[212];
+};
+struct scux_cim_regs {
+	u32 swrsr;		/*  SWRSR_CIM       */
+	u32 dmacr_cim;		/*  DMACR_CIM       */
+	union {			/*                  */
+		/* DMATD0_CIM       */
+		u32 UINT32;	/*  32-bit Access   */
+		u16 UINT16[2];	/*  16-bit Access   */
+	} dmatd0_cim;		/*                  */
+
+	union {			/*                  */
+		/* DMATD1_CIM       */
+		u32 UINT32;	/*  32-bit Access   */
+		u16 UINT16[2];	/*  16-bit Access   */
+	} dmatd1_cim;		/*                  */
+
+	union {			/*                  */
+		/* DMATD2_CIM       */
+		u32 UINT32;	/*  32-bit Access   */
+		u16 UINT16[2];	/*  16-bit Access   */
+	} dmatd2_cim;		/*                  */
+
+	union {			/*                  */
+		/* DMATD3_CIM       */
+		u32 UINT32;	/*  32-bit Access   */
+		u16 UINT16[2];	/*  16-bit Access   */
+	} dmatd3_cim;		/*                  */
+
+	union {			/*                  */
+		/* DMATU0_CIM       */
+		u32 UINT32;	/*  32-bit Access   */
+		u16 UINT16[2];	/*  16-bit Access   */
+	} dmatu0_cim;		/*                  */
+
+	union {			/*                  */
+		/* DMATU1_CIM       */
+		u32 UINT32;	/*  32-bit Access   */
+		u16 UINT16[2];	/*  16-bit Access   */
+	} dmatu1_cim;		/*                  */
+
+	union {			/*                  */
+		/* DMATU2_CIM       */
+		u32 UINT32;	/*  32-bit Access   */
+		u16 UINT16[2];	/*  16-bit Access   */
+	} dmatu2_cim;		/*                  */
+
+	union {			/*                  */
+		/* DMATU3_CIM       */
+		u32 UINT32;	/*  32-bit Access   */
+		u16 UINT16[2];	/*  16-bit Access   */
+	} dmatu3_cim;		/*                  */
+	unsigned char  dummy_cim[16];	/*                  */
+	u32 ssirsel_cim;	/*  SSIRSEL_CIM     */
+	u32 fdtsel0_cim;	/*  FDTSEL0_CIM     */
+	u32 fdtsel1_cim;	/*  FDTSEL1_CIM     */
+	u32 fdtsel2_cim;	/*  FDTSEL2_CIM     */
+	u32 fdtsel3_cim;	/*  FDTSEL3_CIM     */
+	u32 futsel0_cim;	/*  FUTSEL0_CIM     */
+	u32 futsel1_cim;	/*  FUTSEL1_CIM     */
+	u32 futsel2_cim;	/*  FUTSEL2_CIM     */
+	u32 futsel3_cim;	/*  FUTSEL3_CIM     */
+	u32 ssipmd_cim;		/*  SSIPMD_CIM      */
+	u32 ssictrl_cim;	/*  SSICTRL_CIM     */
+	u32 srcrsel0_cim;	/*  SRCRSEL0_CIM    */
+	u32 srcrsel1_cim;	/*  SRCRSEL1_CIM    */
+	u32 srcrsel2_cim;	/*  SRCRSEL2_CIM    */
+	u32 srcrsel3_cim;	/*  SRCRSEL3_CIM    */
+	u32 mixrsel_cim;	/*  MIXRSEL_CIM     */
+};
+
+struct ssif_regs {
+	u32	ssicr;
+	u32	ssisr;
+	unsigned char dummy_ssifreg1[8];
+	u32	ssifcr;
+	u32	ssifsr;
+	u32	ssiftdr;
+	u32	ssifrdr;
+	u32	ssitdmr;
+	u32	ssifccr;
+	u32	ssifcmr;
+	u32	ssifcsr;
+	unsigned char dummy_ssifreg2[2000];
+};
+
+struct dmac_regs {
+	u32	chctrl;
+};
+
+struct scux_reg_info {
+#if 1
+	void __iomem				*scuxreg;
+	struct scux_ipc_regs		*ipcreg[NUM_SCUX_CH];
+	struct scux_opc_regs		*opcreg[NUM_SCUX_CH];
+	struct scux_ffd_regs		*ffdreg[NUM_SCUX_CH];
+	struct scux_ffu_regs		*ffureg[NUM_SCUX_CH];
+	struct scux_src_regs		*srcreg[MAXCH_SRC];
+	struct scux_dvu_regs		*dvureg[MAXCH_DVU];
+	struct scux_mix_regs		*mixreg;
+	struct scux_cim_regs		*cimreg;
+#endif // 0
+	void __iomem				*ssireg;
+	struct ssif_regs			*ssifreg[MAXCH_SSIF];
+};
+
+struct scu_audio_info {
+	struct scux_reg_info reginfo;
+	struct scu_route_info routeinfo;
+	struct scu_clock_info clockinfo;
+	spinlock_t scu_lock;		/* for common register */
+	unsigned int rate[2];
+	unsigned int volume[2][2];
+	unsigned int mute[2];
+};
+
+/******************************************************************************
+ ==== SSIF ====
+******************************************************************************/
+/* SSICRn bit */
+#define	SSICR_REN_DIS	(0<<0)
+#define	SSICR_REN_EN	(1<<0)
+#define	SSICR_TEN_DIS	(0<<1)
+#define	SSICR_TEN_EN	(1<<1)
+#define	SSICR_MUEN	(1<<3)
+#define	SSICR_CKDV_1	(0<<4)
+#define	SSICR_CKDV_2	(1<<4)
+#define	SSICR_CKDV_4	(2<<4)
+#define	SSICR_CKDV_8	(3<<4)
+#define	SSICR_CKDV_16	(4<<4)
+#define	SSICR_CKDV_32	(5<<4)
+#define	SSICR_CKDV_64	(6<<4)
+#define	SSICR_CKDV_128	(7<<4)
+#define	SSICR_CKDV_6	(8<<4)
+#define	SSICR_CKDV_12	(9<<4)
+#define	SSICR_CKDV_24	(10<<4)
+#define	SSICR_CKDV_48	(11<<4)
+#define	SSICR_CKDV_96	(12<<4)
+#define	SSICR_DEL_1CLKDEL (0<<8)
+#define	SSICR_DEL_NODEL (1<<8)
+#define	SSICR_PDTA	(1<<9)
+#define	SSICR_SDTA	(1<<10)
+#define	SSICR_SPDP	(1<<11)
+#define	SSICR_SWSP	(1<<12)
+#define	SSICR_SCKP	(1<<13)
+#define	SSICR_SWSD_SLAVE (0<<14)
+#define	SSICR_SWSD_MASTER (1<<14)
+#define	SSICR_M_MASTER	(3<<14)
+#define	SSICR_SCKD_SLAVE (0<<15)
+#define	SSICR_SCKD_MASTER (1<<15)
+#define	SSICR_SWL_ST8	(0<<16)
+#define	SSICR_SWL_ST16	(1<<16)
+#define	SSICR_SWL_ST24	(2<<16)
+#define	SSICR_SWL_ST32	(3<<16)
+#define	SSICR_SWL_ST48	(4<<16)
+#define	SSICR_SWL_ST64	(5<<16)
+#define	SSICR_SWL_ST128	(6<<16)
+#define	SSICR_SWL_ST256	(7<<16)
+#define	SSICR_DWL_ST8	(0<<19)
+#define	SSICR_DWL_ST16	(1<<19)
+#define	SSICR_DWL_ST18	(2<<19)
+#define	SSICR_DWL_ST20	(3<<19)
+#define	SSICR_DWL_ST22	(4<<19)
+#define	SSICR_DWL_ST24	(5<<19)
+#define	SSICR_DWL_ST32	(6<<19)
+#define	SSICR_CHNL_ST1	(0<<22)
+#define	SSICR_CHNL_ST2	(1<<22)
+#define	SSICR_CHNL_ST3	(2<<22)
+#define	SSICR_CHNL_ST4	(3<<22)
+#define	SSICR_IIEN	(1<<25)
+#define	SSICR_ROIEN	(1<<26)
+#define	SSICR_RUIEN	(1<<27)
+#define	SSICR_TOIEN	(1<<28)
+#define	SSICR_TUIEN	(1<<29)
+#define	SSICR_CKS	(1<<30)
+
+
+/* for SSI start */
+#define	SSICR_ENABLE	(SSICR_REN_EN	| \
+			 SSICR_ROIEN	| \
+			 SSICR_RUIEN	| \
+			 SSICR_TOIEN)
+
+/* SSISRn bit */
+#define	SSISR_IDST	(1<<0)
+#define	SSISR_SWNO	(1<<1)
+#define	SSISR_CHNO0	(1<<2)
+#define	SSISR_CHNO1	(1<<3)
+#define	SSISR_DIRQ	(1<<24)
+#define	SSISR_IIRQ	(1<<25)
+#define	SSISR_OIRQ	(1<<26)
+#define	SSISR_UIRQ	(1<<27)
+#define	SSISR_DMRQ	(1<<28)
+#define	SSISR_ROIRQ	(0<<26)
+#define	SSISR_RUIRQ	(0<<27)
+#define	SSISR_TOIRQ	(0<<28)
+#define	SSISR_TUIRQ	(0<<29)
+
+/* SSIFCRn bit */
+#define SSIFCR_RFRST	(1<<0)
+#define SSIFCR_TFRST	(1<<1)
+#define SSIFCR_RIE	(1<<2)
+#define SSIFCR_TIE	(1<<3)
+#define SSIFCR_SSIRST	(1<<16)
+#define SSIFCR_AUCKE	(1<<31)
+
+/* SSI TDM Mode Register Setting */
+/*  [17] RXDMUTE  : B'0 : Rx Direct Data MUTE : Rx Direct Data  */
+/*  [8] CONT  : B'1 : WS Continue Mode:Enables WS continue mode */
+/*  [0] TDM      : B'0 : TDM Mode : Disables TDM mode           */
+#define	SSITDMR_TDM_DIS			(0<<0)
+#define	SSITDMR_TDM_EN			(1<<0)
+#define	SSITDMR_CONT_DIS		(0<<8)
+#define	SSITDMR_CONT_EN			(1<<8)
+#define	SSITDMR_RXDMUTE_RCVDATA		(0<<17)
+#define	SSITDMR_RXDMUTE_0DATA		(1<<17)
+#define SSI_SSITDMR_BASE_INIT_VALUE	(SSITDMR_RXDMUTE_RCVDATA | \
+						SSITDMR_CONT_EN | \
+						SSITDMR_TDM_DIS)
+
+/* ==== SSI Channel0 ==== */
+/* SSI0 Control Register Setting */
+#define SSI_SSICR0_CKS_VALUE		(0x00000000uL)
+#define SSI_SSICR0_CHNL_VALUE		(0x00000000uL)
+#define SSI_SSICR0_DWL_VALUE		(0x00080000uL)
+#define SSI_SSICR0_SWL_VALUE		(0x00030000uL)
+#define SSI_SSICR0_SCKD_VALUE		(0x00000000uL)
+#define SSI_SSICR0_SWSD_VALUE		(0x00004000uL)
+#define SSI_SSICR0_SCKP_VALUE		(0x00000000uL)
+#define SSI_SSICR0_SWSP_VALUE		(0x00000000uL)
+#define SSI_SSICR0_SPDP_VALUE		(0x00000000uL)
+#define SSI_SSICR0_SDTA_VALUE		(0x00000000uL)
+#define SSI_SSICR0_PDTA_VALUE		(0x00000000uL)
+#define SSI_SSICR0_DEL_VALUE		(0x00000000uL)
+#define SSI_SSICR0_CKDV_VALUE		(0x00000020uL)
+
+/*  [30]    CKS : B'0  : AUDIO_X1 input                                      */
+/*  [23:22] CHNL: B'00 : 1 channel / system word                             */
+/*  [21:19] DWL : B'001: 16 bit / data word                                  */
+/*  [18:16] SWL : B'011: 32 bit / system word                                */
+/*  [15]    SCKD: B'0  : Serial Bit Clock Direction:master mode              */
+/*  [14]    SWSD: B'1  : Serial WS Direction:master mode                     */
+/*  [13]    SCKP: B'0  : SSIWS and SSIDATA change at the SSISCK falling edge */
+/*  [12]    SWSP: B'0  : SSIWS is low for 1st channel, high for 2nd channel  */
+/*  [11]    SPDP: B'0  : Padding bits are low                                */
+/*  [10]    SDTA: B'0  : Tx and Rx in the order of serial data and padding bit*/
+/*  [9]     PDTA: B'0  : The lower bits of parallel data(SSITDR, SSIRDR)
+				     are transferred prior to the upper bits */
+/*  [8]     DEL : B'0  : 1 clock cycle delay between SSIWS and SSIDATA       */
+/*  [7:4]   CKDV: B'0010: AUDIO dia / 4
+			(64FS,AUDIO_X1@11.2896MHz/32bit system word) */
+#define SSI_SSICR0_USER_INIT_VALUE  (SSI_SSICR0_CKS_VALUE  | \
+					SSI_SSICR0_CHNL_VALUE | \
+					SSI_SSICR0_DWL_VALUE  | \
+					SSI_SSICR0_SWL_VALUE  | \
+					SSI_SSICR0_SCKD_VALUE | \
+					SSI_SSICR0_SWSD_VALUE | \
+					SSI_SSICR0_SCKP_VALUE | \
+					SSI_SSICR0_SWSP_VALUE | \
+					SSI_SSICR0_SPDP_VALUE | \
+					SSI_SSICR0_SDTA_VALUE | \
+					SSI_SSICR0_PDTA_VALUE | \
+					SSI_SSICR0_DEL_VALUE  | \
+					SSI_SSICR0_CKDV_VALUE)
+
+/* SSI SSICR0 Register INIT Setting */
+/*  [29]    TUIEN   : B'0    : Disables an underflow interrupt              */
+/*  [28]    TOIEN   : B'0    : Disables an overflow interrupt               */
+/*  [27]    RUIEN   : B'0    : Disables an underflow interrupt              */
+/*  [26]    ROIEN   : B'0    : Receive Overflow Interrupt Enable            */
+/*  [25]    IIEN    : B'0    : Disables an idle mode interrupt              */
+/*  [3]     MUEN    : B'0    : This module is not muted                     */
+/*  [1]     TEN     : B'0    : Disables the transmit operation              */
+/*  [0]     REN     : B'0    : Disables the receive operation               */
+/*  [30:4] SSI_SSICR0_USER_INIT_VALUE SSICR0 INIT                          */
+#define SSI_SSICR_TUIEN_INIT_VALUE          (0x00000000uL)
+#define SSI_SSICR_TOIEN_INIT_VALUE          (0x00000000uL)
+#define SSI_SSICR_RUIEN_INIT_VALUE          (0x00000000uL)
+#define SSI_SSICR_ROIEN_INIT_VALUE          (0x00000000uL)
+#define SSI_SSICR_IIEN_INIT_VALUE           (0x00000000uL)
+#define SSI_SSICR_MUEN_INIT_VALUE           (0x00000000uL)
+#define SSI_SSICR_TEN_INIT_VALUE            (0x00000000uL)
+#define SSI_SSICR_REN_INIT_VALUE            (0x00000000uL)
+#define SSI_SSICR_BASE_INIT_VALUE           (SSI_SSICR_TUIEN_INIT_VALUE | \
+						SSI_SSICR_TOIEN_INIT_VALUE | \
+						SSI_SSICR_RUIEN_INIT_VALUE | \
+						SSI_SSICR_ROIEN_INIT_VALUE | \
+						SSI_SSICR_IIEN_INIT_VALUE  | \
+						SSI_SSICR_MUEN_INIT_VALUE  | \
+						SSI_SSICR_TEN_INIT_VALUE   | \
+						SSI_SSICR_REN_INIT_VALUE   | \
+						SSI_SSICR0_USER_INIT_VALUE)
+/*
+ * SSICR setting for WM8978
+ *   playback, master, 16bit, stereo
+ *   SCLK=256fs(MCLK)/4=32fs
+ */
+#define	SSICR_PLAY_WM8978_ST	(SSICR_CHNL_ST1    | \
+			 SSICR_DWL_ST16 | \
+			 SSICR_SWL_ST32 | \
+			 SSICR_SWSD_MASTER | \
+			 SSICR_CKDV_4)
+/*
+ * SSICR setting for WWM8978
+ *   capture, slave, 16bit, stereo
+ *   SCLK=256fs(MCLK)/4=32fs
+ */
+#define	SSICR_CAP_WM8978_ST	(SSICR_CHNL_ST1    | \
+			 SSICR_DWL_ST16 | \
+			 SSICR_SWL_ST32 | \
+			 SSICR_SWSD_MASTER | \
+			 SSICR_CKDV_4)
+/* SSI0 FIFO Control Register Setting */
+/*  [7:6] TTRG  : B'00 : Transmit Data Trigger Number:7                       */
+/*  [5:4] RTRG  : B'00 : Receive Data Trigger Number:1                        */
+/*  [3]   TIE   : B'0  : Transmit data empty interrupt (TXI)
+			 request is disabled */
+/*  [2]   RIE   : B'0  : Receive data full interrupt (RXI)
+			 request is disabled   */
+/*  [1]   TFRST : B'1  : Reset is enabled                                     */
+/*  [0]   RFRST : B'1  : Reset is enabled                                     */
+#define SSI_SSIFCR0_AUCKE_VALUE			(0x80000000uL)
+#define SSI_SSIFCR0_TTRG_VALUE			(0x00000000uL)
+#define SSI_SSIFCR0_RTRG_VALUE			(0x00000000uL)
+#define SSI_SSIFCR_TIE_INIT_VALUE		(0x00000000uL)
+#define SSI_SSIFCR_RIE_INIT_VALUE		(0x00000000uL)
+#define SSI_SSIFCR_TFRST_INIT_VALUE		(0x00000002uL)
+#define SSI_SSIFCR_RFRST_INIT_VALUE		(0x00000001uL)
+
+#define SSI_SSIFCR_BASE_INIT_VALUE	(SSI_SSIFCR0_AUCKE_VALUE    | \
+					SSI_SSIFCR0_TTRG_VALUE      | \
+					SSI_SSIFCR0_RTRG_VALUE      | \
+					SSI_SSIFCR_TIE_INIT_VALUE   | \
+					SSI_SSIFCR_RIE_INIT_VALUE   | \
+					SSI_SSIFCR_TFRST_INIT_VALUE | \
+					SSI_SSIFCR_RFRST_INIT_VALUE)
+
+/******************************************************************************
+ ==== SWRSTCR1 ====
+******************************************************************************/
+#define	SWRSTCR1	0xFCFE0460	/* SWRSTCR1 Address */
+#define	SWRSTCR1_INIT	(0x00)		/* Initialize */
+#define	SWRSTCR1_SRST11	(1<<1)		/* SSIF5SRST */
+#define	SWRSTCR1_SRST12 (1<<2)		/* SSIF4SRST */
+#define	SWRSTCR1_SRST13 (1<<3)		/* SSIF3SRST */
+#define	SWRSTCR1_SRST14 (1<<4)		/* SSIF2SRST */
+#define	SWRSTCR1_SRST15 (1<<5)		/* SSIF1SRST */
+#define	SWRSTCR1_SRST16 (1<<6)		/* SSIF0SRST */
+#define	SWRSTCR1_AXTALE (1<<7)		/* AXTALE    */
+
+/************************************************************************
+	external prototype declaration
+************************************************************************/
+extern struct snd_soc_platform_driver scu_platform;
+extern struct scu_route_info *scu_get_route_info(void);
+extern struct scu_platform_data *scu_get_platform_data(void);
+extern void scu_init_ssi(int, int, int, int, int);
+extern void scu_init_src(int, unsigned int, unsigned int);
+extern void scu_init_dvc(int);
+extern void scu_deinit_ssi(int, int, int, int);
+extern void scu_deinit_src(int);
+extern void scu_deinit_dvc(int);
+extern int scu_check_route(int dir, struct scu_route_info *routeinfo);
+extern int scu_dai_add_control(struct snd_card *card);
+
+#endif /* SH_SCUX_H */
diff --git a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
old mode 100644
new mode 100755
index efb095dbc..e4b8786e4
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@ -218,6 +218,7 @@ config SND_SOC_ALL_CODECS
 	select SND_SOC_WM8971 if I2C
 	select SND_SOC_WM8974 if I2C
 	select SND_SOC_WM8978 if I2C
+	select SND_SOC_WM8978_SPI if (MACH_RZA2MEVB && SPI_MASTER)
 	select SND_SOC_WM8983 if SND_SOC_I2C_AND_SPI
 	select SND_SOC_WM8985 if SND_SOC_I2C_AND_SPI
 	select SND_SOC_WM8988 if SND_SOC_I2C_AND_SPI
@@ -1207,6 +1208,9 @@ config SND_SOC_WM8978
 	tristate "Wolfson Microelectronics WM8978 codec"
 	depends on I2C
 
+config SND_SOC_WM8978_SPI
+	tristate
+
 config SND_SOC_WM8983
 	tristate
 
diff --git a/sound/soc/codecs/Makefile b/sound/soc/codecs/Makefile
old mode 100644
new mode 100755
index 7ae7c85e8..205cca9f2
--- a/sound/soc/codecs/Makefile
+++ b/sound/soc/codecs/Makefile
@@ -233,6 +233,7 @@ snd-soc-wm8962-objs := wm8962.o
 snd-soc-wm8971-objs := wm8971.o
 snd-soc-wm8974-objs := wm8974.o
 snd-soc-wm8978-objs := wm8978.o
+snd-soc-wm8978-spi-objs := wm8978-spi.o
 snd-soc-wm8983-objs := wm8983.o
 snd-soc-wm8985-objs := wm8985.o
 snd-soc-wm8988-objs := wm8988.o
@@ -491,6 +492,7 @@ obj-$(CONFIG_SND_SOC_WM8962)	+= snd-soc-wm8962.o
 obj-$(CONFIG_SND_SOC_WM8971)	+= snd-soc-wm8971.o
 obj-$(CONFIG_SND_SOC_WM8974)	+= snd-soc-wm8974.o
 obj-$(CONFIG_SND_SOC_WM8978)	+= snd-soc-wm8978.o
+obj-$(CONFIG_SND_SOC_WM8978_SPI) += snd-soc-wm8978-spi.o
 obj-$(CONFIG_SND_SOC_WM8983)	+= snd-soc-wm8983.o
 obj-$(CONFIG_SND_SOC_WM8985)	+= snd-soc-wm8985.o
 obj-$(CONFIG_SND_SOC_WM8988)	+= snd-soc-wm8988.o
diff --git a/sound/soc/codecs/wm8978-spi.c b/sound/soc/codecs/wm8978-spi.c
new file mode 100755
index 000000000..bb41ab21e
--- /dev/null
+++ b/sound/soc/codecs/wm8978-spi.c
@@ -0,0 +1,1168 @@
+/*
+ * wm8978-spi.c  --  WM8978 ALSA SoC Audio Codec driver (spi-version)
+ *
+ * Copyright (C) 2009-2010 Guennadi Liakhovetski <g.liakhovetski@gmx.de>
+ * Copyright (C) 2007 Carlos Munoz <carlos@kenati.com>
+ * Copyright 2006-2009 Wolfson Microelectronics PLC.
+ * Based on wm8974 and wm8990 by Liam Girdwood <lrg@slimlogic.co.uk>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#if 0
+#include <linux/i2c.h>
+#endif
+#include <linux/pm.h>
+#include <linux/regmap.h>
+#include <linux/spi/spi.h>
+#include <linux/slab.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/initval.h>
+#include <sound/tlv.h>
+#include <asm/div64.h>
+
+#include "wm8978.h"
+
+static const struct reg_default wm8978_reg_defaults[] = {
+	{ 1, 0x0000 },
+	{ 2, 0x0000 },
+	{ 3, 0x0000 },
+	{ 4, 0x0050 },
+	{ 5, 0x0000 },
+	{ 6, 0x0140 },
+	{ 7, 0x0000 },
+	{ 8, 0x0000 },
+	{ 9, 0x0000 },
+	{ 10, 0x0000 },
+	{ 11, 0x00ff },
+	{ 12, 0x00ff },
+	{ 13, 0x0000 },
+	{ 14, 0x0100 },
+	{ 15, 0x00ff },
+	{ 16, 0x00ff },
+	{ 17, 0x0000 },
+	{ 18, 0x012c },
+	{ 19, 0x002c },
+	{ 20, 0x002c },
+	{ 21, 0x002c },
+	{ 22, 0x002c },
+	{ 23, 0x0000 },
+	{ 24, 0x0032 },
+	{ 25, 0x0000 },
+	{ 26, 0x0000 },
+	{ 27, 0x0000 },
+	{ 28, 0x0000 },
+	{ 29, 0x0000 },
+	{ 30, 0x0000 },
+	{ 31, 0x0000 },
+	{ 32, 0x0038 },
+	{ 33, 0x000b },
+	{ 34, 0x0032 },
+	{ 35, 0x0000 },
+	{ 36, 0x0008 },
+	{ 37, 0x000c },
+	{ 38, 0x0093 },
+	{ 39, 0x00e9 },
+	{ 40, 0x0000 },
+	{ 41, 0x0000 },
+	{ 42, 0x0000 },
+	{ 43, 0x0000 },
+	{ 44, 0x0033 },
+	{ 45, 0x0010 },
+	{ 46, 0x0010 },
+	{ 47, 0x0100 },
+	{ 48, 0x0100 },
+	{ 49, 0x0002 },
+	{ 50, 0x0001 },
+	{ 51, 0x0001 },
+	{ 52, 0x0039 },
+	{ 53, 0x0039 },
+	{ 54, 0x0039 },
+	{ 55, 0x0039 },
+	{ 56, 0x0001 },
+	{ 57, 0x0001 },
+};
+
+static bool wm8978_volatile(struct device *dev, unsigned int reg)
+{
+	return reg == WM8978_RESET;
+}
+
+/* codec private data */
+struct wm8978_priv {
+	struct regmap *regmap;
+	unsigned int f_pllout;
+	unsigned int f_mclk;
+	unsigned int f_256fs;
+	unsigned int f_opclk;
+	int mclk_idx;
+	enum wm8978_sysclk_src sysclk;
+};
+
+static const char *wm8978_companding[] = {"Off", "NC", "u-law", "A-law"};
+static const char *wm8978_eqmode[] = {"Capture", "Playback"};
+static const char *wm8978_bw[] = {"Narrow", "Wide"};
+static const char *wm8978_eq1[] = {"80Hz", "105Hz", "135Hz", "175Hz"};
+static const char *wm8978_eq2[] = {"230Hz", "300Hz", "385Hz", "500Hz"};
+static const char *wm8978_eq3[] = {"650Hz", "850Hz", "1.1kHz", "1.4kHz"};
+static const char *wm8978_eq4[] = {"1.8kHz", "2.4kHz", "3.2kHz", "4.1kHz"};
+static const char *wm8978_eq5[] = {"5.3kHz", "6.9kHz", "9kHz", "11.7kHz"};
+static const char *wm8978_alc3[] = {"ALC", "Limiter"};
+static const char *wm8978_alc1[] = {"Off", "Right", "Left", "Both"};
+
+static SOC_ENUM_SINGLE_DECL(adc_compand, WM8978_COMPANDING_CONTROL, 1,
+			    wm8978_companding);
+static SOC_ENUM_SINGLE_DECL(dac_compand, WM8978_COMPANDING_CONTROL, 3,
+			    wm8978_companding);
+static SOC_ENUM_SINGLE_DECL(eqmode, WM8978_EQ1, 8, wm8978_eqmode);
+static SOC_ENUM_SINGLE_DECL(eq1, WM8978_EQ1, 5, wm8978_eq1);
+static SOC_ENUM_SINGLE_DECL(eq2bw, WM8978_EQ2, 8, wm8978_bw);
+static SOC_ENUM_SINGLE_DECL(eq2, WM8978_EQ2, 5, wm8978_eq2);
+static SOC_ENUM_SINGLE_DECL(eq3bw, WM8978_EQ3, 8, wm8978_bw);
+static SOC_ENUM_SINGLE_DECL(eq3, WM8978_EQ3, 5, wm8978_eq3);
+static SOC_ENUM_SINGLE_DECL(eq4bw, WM8978_EQ4, 8, wm8978_bw);
+static SOC_ENUM_SINGLE_DECL(eq4, WM8978_EQ4, 5, wm8978_eq4);
+static SOC_ENUM_SINGLE_DECL(eq5, WM8978_EQ5, 5, wm8978_eq5);
+static SOC_ENUM_SINGLE_DECL(alc3, WM8978_ALC_CONTROL_3, 8, wm8978_alc3);
+static SOC_ENUM_SINGLE_DECL(alc1, WM8978_ALC_CONTROL_1, 7, wm8978_alc1);
+
+static const DECLARE_TLV_DB_SCALE(digital_tlv, -12750, 50, 1);
+static const DECLARE_TLV_DB_SCALE(eq_tlv, -1200, 100, 0);
+static const DECLARE_TLV_DB_SCALE(inpga_tlv, -1200, 75, 0);
+static const DECLARE_TLV_DB_SCALE(spk_tlv, -5700, 100, 0);
+static const DECLARE_TLV_DB_SCALE(boost_tlv, -1500, 300, 1);
+static const DECLARE_TLV_DB_SCALE(limiter_tlv, 0, 100, 0);
+
+static const struct snd_kcontrol_new wm8978_snd_controls[] = {
+
+	SOC_SINGLE("Digital Loopback Switch",
+		WM8978_COMPANDING_CONTROL, 0, 1, 0),
+
+	SOC_ENUM("ADC Companding", adc_compand),
+	SOC_ENUM("DAC Companding", dac_compand),
+
+	SOC_DOUBLE("DAC Inversion Switch", WM8978_DAC_CONTROL, 0, 1, 1, 0),
+
+#if !defined(CONFIG_MACH_RZA2MEVB) && !defined(CONFIG_MACH_RSKRZA1)
+	/* The volume of a codec is not changed */
+	SOC_DOUBLE_R_TLV("PCM Volume",
+		WM8978_LEFT_DAC_DIGITAL_VOLUME, WM8978_RIGHT_DAC_DIGITAL_VOLUME,
+		0, 255, 0, digital_tlv),
+#endif
+	SOC_SINGLE("High Pass Filter Switch", WM8978_ADC_CONTROL, 8, 1, 0),
+	SOC_SINGLE("High Pass Cut Off", WM8978_ADC_CONTROL, 4, 7, 0),
+	SOC_DOUBLE("ADC Inversion Switch", WM8978_ADC_CONTROL, 0, 1, 1, 0),
+
+	SOC_DOUBLE_R_TLV("ADC Volume",
+		WM8978_LEFT_ADC_DIGITAL_VOLUME, WM8978_RIGHT_ADC_DIGITAL_VOLUME,
+		0, 255, 0, digital_tlv),
+
+	SOC_ENUM("Equaliser Function", eqmode),
+	SOC_ENUM("EQ1 Cut Off", eq1),
+	SOC_SINGLE_TLV("EQ1 Volume", WM8978_EQ1,  0, 24, 1, eq_tlv),
+
+	SOC_ENUM("Equaliser EQ2 Bandwidth", eq2bw),
+	SOC_ENUM("EQ2 Cut Off", eq2),
+	SOC_SINGLE_TLV("EQ2 Volume", WM8978_EQ2,  0, 24, 1, eq_tlv),
+
+	SOC_ENUM("Equaliser EQ3 Bandwidth", eq3bw),
+	SOC_ENUM("EQ3 Cut Off", eq3),
+	SOC_SINGLE_TLV("EQ3 Volume", WM8978_EQ3,  0, 24, 1, eq_tlv),
+
+	SOC_ENUM("Equaliser EQ4 Bandwidth", eq4bw),
+	SOC_ENUM("EQ4 Cut Off", eq4),
+	SOC_SINGLE_TLV("EQ4 Volume", WM8978_EQ4,  0, 24, 1, eq_tlv),
+
+	SOC_ENUM("EQ5 Cut Off", eq5),
+	SOC_SINGLE_TLV("EQ5 Volume", WM8978_EQ5, 0, 24, 1, eq_tlv),
+
+	SOC_SINGLE("DAC Playback Limiter Switch",
+		WM8978_DAC_LIMITER_1, 8, 1, 0),
+	SOC_SINGLE("DAC Playback Limiter Decay",
+		WM8978_DAC_LIMITER_1, 4, 15, 0),
+	SOC_SINGLE("DAC Playback Limiter Attack",
+		WM8978_DAC_LIMITER_1, 0, 15, 0),
+
+	SOC_SINGLE("DAC Playback Limiter Threshold",
+		WM8978_DAC_LIMITER_2, 4, 7, 0),
+	SOC_SINGLE_TLV("DAC Playback Limiter Volume",
+		WM8978_DAC_LIMITER_2, 0, 12, 0, limiter_tlv),
+
+	SOC_ENUM("ALC Enable Switch", alc1),
+	SOC_SINGLE("ALC Capture Min Gain", WM8978_ALC_CONTROL_1, 0, 7, 0),
+	SOC_SINGLE("ALC Capture Max Gain", WM8978_ALC_CONTROL_1, 3, 7, 0),
+
+	SOC_SINGLE("ALC Capture Hold", WM8978_ALC_CONTROL_2, 4, 10, 0),
+	SOC_SINGLE("ALC Capture Target", WM8978_ALC_CONTROL_2, 0, 15, 0),
+
+	SOC_ENUM("ALC Capture Mode", alc3),
+	SOC_SINGLE("ALC Capture Decay", WM8978_ALC_CONTROL_3, 4, 10, 0),
+	SOC_SINGLE("ALC Capture Attack", WM8978_ALC_CONTROL_3, 0, 10, 0),
+
+	SOC_SINGLE("ALC Capture Noise Gate Switch", WM8978_NOISE_GATE, 3, 1, 0),
+	SOC_SINGLE("ALC Capture Noise Gate Threshold",
+		WM8978_NOISE_GATE, 0, 7, 0),
+
+	SOC_DOUBLE_R("Capture PGA ZC Switch",
+		WM8978_LEFT_INP_PGA_CONTROL, WM8978_RIGHT_INP_PGA_CONTROL,
+		7, 1, 0),
+
+	/* OUT1 - Headphones */
+	SOC_DOUBLE_R("Headphone Playback ZC Switch",
+		WM8978_LOUT1_HP_CONTROL, WM8978_ROUT1_HP_CONTROL, 7, 1, 0),
+
+	SOC_DOUBLE_R_TLV("Headphone Playback Volume",
+		WM8978_LOUT1_HP_CONTROL, WM8978_ROUT1_HP_CONTROL,
+		0, 63, 0, spk_tlv),
+
+	/* OUT2 - Speakers */
+	SOC_DOUBLE_R("Speaker Playback ZC Switch",
+		WM8978_LOUT2_SPK_CONTROL, WM8978_ROUT2_SPK_CONTROL, 7, 1, 0),
+
+	SOC_DOUBLE_R_TLV("Speaker Playback Volume",
+		WM8978_LOUT2_SPK_CONTROL, WM8978_ROUT2_SPK_CONTROL,
+		0, 63, 0, spk_tlv),
+
+	/* OUT3/4 - Line Output */
+	SOC_DOUBLE_R("Line Playback Switch",
+		WM8978_OUT3_MIXER_CONTROL, WM8978_OUT4_MIXER_CONTROL, 6, 1, 1),
+
+	/* Mixer #3: Boost (Input) mixer */
+	SOC_DOUBLE_R("PGA Boost (+20dB)",
+		WM8978_LEFT_ADC_BOOST_CONTROL, WM8978_RIGHT_ADC_BOOST_CONTROL,
+		8, 1, 0),
+	SOC_DOUBLE_R_TLV("L2/R2 Boost Volume",
+		WM8978_LEFT_ADC_BOOST_CONTROL, WM8978_RIGHT_ADC_BOOST_CONTROL,
+		4, 7, 0, boost_tlv),
+	SOC_DOUBLE_R_TLV("Aux Boost Volume",
+		WM8978_LEFT_ADC_BOOST_CONTROL, WM8978_RIGHT_ADC_BOOST_CONTROL,
+		0, 7, 0, boost_tlv),
+
+	/* Input PGA volume */
+	SOC_DOUBLE_R_TLV("Input PGA Volume",
+		WM8978_LEFT_INP_PGA_CONTROL, WM8978_RIGHT_INP_PGA_CONTROL,
+		0, 63, 0, inpga_tlv),
+
+	/* Headphone */
+	SOC_DOUBLE_R("Headphone Switch",
+		WM8978_LOUT1_HP_CONTROL, WM8978_ROUT1_HP_CONTROL, 6, 1, 1),
+
+	/* Speaker */
+	SOC_DOUBLE_R("Speaker Switch",
+		WM8978_LOUT2_SPK_CONTROL, WM8978_ROUT2_SPK_CONTROL, 6, 1, 1),
+
+	/* DAC / ADC oversampling */
+	SOC_SINGLE("DAC 128x Oversampling Switch", WM8978_DAC_CONTROL,
+		   5, 1, 0),
+	SOC_SINGLE("ADC 128x Oversampling Switch", WM8978_ADC_CONTROL,
+		   5, 1, 0),
+};
+
+/* Mixer #1: Output (OUT1, OUT2) Mixer: mix AUX, Input mixer output and DAC */
+static const struct snd_kcontrol_new wm8978_left_out_mixer[] = {
+	SOC_DAPM_SINGLE("Line Bypass Switch", WM8978_LEFT_MIXER_CONTROL, 1, 1, 0),
+	SOC_DAPM_SINGLE("Aux Playback Switch", WM8978_LEFT_MIXER_CONTROL, 5, 1, 0),
+	SOC_DAPM_SINGLE("PCM Playback Switch", WM8978_LEFT_MIXER_CONTROL, 0, 1, 0),
+};
+
+static const struct snd_kcontrol_new wm8978_right_out_mixer[] = {
+	SOC_DAPM_SINGLE("Line Bypass Switch", WM8978_RIGHT_MIXER_CONTROL, 1, 1, 0),
+	SOC_DAPM_SINGLE("Aux Playback Switch", WM8978_RIGHT_MIXER_CONTROL, 5, 1, 0),
+	SOC_DAPM_SINGLE("PCM Playback Switch", WM8978_RIGHT_MIXER_CONTROL, 0, 1, 0),
+};
+
+/* OUT3/OUT4 Mixer not implemented */
+
+/* Mixer #2: Input PGA Mute */
+static const struct snd_kcontrol_new wm8978_left_input_mixer[] = {
+	SOC_DAPM_SINGLE("L2 Switch", WM8978_INPUT_CONTROL, 2, 1, 0),
+	SOC_DAPM_SINGLE("MicN Switch", WM8978_INPUT_CONTROL, 1, 1, 0),
+	SOC_DAPM_SINGLE("MicP Switch", WM8978_INPUT_CONTROL, 0, 1, 0),
+};
+static const struct snd_kcontrol_new wm8978_right_input_mixer[] = {
+	SOC_DAPM_SINGLE("R2 Switch", WM8978_INPUT_CONTROL, 6, 1, 0),
+	SOC_DAPM_SINGLE("MicN Switch", WM8978_INPUT_CONTROL, 5, 1, 0),
+	SOC_DAPM_SINGLE("MicP Switch", WM8978_INPUT_CONTROL, 4, 1, 0),
+};
+
+static const struct snd_soc_dapm_widget wm8978_dapm_widgets[] = {
+	SND_SOC_DAPM_DAC("Left DAC", "Left HiFi Playback",
+			 WM8978_POWER_MANAGEMENT_3, 0, 0),
+	SND_SOC_DAPM_DAC("Right DAC", "Right HiFi Playback",
+			 WM8978_POWER_MANAGEMENT_3, 1, 0),
+	SND_SOC_DAPM_ADC("Left ADC", "Left HiFi Capture",
+			 WM8978_POWER_MANAGEMENT_2, 0, 0),
+	SND_SOC_DAPM_ADC("Right ADC", "Right HiFi Capture",
+			 WM8978_POWER_MANAGEMENT_2, 1, 0),
+
+	/* Mixer #1: OUT1,2 */
+	SOC_MIXER_ARRAY("Left Output Mixer", WM8978_POWER_MANAGEMENT_3,
+			2, 0, wm8978_left_out_mixer),
+	SOC_MIXER_ARRAY("Right Output Mixer", WM8978_POWER_MANAGEMENT_3,
+			3, 0, wm8978_right_out_mixer),
+
+	SOC_MIXER_ARRAY("Left Input Mixer", WM8978_POWER_MANAGEMENT_2,
+			2, 0, wm8978_left_input_mixer),
+	SOC_MIXER_ARRAY("Right Input Mixer", WM8978_POWER_MANAGEMENT_2,
+			3, 0, wm8978_right_input_mixer),
+
+	SND_SOC_DAPM_PGA("Left Boost Mixer", WM8978_POWER_MANAGEMENT_2,
+			 4, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("Right Boost Mixer", WM8978_POWER_MANAGEMENT_2,
+			 5, 0, NULL, 0),
+
+	SND_SOC_DAPM_PGA("Left Capture PGA", WM8978_LEFT_INP_PGA_CONTROL,
+			 6, 1, NULL, 0),
+	SND_SOC_DAPM_PGA("Right Capture PGA", WM8978_RIGHT_INP_PGA_CONTROL,
+			 6, 1, NULL, 0),
+
+	SND_SOC_DAPM_PGA("Left Headphone Out", WM8978_POWER_MANAGEMENT_2,
+			 7, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("Right Headphone Out", WM8978_POWER_MANAGEMENT_2,
+			 8, 0, NULL, 0),
+
+	SND_SOC_DAPM_PGA("Left Speaker Out", WM8978_POWER_MANAGEMENT_3,
+			 6, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("Right Speaker Out", WM8978_POWER_MANAGEMENT_3,
+			 5, 0, NULL, 0),
+
+	SND_SOC_DAPM_MIXER("OUT4 VMID", WM8978_POWER_MANAGEMENT_3,
+			   8, 0, NULL, 0),
+
+	SND_SOC_DAPM_MICBIAS("Mic Bias", WM8978_POWER_MANAGEMENT_1, 4, 0),
+
+	SND_SOC_DAPM_INPUT("LMICN"),
+	SND_SOC_DAPM_INPUT("LMICP"),
+	SND_SOC_DAPM_INPUT("RMICN"),
+	SND_SOC_DAPM_INPUT("RMICP"),
+	SND_SOC_DAPM_INPUT("LAUX"),
+	SND_SOC_DAPM_INPUT("RAUX"),
+	SND_SOC_DAPM_INPUT("L2"),
+	SND_SOC_DAPM_INPUT("R2"),
+	SND_SOC_DAPM_OUTPUT("LHP"),
+	SND_SOC_DAPM_OUTPUT("RHP"),
+	SND_SOC_DAPM_OUTPUT("LSPK"),
+	SND_SOC_DAPM_OUTPUT("RSPK"),
+};
+
+static const struct snd_soc_dapm_route wm8978_dapm_routes[] = {
+	/* Output mixer */
+	{"Right Output Mixer", "PCM Playback Switch", "Right DAC"},
+	{"Right Output Mixer", "Aux Playback Switch", "RAUX"},
+	{"Right Output Mixer", "Line Bypass Switch", "Right Boost Mixer"},
+
+	{"Left Output Mixer", "PCM Playback Switch", "Left DAC"},
+	{"Left Output Mixer", "Aux Playback Switch", "LAUX"},
+	{"Left Output Mixer", "Line Bypass Switch", "Left Boost Mixer"},
+
+	/* Outputs */
+	{"Right Headphone Out", NULL, "Right Output Mixer"},
+	{"RHP", NULL, "Right Headphone Out"},
+
+	{"Left Headphone Out", NULL, "Left Output Mixer"},
+	{"LHP", NULL, "Left Headphone Out"},
+
+	{"Right Speaker Out", NULL, "Right Output Mixer"},
+	{"RSPK", NULL, "Right Speaker Out"},
+
+	{"Left Speaker Out", NULL, "Left Output Mixer"},
+	{"LSPK", NULL, "Left Speaker Out"},
+
+	/* Boost Mixer */
+	{"Right ADC", NULL, "Right Boost Mixer"},
+
+	{"Right Boost Mixer", NULL, "RAUX"},
+	{"Right Boost Mixer", NULL, "Right Capture PGA"},
+	{"Right Boost Mixer", NULL, "R2"},
+
+	{"Left ADC", NULL, "Left Boost Mixer"},
+
+	{"Left Boost Mixer", NULL, "LAUX"},
+	{"Left Boost Mixer", NULL, "Left Capture PGA"},
+	{"Left Boost Mixer", NULL, "L2"},
+
+	/* Input PGA */
+	{"Right Capture PGA", NULL, "Right Input Mixer"},
+	{"Left Capture PGA", NULL, "Left Input Mixer"},
+
+	{"Right Input Mixer", "R2 Switch", "R2"},
+	{"Right Input Mixer", "MicN Switch", "RMICN"},
+	{"Right Input Mixer", "MicP Switch", "RMICP"},
+
+	{"Left Input Mixer", "L2 Switch", "L2"},
+	{"Left Input Mixer", "MicN Switch", "LMICN"},
+	{"Left Input Mixer", "MicP Switch", "LMICP"},
+};
+
+/* PLL divisors */
+struct wm8978_pll_div {
+	u32 k;
+	u8 n;
+	u8 div2;
+};
+
+#define FIXED_PLL_SIZE (1 << 24)
+
+static void pll_factors(struct snd_soc_component *component,
+		struct wm8978_pll_div *pll_div, unsigned int target, unsigned int source)
+{
+	u64 k_part;
+	unsigned int k, n_div, n_mod;
+
+	n_div = target / source;
+	if (n_div < 6) {
+		source >>= 1;
+		pll_div->div2 = 1;
+		n_div = target / source;
+	} else {
+		pll_div->div2 = 0;
+	}
+
+	if (n_div < 6 || n_div > 12)
+		dev_warn(component->dev,
+			 "WM8978 N value exceeds recommended range! N = %u\n",
+			 n_div);
+
+	pll_div->n = n_div;
+	n_mod = target - source * n_div;
+	k_part = FIXED_PLL_SIZE * (long long)n_mod + source / 2;
+
+	do_div(k_part, source);
+
+	k = k_part & 0xFFFFFFFF;
+
+	pll_div->k = k;
+}
+
+/* MCLK dividers */
+static const int mclk_numerator[]	= {1, 3, 2, 3, 4, 6, 8, 12};
+static const int mclk_denominator[]	= {1, 2, 1, 1, 1, 1, 1, 1};
+
+/*
+ * find index >= idx, such that, for a given f_out,
+ * 3 * f_mclk / 4 <= f_PLLOUT < 13 * f_mclk / 4
+ * f_out can be f_256fs or f_opclk, currently only used for f_256fs. Can be
+ * generalised for f_opclk with suitable coefficient arrays, but currently
+ * the OPCLK divisor is calculated directly, not iteratively.
+ */
+static int wm8978_enum_mclk(unsigned int f_out, unsigned int f_mclk,
+			    unsigned int *f_pllout)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(mclk_numerator); i++) {
+		unsigned int f_pllout_x4 = 4 * f_out * mclk_numerator[i] /
+			mclk_denominator[i];
+		if (3 * f_mclk <= f_pllout_x4 && f_pllout_x4 < 13 * f_mclk) {
+			*f_pllout = f_pllout_x4 / 4;
+			return i;
+		}
+	}
+
+	return -EINVAL;
+}
+
+/*
+ * Calculate internal frequencies and dividers, according to Figure 40
+ * "PLL and Clock Select Circuit" in WM8978 datasheet Rev. 2.6
+ */
+static int wm8978_configure_pll(struct snd_soc_component *component)
+{
+	struct wm8978_priv *wm8978 = snd_soc_component_get_drvdata(component);
+	struct wm8978_pll_div pll_div;
+	unsigned int f_opclk = wm8978->f_opclk, f_mclk = wm8978->f_mclk,
+		f_256fs = wm8978->f_256fs;
+	unsigned int f2;
+
+	if (!f_mclk)
+		return -EINVAL;
+
+	if (f_opclk) {
+		unsigned int opclk_div;
+		/* Cannot set up MCLK divider now, do later */
+		wm8978->mclk_idx = -1;
+
+		/*
+		 * The user needs OPCLK. Choose OPCLKDIV to put
+		 * 6 <= R = f2 / f1 < 13, 1 <= OPCLKDIV <= 4.
+		 * f_opclk = f_mclk * prescale * R / 4 / OPCLKDIV, where
+		 * prescale = 1, or prescale = 2. Prescale is calculated inside
+		 * pll_factors(). We have to select f_PLLOUT, such that
+		 * f_mclk * 3 / 4 <= f_PLLOUT < f_mclk * 13 / 4. Must be
+		 * f_mclk * 3 / 16 <= f_opclk < f_mclk * 13 / 4.
+		 */
+		if (16 * f_opclk < 3 * f_mclk || 4 * f_opclk >= 13 * f_mclk)
+			return -EINVAL;
+
+		if (4 * f_opclk < 3 * f_mclk)
+			/* Have to use OPCLKDIV */
+			opclk_div = (3 * f_mclk / 4 + f_opclk - 1) / f_opclk;
+		else
+			opclk_div = 1;
+
+		dev_dbg(component->dev, "%s: OPCLKDIV=%d\n", __func__, opclk_div);
+
+		snd_soc_component_update_bits(component, WM8978_GPIO_CONTROL, 0x30,
+				    (opclk_div - 1) << 4);
+
+		wm8978->f_pllout = f_opclk * opclk_div;
+	} else if (f_256fs) {
+		/*
+		 * Not using OPCLK, but PLL is used for the codec, choose R:
+		 * 6 <= R = f2 / f1 < 13, to put 1 <= MCLKDIV <= 12.
+		 * f_256fs = f_mclk * prescale * R / 4 / MCLKDIV, where
+		 * prescale = 1, or prescale = 2. Prescale is calculated inside
+		 * pll_factors(). We have to select f_PLLOUT, such that
+		 * f_mclk * 3 / 4 <= f_PLLOUT < f_mclk * 13 / 4. Must be
+		 * f_mclk * 3 / 48 <= f_256fs < f_mclk * 13 / 4. This means MCLK
+		 * must be 3.781MHz <= f_MCLK <= 32.768MHz
+		 */
+		int idx = wm8978_enum_mclk(f_256fs, f_mclk, &wm8978->f_pllout);
+		if (idx < 0)
+			return idx;
+
+		wm8978->mclk_idx = idx;
+	} else {
+		return -EINVAL;
+	}
+
+	f2 = wm8978->f_pllout * 4;
+
+	dev_dbg(component->dev, "%s: f_MCLK=%uHz, f_PLLOUT=%uHz\n", __func__,
+		wm8978->f_mclk, wm8978->f_pllout);
+
+	pll_factors(component, &pll_div, f2, wm8978->f_mclk);
+
+	dev_dbg(component->dev, "%s: calculated PLL N=0x%x, K=0x%x, div2=%d\n",
+		__func__, pll_div.n, pll_div.k, pll_div.div2);
+
+	/* Turn PLL off for configuration... */
+	snd_soc_component_update_bits(component, WM8978_POWER_MANAGEMENT_1, 0x20, 0);
+
+	snd_soc_component_write(component, WM8978_PLL_N, (pll_div.div2 << 4) | pll_div.n);
+	snd_soc_component_write(component, WM8978_PLL_K1, pll_div.k >> 18);
+	snd_soc_component_write(component, WM8978_PLL_K2, (pll_div.k >> 9) & 0x1ff);
+	snd_soc_component_write(component, WM8978_PLL_K3, pll_div.k & 0x1ff);
+
+	/* ...and on again */
+	snd_soc_component_update_bits(component, WM8978_POWER_MANAGEMENT_1, 0x20, 0x20);
+
+	if (f_opclk)
+		/* Output PLL (OPCLK) to GPIO1 */
+		snd_soc_component_update_bits(component, WM8978_GPIO_CONTROL, 7, 4);
+
+	return 0;
+}
+
+/*
+ * Configure WM8978 clock dividers.
+ */
+static int wm8978_set_dai_clkdiv(struct snd_soc_dai *codec_dai,
+				 int div_id, int div)
+{
+	struct snd_soc_component *component = codec_dai->component;
+	struct wm8978_priv *wm8978 = snd_soc_component_get_drvdata(component);
+	int ret = 0;
+
+	switch (div_id) {
+	case WM8978_OPCLKRATE:
+		wm8978->f_opclk = div;
+
+		if (wm8978->f_mclk)
+			/*
+			 * We know the MCLK frequency, the user has requested
+			 * OPCLK, configure the PLL based on that and start it
+			 * and OPCLK immediately. We will configure PLL to match
+			 * user-requested OPCLK frquency as good as possible.
+			 * In fact, it is likely, that matching the sampling
+			 * rate, when it becomes known, is more important, and
+			 * we will not be reconfiguring PLL then, because we
+			 * must not interrupt OPCLK. But it should be fine,
+			 * because typically the user will request OPCLK to run
+			 * at 256fs or 512fs, and for these cases we will also
+			 * find an exact MCLK divider configuration - it will
+			 * be equal to or double the OPCLK divisor.
+			 */
+			ret = wm8978_configure_pll(component);
+		break;
+	case WM8978_BCLKDIV:
+		if (div & ~0x1c)
+			return -EINVAL;
+		snd_soc_component_update_bits(component, WM8978_CLOCKING, 0x1c, div);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	dev_dbg(component->dev, "%s: ID %d, value %u\n", __func__, div_id, div);
+
+	return ret;
+}
+
+/*
+ * @freq:	when .set_pll() us not used, freq is codec MCLK input frequency
+ */
+static int wm8978_set_dai_sysclk(struct snd_soc_dai *codec_dai, int clk_id,
+				 unsigned int freq, int dir)
+{
+	struct snd_soc_component *component = codec_dai->component;
+	struct wm8978_priv *wm8978 = snd_soc_component_get_drvdata(component);
+	int ret = 0;
+
+	dev_dbg(component->dev, "%s: ID %d, freq %u\n", __func__, clk_id, freq);
+
+	if (freq) {
+		wm8978->f_mclk = freq;
+
+		/* Even if MCLK is used for system clock, might have to drive OPCLK */
+		if (wm8978->f_opclk)
+			ret = wm8978_configure_pll(component);
+
+		/* Our sysclk is fixed to 256 * fs, will configure in .hw_params()  */
+
+		if (!ret)
+			wm8978->sysclk = clk_id;
+	}
+
+	if (wm8978->sysclk == WM8978_PLL && (!freq || clk_id == WM8978_MCLK)) {
+		/* Clock CODEC directly from MCLK */
+		snd_soc_component_update_bits(component, WM8978_CLOCKING, 0x100, 0);
+
+		/* GPIO1 into default mode as input - before configuring PLL */
+		snd_soc_component_update_bits(component, WM8978_GPIO_CONTROL, 7, 0);
+
+		/* Turn off PLL */
+		snd_soc_component_update_bits(component, WM8978_POWER_MANAGEMENT_1, 0x20, 0);
+		wm8978->sysclk = WM8978_MCLK;
+		wm8978->f_pllout = 0;
+		wm8978->f_opclk = 0;
+	}
+
+	return ret;
+}
+
+/*
+ * Set ADC and Voice DAC format.
+ */
+static int wm8978_set_dai_fmt(struct snd_soc_dai *codec_dai, unsigned int fmt)
+{
+	struct snd_soc_component *component = codec_dai->component;
+	/*
+	 * BCLK polarity mask = 0x100, LRC clock polarity mask = 0x80,
+	 * Data Format mask = 0x18: all will be calculated anew
+	 */
+	u16 iface = snd_soc_component_read32(component, WM8978_AUDIO_INTERFACE) & ~0x198;
+	u16 clk = snd_soc_component_read32(component, WM8978_CLOCKING);
+
+	dev_dbg(component->dev, "%s\n", __func__);
+
+	/* set master/slave audio interface */
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:
+		clk |= 1;
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:
+		clk &= ~1;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* interface format */
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		iface |= 0x10;
+		break;
+	case SND_SOC_DAIFMT_RIGHT_J:
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		iface |= 0x8;
+		break;
+	case SND_SOC_DAIFMT_DSP_A:
+		iface |= 0x18;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* clock inversion */
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		break;
+	case SND_SOC_DAIFMT_IB_IF:
+		iface |= 0x180;
+		break;
+	case SND_SOC_DAIFMT_IB_NF:
+		iface |= 0x100;
+		break;
+	case SND_SOC_DAIFMT_NB_IF:
+		iface |= 0x80;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	snd_soc_component_write(component, WM8978_AUDIO_INTERFACE, iface);
+	snd_soc_component_write(component, WM8978_CLOCKING, clk);
+
+	return 0;
+}
+
+/*
+ * Set PCM DAI bit size and sample rate.
+ */
+static int wm8978_hw_params(struct snd_pcm_substream *substream,
+			    struct snd_pcm_hw_params *params,
+			    struct snd_soc_dai *dai)
+{
+	struct snd_soc_component *component = dai->component;
+	struct wm8978_priv *wm8978 = snd_soc_component_get_drvdata(component);
+	/* Word length mask = 0x60 */
+	u16 iface_ctl = snd_soc_component_read32(component, WM8978_AUDIO_INTERFACE) & ~0x60;
+	/* Sampling rate mask = 0xe (for filters) */
+	u16 add_ctl = snd_soc_component_read32(component, WM8978_ADDITIONAL_CONTROL) & ~0xe;
+	u16 clking = snd_soc_component_read32(component, WM8978_CLOCKING);
+	enum wm8978_sysclk_src current_clk_id = clking & 0x100 ?
+		WM8978_PLL : WM8978_MCLK;
+	unsigned int f_sel, diff, diff_best = INT_MAX;
+	int i, best = 0;
+
+	if (!wm8978->f_mclk)
+		return -EINVAL;
+
+	/* bit size */
+	switch (params_width(params)) {
+	case 16:
+		break;
+	case 20:
+		iface_ctl |= 0x20;
+		break;
+	case 24:
+		iface_ctl |= 0x40;
+		break;
+	case 32:
+		iface_ctl |= 0x60;
+		break;
+	}
+
+#if !defined(CONFIG_MACH_RZA2MEVB) && !defined(CONFIG_MACH_RSKRZA1)
+	/* Codec setup is fixed to 44100Hz */
+	/* filter coefficient */
+	switch (params_rate(params)) {
+	case 8000:
+		add_ctl |= 0x5 << 1;
+		break;
+	case 11025:
+		add_ctl |= 0x4 << 1;
+		break;
+	case 16000:
+		add_ctl |= 0x3 << 1;
+		break;
+	case 22050:
+		add_ctl |= 0x2 << 1;
+		break;
+	case 32000:
+		add_ctl |= 0x1 << 1;
+		break;
+	case 44100:
+	case 48000:
+		break;
+	}
+
+	/* Sampling rate is known now, can configure the MCLK divider */
+	wm8978->f_256fs = params_rate(params) * 256;
+#else
+	wm8978->f_256fs = 44100 * 256;
+#endif
+
+	if (wm8978->sysclk == WM8978_MCLK) {
+		wm8978->mclk_idx = -1;
+		f_sel = wm8978->f_mclk;
+	} else {
+		if (!wm8978->f_opclk) {
+			/* We only enter here, if OPCLK is not used */
+			int ret = wm8978_configure_pll(component);
+			if (ret < 0)
+				return ret;
+		}
+		f_sel = wm8978->f_pllout;
+	}
+
+	if (wm8978->mclk_idx < 0) {
+		/* Either MCLK is used directly, or OPCLK is used */
+		if (f_sel < wm8978->f_256fs || f_sel > 12 * wm8978->f_256fs)
+			return -EINVAL;
+
+		for (i = 0; i < ARRAY_SIZE(mclk_numerator); i++) {
+			diff = abs(wm8978->f_256fs * 3 -
+				   f_sel * 3 * mclk_denominator[i] / mclk_numerator[i]);
+
+			if (diff < diff_best) {
+				diff_best = diff;
+				best = i;
+			}
+
+			if (!diff)
+				break;
+		}
+	} else {
+		/* OPCLK not used, codec driven by PLL */
+		best = wm8978->mclk_idx;
+		diff = 0;
+	}
+
+	if (diff)
+		dev_warn(component->dev, "Imprecise sampling rate: %uHz%s\n",
+			f_sel * mclk_denominator[best] / mclk_numerator[best] / 256,
+			wm8978->sysclk == WM8978_MCLK ?
+			", consider using PLL" : "");
+
+	dev_dbg(component->dev, "%s: width %d, rate %u, MCLK divisor #%d\n", __func__,
+		params_width(params), params_rate(params), best);
+
+	/* MCLK divisor mask = 0xe0 */
+	snd_soc_component_update_bits(component, WM8978_CLOCKING, 0xe0, best << 5);
+
+	snd_soc_component_write(component, WM8978_AUDIO_INTERFACE, iface_ctl);
+	snd_soc_component_write(component, WM8978_ADDITIONAL_CONTROL, add_ctl);
+
+	if (wm8978->sysclk != current_clk_id) {
+		if (wm8978->sysclk == WM8978_PLL)
+			/* Run CODEC from PLL instead of MCLK */
+			snd_soc_component_update_bits(component, WM8978_CLOCKING,
+					    0x100, 0x100);
+		else
+			/* Clock CODEC directly from MCLK */
+			snd_soc_component_update_bits(component, WM8978_CLOCKING, 0x100, 0);
+	}
+
+	return 0;
+}
+
+static int wm8978_mute(struct snd_soc_dai *dai, int mute)
+{
+	struct snd_soc_component *component = dai->component;
+
+	dev_dbg(component->dev, "%s: %d\n", __func__, mute);
+
+	if (mute)
+		snd_soc_component_update_bits(component, WM8978_DAC_CONTROL, 0x40, 0x40);
+	else
+		snd_soc_component_update_bits(component, WM8978_DAC_CONTROL, 0x40, 0);
+
+	return 0;
+}
+
+static int wm8978_set_bias_level(struct snd_soc_component *component,
+				 enum snd_soc_bias_level level)
+{
+	u16 power1 = snd_soc_component_read32(component, WM8978_POWER_MANAGEMENT_1) & ~3;
+
+	switch (level) {
+	case SND_SOC_BIAS_ON:
+	case SND_SOC_BIAS_PREPARE:
+		power1 |= 1;  /* VMID 75k */
+		snd_soc_component_write(component, WM8978_POWER_MANAGEMENT_1, power1);
+		break;
+	case SND_SOC_BIAS_STANDBY:
+		/* bit 3: enable bias, bit 2: enable I/O tie off buffer */
+		power1 |= 0xc;
+
+		if (snd_soc_component_get_bias_level(component) == SND_SOC_BIAS_OFF) {
+			/* Initial cap charge at VMID 5k */
+			snd_soc_component_write(component, WM8978_POWER_MANAGEMENT_1,
+				      power1 | 0x3);
+			mdelay(100);
+		}
+
+		power1 |= 0x2;  /* VMID 500k */
+		snd_soc_component_write(component, WM8978_POWER_MANAGEMENT_1, power1);
+		break;
+	case SND_SOC_BIAS_OFF:
+		/* Preserve PLL - OPCLK may be used by someone */
+		snd_soc_component_update_bits(component, WM8978_POWER_MANAGEMENT_1, ~0x20, 0);
+		snd_soc_component_write(component, WM8978_POWER_MANAGEMENT_2, 0);
+		snd_soc_component_write(component, WM8978_POWER_MANAGEMENT_3, 0);
+		break;
+	}
+
+	dev_dbg(component->dev, "%s: %d, %x\n", __func__, level, power1);
+
+	return 0;
+}
+
+#define WM8978_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | SNDRV_PCM_FMTBIT_S20_3LE | \
+	SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
+
+static const struct snd_soc_dai_ops wm8978_dai_ops = {
+	.hw_params	= wm8978_hw_params,
+	.digital_mute	= wm8978_mute,
+	.set_fmt	= wm8978_set_dai_fmt,
+	.set_clkdiv	= wm8978_set_dai_clkdiv,
+	.set_sysclk	= wm8978_set_dai_sysclk,
+};
+
+/* Also supports 12kHz */
+static struct snd_soc_dai_driver wm8978_dai = {
+	.name = "wm8978-hifi",
+	.playback = {
+		.stream_name = "Playback",
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = SNDRV_PCM_RATE_8000_48000,
+		.formats = WM8978_FORMATS,
+	},
+	.capture = {
+		.stream_name = "Capture",
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = SNDRV_PCM_RATE_8000_48000,
+		.formats = WM8978_FORMATS,
+	},
+	.ops = &wm8978_dai_ops,
+	.symmetric_rates = 1,
+};
+
+static int wm8978_suspend(struct snd_soc_component *component)
+{
+	struct wm8978_priv *wm8978 = snd_soc_component_get_drvdata(component);
+
+	snd_soc_component_force_bias_level(component, SND_SOC_BIAS_OFF);
+	/* Also switch PLL off */
+	snd_soc_component_write(component, WM8978_POWER_MANAGEMENT_1, 0);
+
+	regcache_mark_dirty(wm8978->regmap);
+
+	return 0;
+}
+
+static int wm8978_resume(struct snd_soc_component *component)
+{
+	struct wm8978_priv *wm8978 = snd_soc_component_get_drvdata(component);
+
+	/* Sync reg_cache with the hardware */
+	regcache_sync(wm8978->regmap);
+
+	snd_soc_component_force_bias_level(component, SND_SOC_BIAS_STANDBY);
+
+	if (wm8978->f_pllout)
+		/* Switch PLL on */
+		snd_soc_component_update_bits(component, WM8978_POWER_MANAGEMENT_1, 0x20, 0x20);
+
+	return 0;
+}
+
+/*
+ * These registers contain an "update" bit - bit 8. This means, for example,
+ * that one can write new DAC digital volume for both channels, but only when
+ * the update bit is set, will also the volume be updated - simultaneously for
+ * both channels.
+ */
+static const int update_reg[] = {
+	WM8978_LEFT_DAC_DIGITAL_VOLUME,
+	WM8978_RIGHT_DAC_DIGITAL_VOLUME,
+	WM8978_LEFT_ADC_DIGITAL_VOLUME,
+	WM8978_RIGHT_ADC_DIGITAL_VOLUME,
+	WM8978_LEFT_INP_PGA_CONTROL,
+	WM8978_RIGHT_INP_PGA_CONTROL,
+	WM8978_LOUT1_HP_CONTROL,
+	WM8978_ROUT1_HP_CONTROL,
+	WM8978_LOUT2_SPK_CONTROL,
+	WM8978_ROUT2_SPK_CONTROL,
+};
+
+static int wm8978_probe(struct snd_soc_component *component)
+{
+	struct wm8978_priv *wm8978 = snd_soc_component_get_drvdata(component);
+	int i;
+
+	/*
+	 * Set default system clock to PLL, it is more precise, this is also the
+	 * default hardware setting
+	 */
+	wm8978->sysclk = WM8978_PLL;
+
+	/*
+	 * Set the update bit in all registers, that have one. This way all
+	 * writes to those registers will also cause the update bit to be
+	 * written.
+	 */
+	for (i = 0; i < ARRAY_SIZE(update_reg); i++)
+		snd_soc_component_update_bits(component, update_reg[i], 0x100, 0x100);
+
+	return 0;
+}
+
+static const struct snd_soc_component_driver soc_component_dev_wm8978 = {
+	.probe			= wm8978_probe,
+	.suspend		= wm8978_suspend,
+	.resume			= wm8978_resume,
+	.set_bias_level		= wm8978_set_bias_level,
+	.controls		= wm8978_snd_controls,
+	.num_controls		= ARRAY_SIZE(wm8978_snd_controls),
+	.dapm_widgets		= wm8978_dapm_widgets,
+	.num_dapm_widgets	= ARRAY_SIZE(wm8978_dapm_widgets),
+	.dapm_routes		= wm8978_dapm_routes,
+	.num_dapm_routes	= ARRAY_SIZE(wm8978_dapm_routes),
+	.idle_bias_on		= 1,
+	.use_pmdown_time	= 1,
+	.endianness		= 1,
+	.non_legacy_dai_naming	= 1,
+};
+
+static const struct regmap_config wm8978_regmap_config = {
+	.reg_bits = 7,
+	.val_bits = 9,
+
+	.max_register = WM8978_MAX_REGISTER,
+	.volatile_reg = wm8978_volatile,
+
+	.cache_type = REGCACHE_RBTREE,
+	.reg_defaults = wm8978_reg_defaults,
+	.num_reg_defaults = ARRAY_SIZE(wm8978_reg_defaults),
+};
+
+#if 0
+static int wm8978_i2c_probe(struct i2c_client *i2c,
+			    const struct i2c_device_id *id)
+{
+	struct wm8978_priv *wm8978;
+	int ret;
+
+	wm8978 = devm_kzalloc(&i2c->dev, sizeof(struct wm8978_priv),
+			      GFP_KERNEL);
+	if (wm8978 == NULL)
+		return -ENOMEM;
+
+	wm8978->regmap = devm_regmap_init_i2c(i2c, &wm8978_regmap_config);
+	if (IS_ERR(wm8978->regmap)) {
+		ret = PTR_ERR(wm8978->regmap);
+		dev_err(&i2c->dev, "Failed to allocate regmap: %d\n", ret);
+		return ret;
+	}
+
+	i2c_set_clientdata(i2c, wm8978);
+
+	/* Reset the codec */
+	ret = regmap_write(wm8978->regmap, WM8978_RESET, 0);
+	if (ret != 0) {
+		dev_err(&i2c->dev, "Failed to issue reset: %d\n", ret);
+		return ret;
+	}
+
+	ret = devm_snd_soc_register_component(&i2c->dev,
+			&soc_component_dev_wm8978, &wm8978_dai, 1);
+	if (ret != 0) {
+		dev_err(&i2c->dev, "Failed to register CODEC: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static const struct i2c_device_id wm8978_i2c_id[] = {
+	{ "wm8978", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, wm8978_i2c_id);
+
+static const struct of_device_id wm8978_of_match[] = {
+	{ .compatible = "wlf,wm8978", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, wm8978_of_match);
+
+static struct i2c_driver wm8978_i2c_driver = {
+	.driver = {
+		.name = "wm8978",
+		.of_match_table = wm8978_of_match,
+	},
+	.probe =    wm8978_i2c_probe,
+	.id_table = wm8978_i2c_id,
+};
+
+module_i2c_driver(wm8978_i2c_driver);
+#endif
+
+#if defined(CONFIG_SPI_MASTER)
+static int wm8978_spi_probe(struct spi_device *spi)
+{
+	struct wm8978_priv *wm8978;
+	int ret;
+
+	wm8978 = devm_kzalloc(&spi->dev, sizeof(struct wm8978_priv), GFP_KERNEL);
+	if (wm8978 == NULL){
+		pr_warn(KERN_WARNING "error:wm8978_spi_probe():NULL.\n");
+		return -ENOMEM;
+	}
+
+	wm8978->regmap = devm_regmap_init_spi(spi, &wm8978_regmap_config);
+	if (IS_ERR(wm8978->regmap)) {
+		ret = PTR_ERR(wm8978->regmap);
+		dev_err(&spi->dev, "Failed to allocate regmap: %d\n", ret);
+		return ret;
+	}
+
+	spi_set_drvdata(spi, wm8978);
+	
+	/* Reset the codec */
+	ret = regmap_write(wm8978->regmap, WM8978_RESET, 0);
+	if (ret != 0) {
+		dev_err(&spi->dev, "Failed to issue reset: %d\n", ret);
+		return ret;
+	}
+
+	ret = snd_soc_register_component(&spi->dev,&soc_component_dev_wm8978, &wm8978_dai, 1);
+
+	if (ret != 0) {
+		dev_err(&spi->dev, "Failed to register CODEC: %d\n", ret);
+		return ret;
+	}
+
+	return ret;
+}
+
+static int wm8978_spi_remove(struct spi_device *client)
+{
+	snd_soc_unregister_component(&client->dev);
+	return 0;
+}
+
+static const struct spi_device_id wm8978_spi_id[] = {
+	{ "wm8978", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(spi, wm8978_spi_id);
+
+static const struct of_device_id wm8978_of_match[] = {
+	{ .compatible = "wlf,wm8978", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, wm8978_of_match);
+
+static struct spi_driver wm8978_spi_driver = {
+	.driver = {
+		.name	= "wm8978",
+		.of_match_table = wm8978_of_match,
+	},
+	.probe		= wm8978_spi_probe,
+	.remove		= wm8978_spi_remove,
+	.id_table	= wm8978_spi_id,
+};
+
+module_spi_driver(wm8978_spi_driver);
+#endif
+
+MODULE_DESCRIPTION("ASoC WM8978 codec driver");
+MODULE_AUTHOR("Guennadi Liakhovetski <g.liakhovetski@gmx.de>");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/sh/Kconfig b/sound/soc/sh/Kconfig
old mode 100644
new mode 100755
index dc20f0f70..90d31044a
--- a/sound/soc/sh/Kconfig
+++ b/sound/soc/sh/Kconfig
@@ -44,6 +44,18 @@ config SND_SOC_RCAR
 	help
 	  This option enables R-Car SRU/SCU/SSIU/SSI sound support
 
+config SND_SOC_SCUX
+	tristate
+	depends on ARCH_R7S72100
+	select DMA_ENGINE
+	select DMADEVICES
+
+config SND_SOC_RZA2
+	tristate
+	depends on ARCH_R7S9210
+	select DMA_ENGINE
+	select DMADEVICES
+
 ##
 ## Boards
 ##
@@ -65,4 +77,28 @@ config SND_SIU_MIGOR
 	help
 	  This option enables sound support for the SH7722 Migo-R board
 
+config SND_SCUX_RSKRZA1
+	tristate "SCUX sound support on RSK-RZA1"
+	depends on ARCH_R7S72100
+	select SND_SOC_SCUX
+	select SND_SOC_MAX9856
+
+	help
+	  Enable sound support for the RSK-RZA1 board.
+	  This is supported to the Renesas SCUX peripheral.
+	  Say Y here if you have enabled, otherwise say N.
+	  To compile this driver as a module, say M.
+
+config SND_RZA2MEVB
+	tristate "SSI sound support on RZA2MEVB"
+	depends on ARCH_R7S9210
+	select SND_SOC_RZA2
+	select SND_SOC_WM8978_SPI
+
+	help
+	  Enable sound support for the RZA2MEVB board.
+	  This is supported to the SSIF peripheral.
+	  Say Y here if you have enabled, otherwise say N.
+	  To compile this driver as a module, say M.
+
 endmenu
diff --git a/sound/soc/sh/Makefile b/sound/soc/sh/Makefile
old mode 100644
new mode 100755
index 51bd7c816..c6e1324a3
--- a/sound/soc/sh/Makefile
+++ b/sound/soc/sh/Makefile
@@ -8,10 +8,14 @@ snd-soc-hac-objs	:= hac.o
 snd-soc-ssi-objs	:= ssi.o
 snd-soc-fsi-objs	:= fsi.o
 snd-soc-siu-objs	:= siu_pcm.o siu_dai.o
+snd-soc-scux-objs	:= scux_pcm.o scux_dai.o
+snd-soc-rza2-objs	:= rza2_pcm.o rza2_dai.o
 obj-$(CONFIG_SND_SOC_SH4_HAC)	+= snd-soc-hac.o
 obj-$(CONFIG_SND_SOC_SH4_SSI)	+= snd-soc-ssi.o
 obj-$(CONFIG_SND_SOC_SH4_FSI)	+= snd-soc-fsi.o
 obj-$(CONFIG_SND_SOC_SH4_SIU)	+= snd-soc-siu.o
+obj-$(CONFIG_SND_SOC_SCUX)	+= snd-soc-scux.o
+obj-$(CONFIG_SND_SOC_RZA2)	+= snd-soc-rza2.o
 
 ## audio units for R-Car
 obj-$(CONFIG_SND_SOC_RCAR)	+= rcar/
@@ -19,6 +23,10 @@ obj-$(CONFIG_SND_SOC_RCAR)	+= rcar/
 ## boards
 snd-soc-sh7760-ac97-objs	:= sh7760-ac97.o
 snd-soc-migor-objs		:= migor.o
+snd-soc-rskrza1-objs		:= rskrza1.o
+snd-soc-rza2mevb-objs		:= rza2mevb.o
 
 obj-$(CONFIG_SND_SH7760_AC97)	+= snd-soc-sh7760-ac97.o
 obj-$(CONFIG_SND_SIU_MIGOR)	+= snd-soc-migor.o
+obj-$(CONFIG_SND_SCUX_RSKRZA1)	+= snd-soc-rskrza1.o
+obj-$(CONFIG_SND_RZA2MEVB)	+= snd-soc-rza2mevb.o
diff --git a/sound/soc/sh/rza2_dai.c b/sound/soc/sh/rza2_dai.c
new file mode 100755
index 000000000..330359bf4
--- /dev/null
+++ b/sound/soc/sh/rza2_dai.c
@@ -0,0 +1,1534 @@
+/*
+ * sound/soc/sh/scux_dai.c
+ *     This file is ALSA SoC driver for SCUX peripheral.
+ *
+ * Copyright (C) 2013 Renesas Solutions Corp.
+ * Copyright (C) 2013 Renesas Electronics Corporation
+ *
+ * This file is based on the sound/soc/sh/siu_dai.c
+ *
+ * siu_dai.c - ALSA SoC driver for Renesas SH7343, SH7722 SIU peripheral.
+ *
+ * Copyright (C) 2009-2010 Guennadi Liakhovetski <g.liakhovetski@gmx.de>
+ * Copyright (C) 2006 Carlos Munoz <carlos@kenati.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/firmware.h>
+#include <linux/pm_runtime.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/clk.h>
+
+#include <sound/control.h>
+#include <sound/soc.h>
+#include <sound/sh_rza2.h>
+
+#undef DEBUG
+#ifdef DEBUG
+#define FNC_ENTRY	pr_info("entry:%s:%d\n", __func__, __LINE__);
+#define FNC_EXIT	pr_info("exit:%s:%d\n", __func__, __LINE__);
+#define DBG_POINT()	pr_info("check:%s:%d\n", __func__, __LINE__);
+#define DBG_MSG(args...)	pr_info(args)
+#else  /* DEBUG */
+#define FNC_ENTRY
+#define FNC_EXIT
+#define DBG_POINT()
+#define DBG_MSG(args...)
+#endif /* DEBUG */
+
+extern struct snd_soc_component_driver scu_component;
+
+static struct scux_reg_info *scux_reg;
+static spinlock_t *sculock;
+static struct scu_audio_info *ainfo;
+static struct scu_platform_data *pdata;
+
+int32_t getvolume0;
+int32_t getvolume1;
+
+/* DMA slave IDs */
+enum {
+#if 0
+	RZA1DMA_SLAVE_PCM_MEM_SSI0 = 1,	/* DMA0		MEM->(DMA0)->SSI0 */
+	RZA1DMA_SLAVE_PCM_MEM_SRC1,		/* DMA1		MEM->(DMA1)->FFD0_1->SRC1->SSI0 */
+	RZA1DMA_SLAVE_PCM_SSI0_MEM,		/* DMA2		SSI0->(DMA2)->MEM */
+	RZA1DMA_SLAVE_PCM_SRC0_MEM,		/* DMA3		SSI0->SRC0->FFU0_0->(DMA3)->MEM */
+	RZA1DMA_SLAVE_PCM_MAX,
+	RZA1DMA_SLAVE_SDHI0_TX,
+	RZA1DMA_SLAVE_SDHI0_RX,
+	RZA1DMA_SLAVE_SDHI1_TX,
+	RZA1DMA_SLAVE_SDHI1_RX,
+	RZA1DMA_SLAVE_MMCIF_TX,
+	RZA1DMA_SLAVE_MMCIF_RX,
+#else
+	RZADMA_SLAVE_PCM_MEM_SSI0 = 1,	/* DMA0		MEM->(DMA0)->SSI0 */
+	RZADMA_SLAVE_PCM_SSI0_MEM,		/* DMA2		SSI0->(DMA2)->MEM */
+	RZADMA_SLAVE_PCM_MAX,
+	RZADMA_SLAVE_RSPI0_TX,
+	RZADMA_SLAVE_RSPI0_RX,
+#endif
+};
+
+static const struct resource scux_resources[] __initconst = {
+#if 0
+	[0] = DEFINE_RES_MEM_NAMED(0xe8208000, 0x00001778, "scux"),
+	[1] = DEFINE_RES_MEM_NAMED(0xe820b000, 0x00002830, "ssif0"),
+#else
+	[0] = DEFINE_RES_MEM_NAMED(0xe8208000, 0x00001778, "scux"),
+	[1] = DEFINE_RES_MEM_NAMED(0xe8048000, 0x00001828, "ssif0"),
+#endif
+};
+
+static struct scu_config ssi_ch_value[] = {
+	{RP_MEM_SSI0,		SSI0},
+	{RP_MEM_SRC1_SSI0,	SSI0},
+	{RP_MEM_SRC1_DVC1_SSI0,	SSI0},
+	{RC_SSI0_MEM,		SSI0},
+	{RC_SSI0_SRC0_MEM,	SSI0},
+};
+
+static struct scu_config src_ch_value[] = {
+	{RP_MEM_SSI0,		-1},
+	{RP_MEM_SRC1_SSI0,	SRC1},
+	{RP_MEM_SRC1_DVC1_SSI0,	SRC1},
+	{RC_SSI0_MEM,		-1},
+	{RC_SSI0_SRC0_MEM,	SRC0},
+};
+
+static struct scu_config dvc_ch_value[] = {
+	{RP_MEM_SSI0,		-1},
+	{RP_MEM_SRC1_SSI0,	-1},
+	{RP_MEM_SRC1_DVC1_SSI0,	DVC1},
+	{RC_SSI0_MEM,		-1},
+	{RC_SSI0_SRC0_MEM,	-1},
+};
+
+static struct scu_config audma_slave_value[] = {
+#if 0
+	{RP_MEM_SSI0,		RZA1DMA_SLAVE_PCM_MEM_SSI0},
+	{RP_MEM_SRC1_SSI0,	RZA1DMA_SLAVE_PCM_MEM_SRC1},
+	{RP_MEM_SRC1_DVC1_SSI0,	RZA1DMA_SLAVE_PCM_MEM_SRC1},
+	{RC_SSI0_MEM,		RZA1DMA_SLAVE_PCM_SSI0_MEM},
+	{RC_SSI0_SRC0_MEM,	RZA1DMA_SLAVE_PCM_SRC0_MEM},
+#else
+	{RP_MEM_SSI0,		RZADMA_SLAVE_PCM_MEM_SSI0},
+	{RC_SSI0_MEM,		RZADMA_SLAVE_PCM_SSI0_MEM},
+#endif
+};
+
+static struct scu_config ssi_depend_value[] = {
+	{RP_MEM_SSI0,		SSI_INDEPENDANT},
+	{RP_MEM_SRC1_SSI0,	SSI_DEPENDANT},
+	{RP_MEM_SRC1_DVC1_SSI0,	SSI_DEPENDANT},
+	{RC_SSI0_MEM,		SSI_INDEPENDANT},
+	{RC_SSI0_SRC0_MEM,	SSI_DEPENDANT},
+};
+
+static struct scu_config ssi_mode_value[] = {
+	{RP_MEM_SSI0,		SSI_MASTER},
+	{RP_MEM_SRC1_SSI0,	SSI_MASTER},
+	{RP_MEM_SRC1_DVC1_SSI0,	SSI_MASTER},
+	{RC_SSI0_MEM,		SSI_SLAVE},
+	{RC_SSI0_SRC0_MEM,	SSI_SLAVE},
+};
+
+static struct scu_config src_mode_value[] = {
+	{RP_MEM_SSI0,		SRC_CR_ASYNC},
+	{RP_MEM_SRC1_SSI0,	SRC_CR_ASYNC},
+	{RP_MEM_SRC1_DVC1_SSI0,	SRC_CR_ASYNC},
+	{RC_SSI0_MEM,		SRC_CR_ASYNC},
+	{RC_SSI0_SRC0_MEM,	SRC_CR_ASYNC},
+};
+
+static const struct scu_platform_data scu_pdata __initconst = {
+	.ssi_master		= SSI0,
+	.ssi_slave		= SSI0,
+	.ssi_ch			= ssi_ch_value,
+	.ssi_ch_num		= ARRAY_SIZE(ssi_ch_value),
+	.src_ch			= src_ch_value,
+	.src_ch_num		= ARRAY_SIZE(src_ch_value),
+	.dvc_ch			= dvc_ch_value,
+	.dvc_ch_num		= ARRAY_SIZE(dvc_ch_value),
+	.dma_slave_maxnum	= RZADMA_SLAVE_PCM_MAX,
+	.audma_slave		= audma_slave_value,
+	.audma_slave_num	= ARRAY_SIZE(audma_slave_value),
+	.ssi_depend		= ssi_depend_value,
+	.ssi_depend_num		= ARRAY_SIZE(ssi_depend_value),
+	.ssi_mode		= ssi_mode_value,
+	.ssi_mode_num		= ARRAY_SIZE(ssi_mode_value),
+	.src_mode		= src_mode_value,
+	.src_mode_num		= ARRAY_SIZE(src_mode_value),
+};
+
+static const struct platform_device_info scux_info __initconst = {
+	.name		= "rza2-pcm-audio",
+	.id		= 0,
+	.data		= &scu_pdata,
+	.size_data	= sizeof(scu_pdata),
+	.num_res	= ARRAY_SIZE(scux_resources),
+	.res		= scux_resources,
+};
+
+static const struct of_device_id rza2_of_match[] = {
+	{ .compatible = "renesas,rza2mevb" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, rza2_of_match);
+
+struct scu_route_info *scu_get_route_info(void)
+{
+	return &ainfo->routeinfo;
+}
+EXPORT_SYMBOL(scu_get_route_info);
+
+struct scu_platform_data *scu_get_platform_data(void)
+{
+	return pdata;
+}
+EXPORT_SYMBOL(scu_get_platform_data);
+
+/************************************************************************
+	peripheral function
+************************************************************************/
+static void scu_ssif_softreset(int ch)
+{
+#if 0
+	u8 reg;
+
+	u32 __iomem *addr = ioremap(SWRSTCR1, 4);
+
+	switch (ch) {
+	case 0:
+		writeb(SWRSTCR1_SRST16, addr);
+		break;
+	case 1:
+		writeb(SWRSTCR1_SRST15, (u32 *)SWRSTCR1); /* Soft Reset SSIF1 */
+		break;
+	case 2:
+		writeb(SWRSTCR1_SRST14, (u32 *)SWRSTCR1); /* Soft Reset SSIF2 */
+		break;
+	case 3:
+		writeb(SWRSTCR1_SRST13, (u32 *)SWRSTCR1); /* Soft Reset SSIF3 */
+		break;
+	case 4:
+		writeb(SWRSTCR1_SRST12, (u32 *)SWRSTCR1); /* Soft Reset SSIF4 */
+		break;
+	case 5:
+		writeb(SWRSTCR1_SRST11, (u32 *)SWRSTCR1); /* Soft Reset SSIF5 */
+		break;
+	}
+	udelay(10);
+	writeb(SWRSTCR1_INIT, addr);
+	udelay(10);
+	reg = readb(addr);
+#else
+	u32 reg;
+
+	switch (ch) {
+	case 0:
+		reg = readl(&scux_reg->ssifreg[0]->ssifcr);
+		reg |= SSIFCR_SSIRST;
+		writel(reg, &scux_reg->ssifreg[0]->ssifcr);
+		udelay(10);
+		reg &= ~SSIFCR_SSIRST;
+		writel(reg, &scux_reg->ssifreg[0]->ssifcr);
+		udelay(10);
+		break;
+	case 1:
+		reg = readl(&scux_reg->ssifreg[1]->ssifcr);
+		reg |= SSIFCR_SSIRST;
+		writel(reg, &scux_reg->ssifreg[1]->ssifcr);
+		udelay(10);
+		reg &= ~SSIFCR_SSIRST;
+		writel(reg, &scux_reg->ssifreg[1]->ssifcr);
+		udelay(10);
+		break;
+	case 2:
+		reg = readl(&scux_reg->ssifreg[2]->ssifcr);
+		reg |= SSIFCR_SSIRST;
+		writel(reg, &scux_reg->ssifreg[2]->ssifcr);
+		udelay(10);
+		reg &= ~SSIFCR_SSIRST;
+		writel(reg, &scux_reg->ssifreg[2]->ssifcr);
+		udelay(10);
+		break;
+	case 3:
+		reg = readl(&scux_reg->ssifreg[3]->ssifcr);
+		reg |= SSIFCR_SSIRST;
+		writel(reg, &scux_reg->ssifreg[3]->ssifcr);
+		udelay(10);
+		reg &= ~SSIFCR_SSIRST;
+		writel(reg, &scux_reg->ssifreg[3]->ssifcr);
+		udelay(10);
+		break;
+	}
+
+#endif // 0
+}
+
+static void scu_ssif_init(void)
+{
+	FNC_ENTRY
+
+	/* SSI TDM Mode Register Setting */
+	writel(SSI_SSITDMR_BASE_INIT_VALUE, &scux_reg->ssifreg[0]->ssitdmr);
+	/* SSI Control register setting */
+	writel(SSI_SSICR_BASE_INIT_VALUE, &scux_reg->ssifreg[0]->ssicr);
+	/* SSI FIFO Control register setting */
+	writel(SSI_SSIFCR_BASE_INIT_VALUE, &scux_reg->ssifreg[0]->ssifcr);
+	/* SSI Status register clear */
+	writel(0, &scux_reg->ssifreg[0]->ssisr);
+
+	FNC_EXIT
+	return;
+}
+
+static void scu_ssi_control(int master_ch, int slave_ch, int mode)
+{
+	FNC_ENTRY
+	/* SSI setting */
+	if ((readl(&scux_reg->ssifreg[master_ch]->ssicr) & SSICR_ENABLE) == 0) {
+		writel(SSICR_PLAY_WM8978_ST,
+			&scux_reg->ssifreg[master_ch]->ssicr);
+		writel(SSITDMR_CONT_EN, &scux_reg->ssifreg[master_ch]->ssitdmr);
+	}
+	if ((mode == SSI_SLAVE) &&
+	    ((readl(&scux_reg->ssifreg[slave_ch]->ssicr) & SSICR_ENABLE) == 0))
+		writel(SSICR_CAP_WM8978_ST,
+			&scux_reg->ssifreg[slave_ch]->ssicr);
+
+	FNC_EXIT
+	return;
+}
+
+static void scu_ssi_start(int ssi_ch, int ssi_dir)
+{
+	u32 val;
+
+	FNC_ENTRY
+
+	if (ssi_dir == SSI_OUT) {
+		/* SSI enable (figure.39.12 flow) */
+		val = readl(&scux_reg->ssifreg[ssi_ch]->ssicr);
+		val |= (SSICR_TUIEN | SSICR_TOIEN);
+		val &= ~(SSICR_IIEN);
+		writel(val, &scux_reg->ssifreg[ssi_ch]->ssicr);
+
+		val = (SSIFCR_AUCKE | SSIFCR_TIE | SSIFCR_RFRST);
+		writel(val, &scux_reg->ssifreg[ssi_ch]->ssifcr);
+
+		val = readl(&scux_reg->ssifreg[ssi_ch]->ssicr);
+		val |= SSICR_TEN_EN;
+		writel(val, &scux_reg->ssifreg[ssi_ch]->ssicr);
+	} else { /* ssi_dir == SSI_IN */
+		/* SSI enable (figure.39.14 flow) */
+		val = readl(&scux_reg->ssifreg[ssi_ch]->ssicr);
+		val |= (SSICR_RUIEN | SSICR_ROIEN);
+		writel(val, &scux_reg->ssifreg[ssi_ch]->ssicr);
+
+		val = (SSIFCR_AUCKE | SSIFCR_RIE | SSIFCR_TFRST);
+		writel(val, &scux_reg->ssifreg[ssi_ch]->ssifcr);
+
+		val = readl(&scux_reg->ssifreg[ssi_ch]->ssicr);
+		val |= SSICR_REN_EN;
+		writel(val, &scux_reg->ssifreg[ssi_ch]->ssicr);
+	}
+
+	FNC_EXIT
+	return;
+}
+
+static void scu_ssi_stop(int ssi_ch, int ssi_dir)
+{
+	u32 val;
+	int tmout;
+
+	FNC_ENTRY
+
+	if (ssi_dir == SSI_OUT) {
+		/* SSI disable (figure.39.13 flow) */
+		val = readl(&scux_reg->ssifreg[ssi_ch]->ssicr);
+		val &= ~(SSICR_TUIEN | SSICR_TOIEN | SSICR_TEN_EN);
+		writel(val, &scux_reg->ssifreg[ssi_ch]->ssicr);
+
+		val = SSI_SSIFCR_BASE_INIT_VALUE;
+		writel(val, &scux_reg->ssifreg[ssi_ch]->ssifcr);
+
+		tmout = 1000;
+		while (--tmout &&
+		       !(readl(&scux_reg->ssifreg[ssi_ch]->ssisr) & SSISR_IIRQ))
+			udelay(1);
+//		if (!tmout)
+//			tmout = 1000;
+//		while (--tmout &&
+//		       !(readl(&scux_reg->ssifreg[ssi_ch]->ssisr) & SSISR_IDST))
+//			udelay(1);
+		if (!tmout)
+			pr_info("timeout waiting for SSI idle\n");
+
+	} else { /* ssi_dir == SSI_IN */
+		/* SSI disable (figure.39.15 flow) */
+		val = readl(&scux_reg->ssifreg[ssi_ch]->ssicr);
+		val &= ~(SSICR_RUIEN | SSICR_ROIEN | SSICR_REN_EN);
+		writel(val, &scux_reg->ssifreg[ssi_ch]->ssicr);
+
+		val = SSI_SSIFCR_BASE_INIT_VALUE;
+		writel(val, &scux_reg->ssifreg[ssi_ch]->ssifcr);
+
+		tmout = 1000;
+		while (--tmout &&
+//		       !(readl(&scux_reg->ssifreg[ssi_ch]->ssisr) & SSISR_IDST))
+		       !(readl(&scux_reg->ssifreg[ssi_ch]->ssisr) & SSISR_IIRQ))
+			udelay(1);
+		if (!tmout)
+			pr_info("timeout waiting for SSI idle\n");
+	}
+
+	FNC_EXIT
+}
+
+static void scu_src_control(int src_ch, unsigned int rate, unsigned int sync_sw)
+{
+	u32 reg, futsel;
+
+	FNC_ENTRY
+
+	/* SRC0 is capture,SRC1 is playback */
+	/* Return to prohibit the enable register of sending and receiving */
+	reg = readl(&scux_reg->ssifreg[0]->ssicr);
+	reg &= ~(SSICR_TEN_EN | SSICR_REN_EN);
+	writel(reg, &scux_reg->ssifreg[0]->ssicr);
+
+#if 0
+	/* 1.SCUX RESET:when DVU is already reset from scu_init_dvc() */
+	if (ainfo->routeinfo.p_route != RP_MEM_SRC1_DVC1_SSI0) {
+		writel(SWRSR_SWRST_RST, &scux_reg->cimreg->swrsr);
+		udelay(10);
+		writel(SWRSR_SWRST_OPE, &scux_reg->cimreg->swrsr);
+		udelay(10);
+	}
+#endif // 0
+	/* Capture route */
+	if (src_ch == SRC0) {
+#if 0
+		/* 2.Setting the transfer route */
+		/* FFD and FFU route Setting */
+		writel(FFDPR_NO_PASS_SELECT, &scux_reg->ffdreg[src_ch]->ffdpr);
+		writel(FFUPR_CIM_FFU_OPC_ASYNC,
+			&scux_reg->ffureg[src_ch]->ffupr);
+
+		/* IPC and OPC route Setting */
+		writel(IPSLR_SSIF_IPC_ASYNC, &scux_reg->ipcreg[src_ch]->ipslr);
+		writel(OPSLR_ASYNC_OPC_FFU, &scux_reg->opcreg[src_ch]->opslr);
+
+		/* SSIF route choice */
+		reg = readl(&scux_reg->cimreg->ssirsel_cim);
+		reg &= SSIRSEL_SISEL0_USE_SSIF0;
+		writel(reg, &scux_reg->cimreg->ssirsel_cim);
+
+		/* SRCRSELn_CIM (n=0,1,2,3), MIXRSEL_CIM */
+		/* NO SETTING */
+
+		/* SSICTRL_CIM is Direct send setting */
+		reg = readl((u32 *)&scux_reg->cimreg->ssictrl_cim);
+		reg |= SSICTRL_SSI0RX_EN;
+		writel(reg, &scux_reg->cimreg->ssictrl_cim);
+
+		/* 3.Setting of timing */
+		/* FUTSELn_CIM SCKDIV setting ,AUDIO_X1(22579200Hz) / Fout */
+		reg = AUDIO_X1 / rate;
+		if (reg > SCKDIV_MAX)
+			reg = SCKDIV_MAX;
+
+		/* FFU0_0 : setting clock */
+		reg = (reg << 16);
+		reg |= FUTSEL_SCKSEL_AUIDIO_X1;
+		writel(reg, &scux_reg->cimreg->futsel0_cim);
+		futsel = reg;
+
+		/* FFD0_1 */
+		/* NO Setting */
+
+		/* 4.SSIF setting pin */
+		/* SSIPMD_CIM SSIF pinmode setting */
+		writel(SSIPMD_SSI0CKS, &scux_reg->cimreg->ssipmd_cim);
+
+		/* 5.FFD0_1 */
+		/* NO SETTING */
+
+		/* 6.FFU0_1 */
+		writel(FUAIR_AUDIO_CH_2, &scux_reg->ffureg[src_ch]->fuair);
+		writel(URQSR_CH0CH1_REQ_SIZE_256,
+			&scux_reg->ffureg[src_ch]->urqsr);
+		writel(UEVMR_VALUE, &scux_reg->ffureg[src_ch]->uevmr);
+
+		/* 7.SRCn */
+		writel(SRCBR_BYPASS_OFF, &scux_reg->srcreg[0]->srcbr0);
+		writel((SADIR_OTBL_16BIT | SADIR_AUDIO_CH_2),
+			&scux_reg->srcreg[0]->sadir0);
+
+		/* IFSCRp_2SRC0_m is used setting INTIFS */
+		writel(IFSCR_VALUE, &scux_reg->srcreg[0]->ifscr0);
+
+		/* IFSVRp_2SRC0_m is setting INTIFS */
+		switch (rate) {
+		case SRC_IFS_8KHZ:
+			reg = INTIFS_IN44K_OUT8K;
+			break;
+		case SRC_IFS_11KHZ:
+			reg = INTIFS_IN44K_OUT11K;
+			break;
+		case SRC_IFS_12KHZ:
+			reg = INTIFS_IN44K_OUT12K;
+			break;
+		case SRC_IFS_16KHZ:
+			reg = INTIFS_IN44K_OUT16K;
+			break;
+		case SRC_IFS_22KHZ:
+			reg = INTIFS_IN44K_OUT22K;
+			break;
+		case SRC_IFS_24KHZ:
+			reg = INTIFS_IN44K_OUT24K;
+			break;
+		case SRC_IFS_32KHZ:
+			reg = INTIFS_IN44K_OUT32K;
+			break;
+		default:
+		case SRC_IFS_44KHZ:
+			reg = INTIFS_IN44K_OUT44K;
+			break;
+		case SRC_IFS_48KHZ:
+			reg = INTIFS_IN44K_OUT48K;
+			break;
+		}
+		writel(reg, &scux_reg->srcreg[0]->ifsvr0);
+		writel((SRC_CR_BIT16 | SRC_CR_BIT8 | SRC_CR_BIT4),
+			&scux_reg->srcreg[0]->srccr0);
+		/* MNFSRp_2SRC0_m is setting minimum of FS */
+		/* MINFS = INITFS * 90% */
+		reg = reg * MIN_FS_RATIO_90 / MIN_FS_RATIO_100;
+		writel(reg, &scux_reg->srcreg[0]->mnfsr0);
+
+		/* BFSSRp_2SRC0_m NO Setting*/
+		/* WATSRp_2SRC0_m NO Setting */
+		/* SEVMRp_2SRC0_m NO Setting when transfer start*/
+
+		/* 8.DVUn */
+		/* DVU BYPASS setting */
+		/* NO SETTING */
+
+		/* 9.MIX */
+		/* MIX BYPASS setting */
+		/* NO SETTING */
+
+		/* DMA transfer setting */
+		reg = readl(&scux_reg->cimreg->dmacr_cim);
+		reg |= DMACR_DMAMDFFU0_EN;
+		writel(reg, &scux_reg->cimreg->dmacr_cim);
+
+		/* FFD Init off */
+		writel(FFDIR_INIT_OFF, &scux_reg->ffdreg[src_ch]->ffdir);
+
+		/* FFD BOOT */
+		writel(FFDBR_HALT_ON, &scux_reg->ffdreg[src_ch]->ffdbr);
+
+		/* FFU,SRC,IPC,OPC Init off */
+		writel(INIT_OFF, &scux_reg->ffureg[src_ch]->ffuir);
+		writel(INIT_OFF, &scux_reg->srcreg[0]->srcir0);
+		writel(INIT_OFF, &scux_reg->srcreg[0]->srcirr1);
+		writel(INIT_OFF, &scux_reg->ipcreg[src_ch]->ipcir);
+		writel(INIT_OFF, &scux_reg->opcreg[src_ch]->opcir);
+#endif // 0
+		/* Send start setting */
+		reg = readl(&scux_reg->ssifreg[0]->ssicr);
+		reg |= SSICR_REN_EN;
+		writel(reg, &scux_reg->ssifreg[0]->ssicr);
+		futsel |= FUTSEL_DIVEN_START;
+#if 0
+		writel(futsel, &scux_reg->cimreg->futsel0_cim);
+#endif // 0
+	} else if (src_ch == SRC1) {
+#if 0
+		reg = readl(&scux_reg->cimreg->ssirsel_cim);
+		reg |= SSIRSEL_SOSEL0_USE_SRC1;
+		/* 0xE8209738:SSIRSEL_CIM  SOSEL0 = 01b */
+		writel(reg, &scux_reg->cimreg->ssirsel_cim);
+		/* 0xE8208104:IPSLR_IPC0_n  IPC_PASS_SEL = 011b */
+		writel(IPSLR_FFD_IPC_ASYNC, &scux_reg->ipcreg[src_ch]->ipslr);
+		/* 0xE8208504:OPSLR_OPC0_n  OPC_PASS_SEL = 001b	 */
+		writel(OPSLR_ASYNC_OPC_DVU, &scux_reg->opcreg[src_ch]->opslr);
+		/* 0xE820890C:FFDPR_FFD0_n  PASS = 01b */
+		writel(FFDPR_CIM_FFD_IPC_ASYNC,
+			&scux_reg->ffdreg[src_ch]->ffdpr);
+		/* 0xE8208D0C:FFUPR_FFU0_n  PASS = 00b */
+		writel(FFUPR_NO_PASS_SELECT, &scux_reg->ffureg[src_ch]->ffupr);
+		/* 0xE820975C:SSIPMD_CIM    SSI345EN = 0, SSI012EN = 0 */
+		writel(THIS_CH_NOT_USED, &scux_reg->cimreg->ssipmd_cim);
+
+		/* SSICTRL_CIM is Direct send setting */
+		reg = readl((u32 *)&scux_reg->cimreg->ssictrl_cim);
+		/* SSICTRL_CIM  SSI3RX = 0, SSI3TX = 0	: value = 0xBBFFFFFF */
+		reg &= ~(SSICTRL_SSI3TX_EN | SSICTRL_SSI3RX_EN);
+		/* SSICTRL_CIM  SSI0TX = 1		: value = 0x00004000 */
+		reg |= SSICTRL_SSI0TX_EN;
+		/* 0xE8209760 : SSI0TX = 1 */
+		writel(reg, &scux_reg->cimreg->ssictrl_cim);
+
+		/* FDTSELn_CIM SCKDIV setting */
+		/* FDTSELn_CIM    SCKDIV = AUDIO_X1(22579200Hz) / Fin  */
+		/* FDTSELn_CIM SCKSEL = 0001b(AUDIO_X1) */
+		/* MNFSRp_2SRC0_m MINFS  = (2^22 * Fin / Fout) * 90% */
+		/* IFSVRp_2SRC0_m INTIFS = 2^22 * Fin / Fout  */
+		/* Fin = Input Rate, Fout = Output Rate(44100Hz) */
+		reg = AUDIO_X1 / rate;			/* FDTSELn_CIM SCKDIV */
+		if (reg > SCKDIV_MAX)
+			reg = SCKDIV_MAX;
+		reg = (reg << 16);
+		reg |= FDTSEL_SCKSEL_AUIDIO_X1;
+		writel(reg, &scux_reg->cimreg->fdtsel1_cim);
+
+		/* IFSVRp_2SRC0_m  INTIFS */
+		switch (rate) {
+		case SRC_IFS_8KHZ:
+			reg = INTIFS_IN8K_OUT44K;
+			break;
+		case SRC_IFS_11KHZ:
+			reg = INTIFS_IN11K_OUT44K;
+			break;
+		case SRC_IFS_12KHZ:
+			reg = INTIFS_IN12K_OUT44K;
+			break;
+		case SRC_IFS_16KHZ:
+			reg = INTIFS_IN16K_OUT44K;
+			break;
+		case SRC_IFS_22KHZ:
+			reg = INTIFS_IN22K_OUT44K;
+			break;
+		case SRC_IFS_24KHZ:
+			reg = INTIFS_IN24K_OUT44K;
+			break;
+		case SRC_IFS_32KHZ:
+			reg = INTIFS_IN32K_OUT44K;
+			break;
+		default:
+		case SRC_IFS_44KHZ:
+			reg = INTIFS_IN44K_OUT44K;
+			break;
+		case SRC_IFS_48KHZ:
+			reg = INTIFS_IN48K_OUT44K;
+			break;
+		}
+		writel(reg, &scux_reg->srcreg[0]->ifsvr1);
+		/* MNFSRp_2SRC0_m is setting minimum of FS */
+		/* MINFS = INITFS * 90% */
+		reg = reg * MIN_FS_RATIO_90 / MIN_FS_RATIO_100;
+		writel(reg, &scux_reg->srcreg[0]->mnfsr1);
+		writel(IFSCR_VALUE, &scux_reg->srcreg[0]->ifscr1);
+		/* FUTSELn_CIM NO Setting  */
+		/* FFD Setting */
+		/* 0xE8208904:FDAIR_FFD0_n CHNUM = 0010b(2 channel) */
+		writel(FDAIR_AUDIO_CH_2, &scux_reg->ffdreg[src_ch]->fdair);
+		/* 0xE8208908:DRQSR_FFD0_n SIZE = 0001b(256 data) */
+		writel(DRQSR_REQ_SIZE_256, &scux_reg->ffdreg[src_ch]->drqsr);
+		/* 0xE8208914:DEVMR_FFD0_n DEVMUF = 1, DEVMOF = 1, DEVMOL = 1,
+			      DEVMIUF = 1, DEVMRQ = 0 */
+		writel(DEVMR_VALUE, &scux_reg->ffdreg[src_ch]->devmr);
+
+		/* SRC Setting */
+		/* 0xE820903C:SRCBRp_2SRC0_m  BYPASS = 0 */
+		writel(SRCBR_BYPASS_OFF, &scux_reg->srcreg[0]->srcbr1);
+		/* 0xE8209038:SADIRp_2SRC0_m  OTBL = 01000(16 bit),
+					      CHNUM = 0010(2 channel) */
+		writel((SADIR_OTBL_16BIT | SADIR_AUDIO_CH_2),
+			&scux_reg->srcreg[0]->sadir1);
+		/* 0xE8209048:SRCCRp_2SRC0_m */
+		writel((SRC_CR_BIT16 | SRC_CR_BIT8 | SRC_CR_BIT4),
+			&scux_reg->srcreg[0]->srccr1);
+		/* BFSSRp_2SRC0_m NO Setting*/
+		/* WATSRp_2SRC0_m NO Setting */
+		/* SEVMRp_2SRC0_m NO Setting */
+
+		/* DVU Setting */
+		/* 0xE8209304:VADIR_DVU0_n  OTBL = 01000b(16 bit),
+					    CHNUM = 0010b(2 channel) */
+		writel((VADIR_OTBL_16BIT | VADIR_CHNUM_CH_2),
+			&scux_reg->dvureg[1]->vadir);
+		/* DVU BYPASS setting */
+		/* 0xE8209308:DVUBR_DVU0_n  BYPASS = 1 */
+		if (ainfo->routeinfo.p_route != RP_MEM_SRC1_DVC1_SSI0)
+			writel(DVUBR_BYPASS_ON, &scux_reg->dvureg[1]->dvubr);
+
+		/* MIX BYPASS setting */
+		/* 0xE8209608:MIXBR_MIX0_0  BPSYS 01b(Input Data of system B),
+			      BYPASS = 1 */
+		writel(MIXBR_BYPASS_ON, &scux_reg->mixreg->mdber);
+
+		/* DMA transfer setting */
+		reg = readl(&scux_reg->cimreg->dmacr_cim);
+		/* 0xE8209704:DMACR_CIM  DMAMDFFD1 = 1 */
+		reg |= DMACR_DMAMDFFD1_EN;
+		writel(reg, &scux_reg->cimreg->dmacr_cim);
+
+		/* FFD Init off */
+		/* 0xE8208900:FFDIR_FFD0_n  INIT = 0 */
+		writel(FFDIR_INIT_OFF, &scux_reg->ffdreg[src_ch]->ffdir);
+
+		/* FFD BOOT */
+		/* 0xE8208910:FFDBR_FFD0_n  BOOT = 1 */
+		writel(FFDBR_BOOT_ON, &scux_reg->ffdreg[src_ch]->ffdbr);
+
+		/* SRC,DVU,MIX,IPC,OPC Init off */
+		/* 0xE8208D00:FFUIR_FFU0_n  INIT = 0 */
+		writel(INIT_OFF, &scux_reg->ffureg[src_ch]->ffuir);
+		/* 0xE8209034:SRCIRp_2SRC0_m  INIT = 0 */
+		writel(INIT_OFF, &scux_reg->srcreg[0]->srcir1);
+		/* 0xE8209068:SRCIRR_2SRC0_m  INIT = 0 */
+		writel(INIT_OFF, &scux_reg->srcreg[0]->srcirr1);
+		/* 0xE8209300:DVUIR_DVU0_n  INIT = 0 */
+		writel(INIT_OFF, &scux_reg->dvureg[1]->dvuir);
+		/* 0xE8209600:MIXIR_MIX0_0  INIT = 0 */
+		writel(INIT_OFF, &scux_reg->mixreg->mixir);
+		/* 0xE8208100:IPCIR_IPC0_n  INIT = 0 */
+		writel(INIT_OFF, &scux_reg->ipcreg[src_ch]->ipcir);
+		/* 0xE8208500:OPCIR_OPC0_n  INIT = 0 */
+		writel(INIT_OFF, &scux_reg->opcreg[src_ch]->opcir);
+		/* Send start setting */
+		reg = readl(&scux_reg->cimreg->fdtsel1_cim);
+		reg |= SCUX_FDTSEL_BIT_DIVEN;
+		/* 0xE8209740:FDTSELn_CIM  DIVEN = 1 */
+		writel(reg, &scux_reg->cimreg->fdtsel1_cim);
+#endif // 0
+		reg = readl(&scux_reg->ssifreg[0]->ssicr);
+		reg |= SSICR_TEN_EN;
+		writel(reg, &scux_reg->ssifreg[0]->ssicr);
+
+	} else
+		pr_info("error SRC CH:%d\n", src_ch);
+	FNC_EXIT
+	return;
+}
+
+static void scu_dvc_deinit(int dvc_ch)
+{
+	FNC_ENTRY
+#if 0
+	/* DVUIR : DVU init on */
+	/* 0xE8209300:DVUIR_INIT_ON  */
+	writel(DVUIR_INIT_ON, &scux_reg->dvureg[1]->dvuir);
+#endif // 0
+	FNC_EXIT
+	return;
+}
+
+void scu_dvc_control(int dvc_ch)
+{
+	FNC_ENTRY
+#if 0
+	/*  DVU_ADINR */
+	/* only stereo now */
+	/* DVU0_1 VADIR :0xE8209304  */
+	writel((VADIR_OTBL_16BIT | VADIR_CHNUM_CH_2),
+		(u32 *)&scux_reg->dvureg[dvc_ch]->vadir);
+
+	/*  DVU_DVUCR  DVU mode select */
+	/* DVU0_1 DVUCR :0xE820930C  */
+	writel((DVUCR_VVMD_USE | DVUCR_VRMD_USE),
+		(u32 *)&scux_reg->dvureg[dvc_ch]->dvucr);
+	/*  DVU_VRCTR volume ramp action setting */
+	/* DVU0_1 VRCTR : 0xE8209314 */
+	writel((VRCTR_VREN0_EN | VRCTR_VREN1_EN),
+		(u32 *)&scux_reg->dvureg[dvc_ch]->vrctr);
+
+	/* VRPDR volume ramp time setting */
+	/* DVU0_1 VRPDR : 0xE8209318 */	/* SCUX_VRPDR_BIT_VRPDUP */
+	writel((VRPDR_VRPDUP_PERIOD_1 | VRPDR_VRPDDW_PERIOD_1),
+		(u32 *)&scux_reg->dvureg[dvc_ch]->vrpdr);
+
+	/* volume ramp gain level setting */
+	/* DVU0_1 VRDBR : 0xE820931C */
+	writel(VRDBR_VRDB_0DB, (u32 *)&scux_reg->dvureg[dvc_ch]->vrdbr);
+
+	/* Digital Volume Function Parameter */
+	/* DVU0_1 VOL0R : 0xE8209324 */
+	writel(getvolume0, (u32 *)&scux_reg->dvureg[dvc_ch]->vol0r);
+	/* DVU0_1 VOL1R : 0xE8209328 */
+	writel(getvolume1, (u32 *)&scux_reg->dvureg[dvc_ch]->vol1r);
+
+	/* Zero Cross Mute Function */
+	/* DVU0_1 ZCMCR : 0xE8209310 */
+	writel(0, (u32 *)&scux_reg->dvureg[dvc_ch]->zcmcr);
+
+	/* VRWTR volume ramp wait time setting */
+	/* DVU0_1 VRWTR : 0xE8209320 */
+	writel(0, (u32 *)&scux_reg->dvureg[dvc_ch]->vrwtr);
+
+	/* vevmr SCUDVIn request intrrupt enable/disable setting */
+	/* DVU0_1 VERVMR : 0xE820934C */
+	writel(0, (u32 *)&scux_reg->dvureg[dvc_ch]->vevmr);
+
+	/* DVUER */
+	/* DVU0_1 DVUER : 0xE8209344 */
+	writel(DVUER_DVUEN_EN, (u32 *)&scux_reg->dvureg[dvc_ch]->dvuer);
+#endif // 0
+	FNC_EXIT
+	return;
+}
+
+static void scu_dvc_stop(int dvc_ch)
+{
+	FNC_ENTRY
+#if 0
+	/* DVU_DVUER */
+	writel(0, (u32 *)&scux_reg->dvureg[dvc_ch]->dvuer);
+#endif // 0
+	FNC_EXIT
+	return;
+}
+
+/************************************************************************
+
+	DAPM callback function
+
+************************************************************************/
+void scu_init_ssi(int master_ch, int slave_ch, int mode, int ind, int dir)
+{
+	int ch = (mode == SSI_MASTER) ? master_ch : slave_ch;
+
+	scu_ssif_softreset(ch);
+
+	/* SSI init */
+	scu_ssi_control(master_ch, slave_ch, mode);
+
+	/* SSI start */
+	scu_ssi_start(ch, dir);
+}
+EXPORT_SYMBOL(scu_init_ssi);
+
+void scu_deinit_ssi(int ch, int mode, int ind, int dir)
+{
+	/* SSI stop */
+	scu_ssi_stop(ch, dir);
+
+}
+EXPORT_SYMBOL(scu_deinit_ssi);
+
+void scu_init_src(int src_ch, unsigned int rate, unsigned int sync_sw)
+{
+	scu_src_control(src_ch, rate, sync_sw);
+}
+EXPORT_SYMBOL(scu_init_src);
+
+void scu_deinit_src(int src_ch)
+{
+#if 0
+	/* SCUX reset */
+	/* 0xE8209700:SWRSR_CIM SWRST = 0 */
+	writel(SWRSR_SWRST_RST, &scux_reg->cimreg->swrsr);
+	udelay(10);
+	/* 0xE8209700:SWRSR_CIM SWRST = 1 */
+	writel(SWRSR_SWRST_OPE, &scux_reg->cimreg->swrsr);
+	udelay(10);
+#endif // 0
+}
+EXPORT_SYMBOL(scu_deinit_src);
+
+void scu_init_dvc(int dvc_ch)
+{
+#if 0
+	/* SCUX reset */
+	/* 0xE8209700:SWRSR_CIM SWRST = 0 */
+	writel(SWRSR_SWRST_RST, &scux_reg->cimreg->swrsr);
+	udelay(10);
+	/* 0xE8209700:SWRSR_CIM SWRST = 1 */
+	writel(SWRSR_SWRST_OPE, &scux_reg->cimreg->swrsr);
+	udelay(10);
+#endif // 0
+	scu_dvc_control(dvc_ch);
+}
+EXPORT_SYMBOL(scu_init_dvc);
+
+void scu_deinit_dvc(int dvc_ch)
+{
+	/* stop dvu */
+	scu_dvc_stop(dvc_ch);
+	scu_dvc_deinit(dvc_ch);
+}
+EXPORT_SYMBOL(scu_deinit_dvc);
+
+/************************************************************************
+
+	dai ops
+
+************************************************************************/
+/* Playback and capture hardware properties are identical */
+static const struct snd_pcm_hardware scu_dai_pcm_hw = {
+	.info			= (SNDRV_PCM_INFO_INTERLEAVED	|
+				   SNDRV_PCM_INFO_MMAP		|
+				   SNDRV_PCM_INFO_MMAP_VALID	|
+				   SNDRV_PCM_INFO_PAUSE),
+	.formats		= SNDRV_PCM_FMTBIT_S16_LE,
+	.rates			= SNDRV_PCM_RATE_8000_48000,
+	.rate_min		= 8000,
+	.rate_max		= 48000,
+	.channels_min		= 2,
+	.channels_max		= 2,
+	.buffer_bytes_max	= SCU_BUFFER_BYTES_MAX,
+	.period_bytes_min	= SCU_PERIOD_BYTES_MIN,
+	.period_bytes_max	= SCU_PERIOD_BYTES_MAX,
+	.periods_min		= SCU_PERIODS_MIN,
+	.periods_max		= SCU_PERIODS_MAX,
+};
+
+static int scu_dai_info_rate(struct snd_kcontrol *kctrl,
+				struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = RATE_MAX;
+
+	return 0;
+}
+
+static int scu_dai_get_rate(struct snd_kcontrol *kctrl,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct scu_audio_info *ainfo = snd_kcontrol_chip(kctrl);
+
+	switch (kctrl->private_value) {
+	case CTRL_PLAYBACK:
+		ucontrol->value.integer.value[0] = ainfo->rate[0];
+		break;
+	case CTRL_CAPTURE:
+		ucontrol->value.integer.value[0] = ainfo->rate[1];
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int scu_dai_put_rate(struct snd_kcontrol *kctrl,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct scu_audio_info *ainfo = snd_kcontrol_chip(kctrl);
+	int change = 0;
+
+	switch (kctrl->private_value) {
+	case CTRL_PLAYBACK:
+		change |= (ainfo->rate[0] != ucontrol->value.integer.value[0]);
+		if (change)
+			ainfo->rate[0] = ucontrol->value.integer.value[0];
+		break;
+	case CTRL_CAPTURE:
+		change |= (ainfo->rate[1] != ucontrol->value.integer.value[0]);
+		if (change)
+			ainfo->rate[1] = ucontrol->value.integer.value[0];
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return change;
+}
+
+static const struct snd_kcontrol_new playback_rate_controls = {
+	.iface		= SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name		= "PCM Playback Sampling Rate",
+	.index		= 0,
+	.info		= scu_dai_info_rate,
+	.get		= scu_dai_get_rate,
+	.put		= scu_dai_put_rate,
+	.private_value	= CTRL_PLAYBACK,
+};
+
+static const struct snd_kcontrol_new capture_rate_controls = {
+	.iface		= SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name		= "PCM Capture Sampling Rate",
+	.index		= 0,
+	.info		= scu_dai_info_rate,
+	.get		= scu_dai_get_rate,
+	.put		= scu_dai_put_rate,
+	.private_value	= CTRL_CAPTURE,
+};
+
+static int scu_dai_info_volume(struct snd_kcontrol *kctrl,
+				struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 2;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = VOLUME_MAX_DVC;
+
+	return 0;
+}
+
+static int scu_dai_get_volume(struct snd_kcontrol *kctrl,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct scu_audio_info *ainfo = snd_kcontrol_chip(kctrl);
+
+	switch (kctrl->private_value) {
+	case CTRL_PLAYBACK:
+		ucontrol->value.integer.value[0] = ainfo->volume[0][0];
+		ucontrol->value.integer.value[1] = ainfo->volume[0][1];
+		/* save volume */
+		getvolume0 = ucontrol->value.integer.value[0];
+		getvolume1 = ucontrol->value.integer.value[1];
+		break;
+	case CTRL_CAPTURE:
+		ucontrol->value.integer.value[0] = ainfo->volume[1][0];
+		ucontrol->value.integer.value[1] = ainfo->volume[1][1];
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int scu_dai_put_volume(struct snd_kcontrol *kctrl,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct scu_audio_info *ainfo = snd_kcontrol_chip(kctrl);
+	int change = 0;
+
+	if (ucontrol->value.integer.value[0] < 0 ||
+		ucontrol->value.integer.value[0] > VOLUME_MAX_DVC ||
+		ucontrol->value.integer.value[1] < 0 ||
+		ucontrol->value.integer.value[1] > VOLUME_MAX_DVC)
+		return -EINVAL;
+
+	switch (kctrl->private_value) {
+	case CTRL_PLAYBACK:
+		change |= ((ainfo->volume[0][0] !=
+			ucontrol->value.integer.value[0]) ||
+			(ainfo->volume[0][1] !=
+			ucontrol->value.integer.value[1]));
+		if (change) {
+			ainfo->volume[0][0] = ucontrol->value.integer.value[0];
+			ainfo->volume[0][1] = ucontrol->value.integer.value[1];
+#if 0
+			/* DVU0_1 L:vol0r R:vol1r */
+			/* DVU0_1 VOL0R : 0xE8209324 */
+			writel(ainfo->volume[0][0],
+				&scux_reg->dvureg[1]->vol0r);
+			/* DVU0_1 VOL1R : 0xE8209328 */
+			writel(ainfo->volume[0][1],
+				&scux_reg->dvureg[1]->vol1r);
+#endif // 0
+		}
+		break;
+	case CTRL_CAPTURE:
+		change |= ((ainfo->volume[1][0] !=
+			ucontrol->value.integer.value[0]) ||
+			(ainfo->volume[1][1] !=
+			ucontrol->value.integer.value[1]));
+		if (change) {
+			ainfo->volume[1][0] = ucontrol->value.integer.value[0];
+			ainfo->volume[1][1] = ucontrol->value.integer.value[1];
+#if 0
+			/* DVU0_0 L:vol1r R:vol0r */
+			writel(ainfo->volume[1][0],
+			       (u32 *)&scux_reg->dvureg[0]->vol1r);
+			writel(ainfo->volume[1][1],
+			       (u32 *)&scux_reg->dvureg[0]->vol0r);
+#endif // 0
+		}
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return change;
+}
+
+static const struct snd_kcontrol_new playback_volume_controls = {
+	.iface		= SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name		= "PCM Playback Volume",
+	.index		= 0,
+	.info		= scu_dai_info_volume,
+	.get		= scu_dai_get_volume,
+	.put		= scu_dai_put_volume,
+	.private_value	= CTRL_PLAYBACK,
+};
+
+static const struct snd_kcontrol_new capture_volume_controls = {
+	.iface		= SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name		= "Capture Volume",
+	.index		= 0,
+	.info		= scu_dai_info_volume,
+	.get		= scu_dai_get_volume,
+	.put		= scu_dai_put_volume,
+	.private_value	= CTRL_CAPTURE,
+};
+
+static int scu_dai_info_mute(struct snd_kcontrol *kctrl,
+				struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 2;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+
+	return 0;
+}
+
+static int scu_dai_get_mute(struct snd_kcontrol *kctrl,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct scu_audio_info *ainfo = snd_kcontrol_chip(kctrl);
+
+	ucontrol->value.integer.value[0] = ainfo->mute[0];
+	ucontrol->value.integer.value[1] = ainfo->mute[1];
+
+	return 0;
+}
+
+static int scu_dai_put_mute(struct snd_kcontrol *kctrl,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct scu_audio_info *ainfo = snd_kcontrol_chip(kctrl);
+	int change = 0;
+	u32 mute = 0;
+
+	if (ucontrol->value.integer.value[0] < 0 ||
+	    ucontrol->value.integer.value[0] > 1 ||
+	    ucontrol->value.integer.value[1] < 0 ||
+	    ucontrol->value.integer.value[1] > 1)
+		return -EINVAL;
+
+	change |= ((ainfo->mute[0] != ucontrol->value.integer.value[0]) ||
+			(ainfo->mute[1] != ucontrol->value.integer.value[1]));
+	if (change) {
+		ainfo->mute[0] = ucontrol->value.integer.value[0];
+		ainfo->mute[1] = ucontrol->value.integer.value[1];
+		mute = (ainfo->mute[1] << 1) + ainfo->mute[0];
+		mute = ~mute & 0x3;
+#if 0
+		writel(mute, (u32 *)&scux_reg->dvureg[1]->zcmcr);
+#endif // 0
+	}
+
+	return change;
+}
+
+static const struct snd_kcontrol_new playback_mute_controls = {
+	.iface		= SNDRV_CTL_ELEM_IFACE_MIXER,
+	.name		= "PCM Playback Switch",
+	.index		= 0,
+	.info		= scu_dai_info_mute,
+	.get		= scu_dai_get_mute,
+	.put		= scu_dai_put_mute,
+};
+
+int scu_dai_add_control(struct snd_card *card)
+{
+	struct device *dev = card->dev;
+	struct snd_kcontrol *kctrl;
+	int i, j, ret;
+
+	/* initial value */
+	for (i = 0; i < 2; i++) {
+		ainfo->rate[i] = 0;
+		ainfo->mute[i] = 1;
+		for (j = 0; j < 2; j++)
+			ainfo->volume[i][j] = VOLUME_DEFAULT;
+	}
+
+	getvolume0 = VOLUME_DEFAULT;
+	getvolume1 = VOLUME_DEFAULT;
+	kctrl = snd_ctl_new1(&playback_rate_controls, ainfo);
+	ret = snd_ctl_add(card, kctrl);
+	if (ret < 0) {
+		dev_err(dev, "failed to add playback rate err=%d\n", ret);
+		return ret;
+	}
+
+	kctrl = snd_ctl_new1(&capture_rate_controls, ainfo);
+	ret = snd_ctl_add(card, kctrl);
+	if (ret < 0) {
+		dev_err(dev, "failed to add capture rate err=%d\n", ret);
+		return ret;
+	}
+
+	kctrl = snd_ctl_new1(&playback_volume_controls, ainfo);
+	ret = snd_ctl_add(card, kctrl);
+	if (ret < 0) {
+		dev_err(dev, "failed to add playback volume err=%d\n", ret);
+		return ret;
+	}
+
+	kctrl = snd_ctl_new1(&capture_volume_controls, ainfo);
+	ret = snd_ctl_add(card, kctrl);
+	if (ret < 0) {
+		dev_err(dev, "failed to add capture volume err=%d\n", ret);
+		return ret;
+	}
+
+	kctrl = snd_ctl_new1(&playback_mute_controls, ainfo);
+	ret = snd_ctl_add(card, kctrl);
+	if (ret < 0) {
+		dev_err(dev, "failed to add playback mute err=%d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(scu_dai_add_control);
+
+static int scu_dai_startup(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai)
+{
+	int ret = 0;
+
+	FNC_ENTRY
+	snd_soc_set_runtime_hwparams(substream, &scu_dai_pcm_hw);
+
+	FNC_EXIT
+	return ret;
+}
+
+static void scu_dai_shutdown(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai)
+{
+	FNC_ENTRY
+	FNC_EXIT
+	return;
+}
+
+static int scu_dai_prepare(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai)
+{
+	FNC_ENTRY
+	FNC_EXIT
+	return 0;
+}
+
+static int scu_dai_set_fmt(struct snd_soc_dai *dai,
+				unsigned int fmt)
+{
+	FNC_ENTRY
+	FNC_EXIT
+	return 0;
+}
+
+static int scu_dai_set_sysclk(struct snd_soc_dai *dai, int clk_id,
+				unsigned int freq, int dir)
+{
+	FNC_ENTRY
+	FNC_EXIT
+	return 0;
+}
+
+static const struct snd_soc_dai_ops scu_dai_ops = {
+	.startup	= scu_dai_startup,
+	.shutdown	= scu_dai_shutdown,
+	.prepare	= scu_dai_prepare,
+	.set_sysclk	= scu_dai_set_sysclk,
+	.set_fmt	= scu_dai_set_fmt,
+};
+
+//static const struct snd_soc_component_driver scu_ssi_component = {
+//	.name		= "scu-ssi",
+//};
+
+static struct snd_soc_dai_driver scu_ssi_dai = {
+	.name	= "rza2-ssi-dai",
+	.playback = {
+		.channels_min = 2,
+		.channels_max = 2,
+		.formats = SNDRV_PCM_FMTBIT_S16,
+		.rates = SNDRV_PCM_RATE_8000_48000,
+	},
+	.capture = {
+		.channels_min = 2,
+		.channels_max = 2,
+		.formats = SNDRV_PCM_FMTBIT_S16,
+		.rates = SNDRV_PCM_RATE_8000_48000,
+	},
+	.ops = &scu_dai_ops,
+};
+
+static void scu_alloc_scureg(void __iomem *mem)
+{
+#if 0
+	int i;
+	void __iomem *offset;
+
+	/* SCUX common */
+	scux_reg->scuxreg = mem;
+
+	/* IPC */
+	offset = mem;
+	for (i = 0; i < 3; i++) {
+		scux_reg->ipcreg[i] = (struct scux_ipc_regs *)offset;
+		offset += 0x100;
+	}
+
+	/* OPC */
+	offset = mem + 0x0400;
+	for (i = 0; i < 3; i++) {
+		scux_reg->opcreg[i] = (struct scux_opc_regs *)offset;
+		offset += 0x100;
+	}
+
+	/* FFD */
+	offset = mem + 0x0800;
+	for (i = 0; i < 3; i++) {
+		scux_reg->ffdreg[i] = (struct scux_ffd_regs *)offset;
+		offset += 0x100;
+	}
+
+	/* FFU */
+	offset = mem + 0x0C00;
+	for (i = 0; i < 3; i++) {
+		scux_reg->ffureg[i] = (struct scux_ffu_regs *)offset;
+		offset += 0x100;
+	}
+
+	/* SRC */
+	offset = mem + 0x1000;
+	scux_reg->srcreg[SCUX_2SRC0_0] = (struct scux_src_regs *)offset;
+	offset = mem + 0x1100;
+	scux_reg->srcreg[SCUX_2SRC0_1] = (struct scux_src_regs *)offset;
+
+	/* DVU */
+	offset = mem + 0x1200;
+	for (i = 0; i < 3; i++) {
+		scux_reg->dvureg[i] = (struct scux_dvu_regs *)offset;
+		offset += 0x100;
+	}
+
+	/* MIX */
+	offset = mem + 0x1600;
+	scux_reg->mixreg = (struct scux_mix_regs *)offset;
+
+	/* CIM */
+	offset = mem + 0x1700;
+	scux_reg->cimreg = (struct scux_cim_regs *)offset;
+
+#endif // 0
+	return;
+}
+
+static void scu_alloc_ssif0reg(void __iomem *mem)
+{
+	int i;
+	void __iomem *offset;
+
+	offset = mem;
+	for (i = 0; i < 5; i++) {
+		scux_reg->ssifreg[i] = (struct ssif_regs *)offset;
+		offset += 0x800;
+		DBG_MSG("ssireg[%2d]=%08x\n", i, (int)scux_reg->ssireg[i]);
+	}
+
+	return;
+}
+
+static int scu_probe(struct platform_device *pdev)
+{
+	int ret = 0;
+	struct scu_clock_info *cinfo;
+	struct resource *scu_res;
+	struct resource *scu_region = NULL;
+	struct resource *ssi_res;
+	struct resource *ssi_region = NULL;
+	void __iomem *mem;
+
+	FNC_ENTRY
+	if (pdev->id != 0) {
+		dev_err(&pdev->dev, "current scu support id 0 only now\n");
+		return -ENODEV;
+	}
+	pdata = pdev->dev.platform_data;
+
+	ainfo = kzalloc(sizeof(struct scu_audio_info), GFP_KERNEL);
+	if (!ainfo) {
+		dev_err(&pdev->dev, "no memory\n");
+		return -ENOMEM;
+	}
+	cinfo = &ainfo->clockinfo;
+	scux_reg = &ainfo->reginfo;
+
+	spin_lock_init(&ainfo->scu_lock);
+	sculock = &ainfo->scu_lock;
+
+	/* resource */
+	scu_res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!scu_res) {
+		dev_err(&pdev->dev, "No memory (0) resource\n");
+		ret = -ENODEV;
+		goto error_clk_put;
+	}
+
+	ssi_res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+
+	if (!ssi_res) {
+		dev_err(&pdev->dev, "No memory (2) resource\n");
+		ret = -ENODEV;
+		goto error_clk_put;
+	}
+
+//	scu_region = request_mem_region(scu_res->start,
+//					resource_size(scu_res), pdev->name);
+	scu_region = devm_request_mem_region(&pdev->dev, scu_res->start,
+					 resource_size(scu_res), pdev->name);
+	if (!scu_region) {
+		dev_err(&pdev->dev, "SCUX region already claimed\n");
+		ret = -EBUSY;
+		goto error_release;
+	}
+
+//	ssi_region = request_mem_region(ssi_res->start,
+//					resource_size(ssi_res), pdev->name);
+	ssi_region = devm_request_mem_region(&pdev->dev, ssi_res->start,
+					resource_size(ssi_res), pdev->name);
+	if (!ssi_region) {
+		dev_err(&pdev->dev, "SSI region already claimed\n");
+		ret = -EBUSY;
+		goto error_release;
+	}
+
+	/* mapping scux */
+	mem = ioremap_nocache(scu_res->start, resource_size(scu_res));
+//	mem = devm_ioremap_nocache(&pdev->dev, scu_res->start, resource_size(scu_res));
+	if (!mem) {
+		dev_err(&pdev->dev, "ioremap failed for scu\n");
+		ret = -ENOMEM;
+		goto error_unmap;
+	}
+	scu_alloc_scureg(mem);
+
+	mem = ioremap_nocache(ssi_res->start, resource_size(ssi_res));
+//	mem = devm_ioremap_nocache(&pdev->dev, ssi_res->start, resource_size(ssi_res));
+	if (!mem) {
+		dev_err(&pdev->dev, "ioremap failed for ssi\n");
+		ret = -ENOMEM;
+		goto error_unmap;
+	}
+	scu_alloc_ssif0reg(mem);
+
+//	ret = snd_soc_register_platform(&pdev->dev, &scu_platform);
+//	if (ret < 0) {
+//		dev_err(&pdev->dev, "cannot snd soc register\n");
+//		goto error_unmap;
+//	}
+
+//	ret = snd_soc_register_component(&pdev->dev, &scu_ssi_component,
+//					 &scu_ssi_dai, 1);
+	ret = devm_snd_soc_register_component(&pdev->dev, &scu_component,
+					 &scu_ssi_dai, 1);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "cannot snd soc dais register\n");
+		goto error_unregister;
+	}
+
+	scu_ssif_init();
+
+	FNC_EXIT
+	return ret;
+
+error_unregister:
+//	snd_soc_unregister_platform(&pdev->dev);
+
+error_unmap:
+//	if (scux_reg->scuxreg)
+//		iounmap(scux_reg->scuxreg);
+
+//	if (scux_reg->ssireg)
+//		iounmap(scux_reg->ssireg);
+
+error_release:
+//	if (scu_region)
+//		release_mem_region(scu_res->start, resource_size(scu_res));
+//	if (ssi_region)
+//		release_mem_region(ssi_res->start, resource_size(ssi_res));
+
+error_clk_put:
+	FNC_EXIT
+	return ret;
+}
+
+/* NOTE: __ref is used because scux_info is declared __initconst.
+ * See include/linux/init.h for more info. */
+static int __ref of_scu_probe(struct platform_device *pdev)
+{
+	platform_device_register_full(&scux_info);
+	return 0;
+}
+
+static int scu_remove(struct platform_device *pdev)
+{
+#if 0
+	struct resource *res;
+
+	FNC_ENTRY
+	snd_soc_unregister_component(&pdev->dev);
+	snd_soc_unregister_platform(&pdev->dev);
+
+	iounmap(scux_reg->scuxreg);
+	iounmap(scux_reg->ssireg);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res)
+		release_mem_region(res->start, resource_size(res));
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	if (res)
+		release_mem_region(res->start, resource_size(res));
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 2);
+	if (res)
+		release_mem_region(res->start, resource_size(res));
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 3);
+	if (res)
+		release_mem_region(res->start, resource_size(res));
+
+	kfree(ainfo);
+
+	FNC_EXIT
+#endif // 0
+	return 0;
+}
+
+static struct platform_driver scu_driver = {
+	.driver		= {
+//		.owner	= THIS_MODULE,
+		.name	= "rza2-pcm-audio",
+	},
+	.probe		= scu_probe,
+	.remove		= scu_remove,
+};
+
+static struct platform_driver of_scu_driver = {
+	.driver		= {
+//		.owner	= THIS_MODULE,
+		.name	= "of_rza2-pcm-audio",
+		.of_match_table = rza2_of_match,
+	},
+	.probe		= of_scu_probe,
+};
+
+module_platform_driver(of_scu_driver);
+module_platform_driver(scu_driver);
+
+MODULE_AUTHOR(" Renesas Solutions Corp.");
+MODULE_DESCRIPTION("ALSA SoC RZA2 SSI driver");
+MODULE_LICENSE("GPL");
diff --git a/sound/soc/sh/rza2_pcm.c b/sound/soc/sh/rza2_pcm.c
new file mode 100755
index 000000000..99dc3abba
--- /dev/null
+++ b/sound/soc/sh/rza2_pcm.c
@@ -0,0 +1,774 @@
+/*
+ * sound/soc/sh/scux_pcm.c
+ *     This file is ALSA SoC driver for SCUX peripheral.
+ *
+ * Copyright (C) 2013 Renesas Solutions Corp.
+ * Copyright (C) 2013 Renesas Electronics Corporation
+ *
+ * This file is based on the sound/soc/sh/siu_pcm.c
+ *
+ * siu_pcm.c - ALSA driver for Renesas SH7343, SH7722 SIU peripheral.
+ *
+ * Copyright (C) 2009-2010 Guennadi Liakhovetski <g.liakhovetski@gmx.de>
+ * Copyright (C) 2006 Carlos Munoz <carlos@kenati.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/dmaengine.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/workqueue.h>
+#include <sound/control.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/sh_rza2.h>
+
+
+#define DRV_NAME "siu-i2s"
+
+#undef DEBUG
+#ifdef DEBUG
+#define FNC_ENTRY	pr_info("entry:%s:%d\n", __func__, __LINE__);
+#define FNC_EXIT	pr_info("exit:%s:%d\n", __func__, __LINE__);
+#define DBG_POINT()	pr_info("check:%s:%d\n", __func__, __LINE__);
+#define DBG_MSG(args...)	pr_info(args)
+#else  /* DEBUG */
+#define FNC_ENTRY
+#define FNC_EXIT
+#define DBG_POINT()
+#define DBG_MSG(args...)
+#endif /* DEBUG */
+
+static u64 dma_mask = DMA_BIT_MASK(32);
+static unsigned int codec_powerup_wait;
+module_param(codec_powerup_wait, uint, 0644);
+
+struct rza1dma_slave {
+	int slave_id;
+};
+
+/* Used by slave DMA clients to request DMA to/from a specific peripheral */
+struct rza1_dma_slave {
+	struct rza1dma_slave	rza1dma_slaveid;	/* Set by the platform */
+};
+
+extern bool rzadma_chan_filter(struct dma_chan *chan, void *arg);
+
+static struct snd_soc_dai *scu_get_dai(struct snd_pcm_substream *ss)
+{
+	struct snd_soc_pcm_runtime *rtd = ss->private_data;
+
+	return  rtd->cpu_dai;
+}
+
+static void scu_avoid_end_noise(int dir, u32 *st_ptr, int size)
+{
+	if (dir == SNDRV_PCM_STREAM_PLAYBACK) {
+		while (0 < size) {
+			*st_ptr = 0;
+			st_ptr++;
+			size--;
+		}
+	}
+}
+
+static void scu_dma_callback(struct snd_pcm_substream *ss)
+{
+	struct snd_pcm_runtime *runtime = ss->runtime;
+	struct scu_pcm_info *pcminfo = ss->runtime->private_data;
+	snd_pcm_uframes_t period, buf, tran, remain, threshold, tran_piece;
+	u32 *buf_st_vadr, *buf_end_vadr;
+	snd_pcm_uframes_t st_point;
+	int dir = ss->stream;
+
+	FNC_ENTRY
+
+	period = runtime->period_size;
+	buf = runtime->buffer_size;
+	tran = pcminfo->tran_size;
+	remain = buf - (tran % buf);
+	threshold = period + (period / 2);
+	tran_piece = pcminfo->tran_period_piece;
+	buf_st_vadr = (u32 *)runtime->dma_area;
+	buf_end_vadr = (u32 *)(runtime->dma_area + runtime->dma_bytes);
+	st_point = tran % buf;
+
+	if ((0 < remain) && (remain <= threshold)) {
+		tran += remain;
+		if (remain <= period)
+			tran_piece = period - remain;
+		else
+			tran_piece = (period * 2) - remain;
+		scu_avoid_end_noise(dir, buf_end_vadr - (period / 2),
+								period / 2);
+	} else if (tran_piece > 0) {
+		if ((tran_piece + period) < threshold)
+			tran += (tran_piece + period);
+		else
+			tran += tran_piece;
+		tran_piece = 0;
+		scu_avoid_end_noise(dir, buf_st_vadr, tran % buf);
+	} else {
+		tran += period;
+		if ((0 < st_point) && (st_point < threshold) &&
+							((buf % period) != 0))
+			scu_avoid_end_noise(dir, buf_st_vadr + st_point,
+						(threshold - 1) - st_point);
+	}
+
+	pcminfo->tran_size = tran;
+	pcminfo->tran_period_piece = tran_piece;
+
+	/* Notify alsa */
+	snd_pcm_period_elapsed(ss);
+
+	/* stop dma */
+	if (pcminfo->flag_start == 0)
+		return;
+
+	queue_work(pcminfo->workq, &pcminfo->work);
+
+	FNC_EXIT
+}
+
+static int scu_dmae_req_chan(int sid, struct snd_pcm_substream *ss)
+{
+	struct scu_pcm_info *pcminfo = ss->runtime->private_data;
+	struct rza1_dma_slave *param = &pcminfo->de_param[sid];
+	struct dma_slave_config cfg;
+	dma_cap_mask_t mask;
+	int ret = 0;
+	struct of_phandle_args *sid_addr;
+
+	dma_cap_zero(mask);
+	dma_cap_set(DMA_SLAVE, mask);
+
+	FNC_ENTRY
+
+	/* set dma slave id */
+	param->rza1dma_slaveid.slave_id = sid;
+	sid_addr = kzalloc(sizeof(struct of_phandle_args), GFP_KERNEL);
+	sid_addr->args[0] = sid;
+
+	/* request dma channel */
+	if (pcminfo->de_chan[sid] == NULL) {
+		pcminfo->de_chan[sid] = dma_request_channel(mask,
+					      rzadma_chan_filter, (void *)sid_addr);
+		if (!pcminfo->de_chan[sid]) {
+			snd_printk(KERN_ERR "DMA channel request error\n");
+			return -EBUSY;
+		}
+
+		cfg.slave_id = sid;
+		ret = dmaengine_slave_config(pcminfo->de_chan[sid], &cfg);
+		if (ret < 0) {
+			dma_release_channel(pcminfo->de_chan[sid]);
+			return ret;
+		}
+	}
+
+	DBG_MSG("chan=0x%08x\n", (int)pcminfo->de_chan[sid]);
+
+	FNC_EXIT
+	return ret;
+}
+
+static void scu_dmae_rel_chan(int sid, struct snd_pcm_substream *ss)
+{
+	struct scu_pcm_info *pcminfo = ss->runtime->private_data;
+
+	FNC_ENTRY
+
+	/* release dma channel */
+	if (pcminfo->de_chan[sid]) {
+		dma_release_channel(pcminfo->de_chan[sid]);
+		pcminfo->de_chan[sid] = NULL;
+	}
+
+	FNC_EXIT
+	return;
+}
+
+static int scu_dmae_request(struct snd_pcm_substream *ss)
+{
+	struct scu_pcm_info *pcminfo = ss->runtime->private_data;
+	int dir = ss->stream == SNDRV_PCM_STREAM_CAPTURE;
+	int route = 0;
+	int audma_slave_id = 0;
+	int ret = 0;
+
+	FNC_ENTRY
+
+	if (!dir) { /* playback */
+		route = pcminfo->routeinfo->p_route;
+	} else { /* capture */
+		route = pcminfo->routeinfo->c_route;
+	}
+
+	audma_slave_id = scu_find_data(route, pcminfo->pdata->audma_slave,
+					pcminfo->pdata->audma_slave_num);
+	if (audma_slave_id != -1) {
+		ret = scu_dmae_req_chan(audma_slave_id, ss);
+		if (ret < 0)
+			return ret;
+	}
+
+	FNC_EXIT
+	return ret;
+}
+
+static int scu_dmae_release(struct snd_pcm_substream *ss)
+{
+	struct scu_pcm_info *pcminfo = ss->runtime->private_data;
+	int dir = ss->stream == SNDRV_PCM_STREAM_CAPTURE;
+	int route = 0;
+	int audma_slave_id = 0;
+	int ret = 0;
+
+	FNC_ENTRY
+
+	if (!dir) /* playback */
+		route = pcminfo->routeinfo->p_route;
+	else /* capture */
+		route = pcminfo->routeinfo->c_route;
+
+	audma_slave_id = scu_find_data(route, pcminfo->pdata->audma_slave,
+					pcminfo->pdata->audma_slave_num);
+	if (audma_slave_id != -1)
+		scu_dmae_rel_chan(audma_slave_id, ss);
+
+	FNC_EXIT
+	return ret;
+}
+
+static int scu_audma_start(int sid, struct snd_pcm_substream *ss)
+{
+	int dir = ss->stream == SNDRV_PCM_STREAM_CAPTURE;
+	struct snd_pcm_runtime *runtime = ss->runtime;
+	struct scu_pcm_info *pcminfo = runtime->private_data;
+	struct device *dev = ss->pcm->card->dev;
+	struct dma_async_tx_descriptor *desc;
+	dma_cookie_t cookie;
+	u32 dma_size;
+	u32 dma_paddr;
+	struct snd_soc_dai *dai;
+	snd_pcm_uframes_t period, buf, offset, remain, threshold, period_piece;
+
+	FNC_ENTRY
+
+	dai = scu_get_dai(ss);
+
+	/* DMA physical adddress */
+	dma_paddr = runtime->dma_addr
+			+ frames_to_bytes(runtime, pcminfo->buf_offset);
+	DBG_MSG("dma_paddr=0x%08x\n", dma_paddr);
+
+	period = runtime->period_size;
+	buf = runtime->buffer_size;
+	offset = pcminfo->buf_offset;
+	remain = buf - offset;
+	threshold = period + (period / 2);
+	period_piece = pcminfo->period_piece;
+
+	/* DMA size */
+	if ((0 < remain) && (remain <= threshold)) {
+		dma_size = frames_to_bytes(runtime, remain);
+		offset = 0;
+		if (remain <= period)
+			period_piece = period - remain;
+		else
+			period_piece = (period * 2) - remain;
+	} else if (period_piece > 0) {
+		if (period_piece + period < threshold) {
+			dma_size = frames_to_bytes(runtime,
+						period_piece + period);
+			offset += (period_piece + period);
+		} else {
+			dma_size = frames_to_bytes(runtime, period_piece);
+			offset += period_piece;
+		}
+		period_piece = 0;
+	} else {
+		dma_size = frames_to_bytes(runtime, period);
+		offset += period;
+		if (offset >= buf)
+			offset -= buf;
+	}
+	DBG_MSG("dma_size=%d\n", dma_size);
+
+	pcminfo->buf_offset = offset;
+	pcminfo->period_piece = period_piece;
+
+	dma_sync_single_for_device(dai->dev, dma_paddr, dma_size, DMA_DIR(dir));
+
+	desc = dmaengine_prep_slave_single(pcminfo->de_chan[sid], dma_paddr,
+		dma_size, DMA_DIR(dir), DMA_PREP_INTERRUPT | DMA_CTRL_ACK);
+	if (!desc) {
+		dev_err(dai->dev, "dmaengine_prep_slave_sg_single() fail\n");
+		return -ENOMEM;
+	}
+
+	desc->callback = (dma_async_tx_callback)scu_dma_callback;
+	desc->callback_param = ss;
+
+//	cookie = dmaengine_submit(desc);
+	cookie = desc->tx_submit(desc);
+	if (cookie < 0) {
+		dev_err(dev, "Failed to submit a dma transfer\n");
+		FNC_EXIT
+		return cookie;
+	}
+
+	dma_async_issue_pending(pcminfo->de_chan[sid]);
+
+	FNC_EXIT
+	return 0;
+}
+
+static int scu_audma_stop(int sid, struct snd_pcm_substream *ss)
+{
+	FNC_ENTRY
+
+	FNC_EXIT
+	return 0;
+}
+
+static void scu_pcm_start(struct snd_pcm_substream *ss, int first_flag)
+{
+	struct scu_pcm_info *pcminfo = ss->runtime->private_data;
+	int dir = ss->stream == SNDRV_PCM_STREAM_CAPTURE;
+	int route = 0;
+	int audma_slave_id = 0;
+	int ssi_depend = 0;
+	int ssi_mode = 0;
+	int src_ch = 0;
+	int src_mode = 0;
+	int dvc_ch = 0;
+	struct scu_pcm_callback callback;
+
+	FNC_ENTRY
+
+	if (!dir) { /* playback */
+		route = pcminfo->routeinfo->p_route;
+		callback = pcminfo->routeinfo->pcb;
+	} else { /* capture */
+		route = pcminfo->routeinfo->c_route;
+		callback = pcminfo->routeinfo->ccb;
+	}
+
+	audma_slave_id = scu_find_data(route, pcminfo->pdata->audma_slave,
+					pcminfo->pdata->audma_slave_num);
+	ssi_depend = scu_find_data(route, pcminfo->pdata->ssi_depend,
+					pcminfo->pdata->ssi_depend_num);
+	ssi_mode = scu_find_data(route, pcminfo->pdata->ssi_mode,
+					pcminfo->pdata->ssi_mode_num);
+	src_ch = scu_find_data(route, pcminfo->pdata->src_ch,
+					pcminfo->pdata->src_ch_num);
+	src_mode = scu_find_data(route, pcminfo->pdata->src_mode,
+					pcminfo->pdata->src_mode_num);
+	dvc_ch = scu_find_data(route, pcminfo->pdata->dvc_ch,
+					pcminfo->pdata->dvc_ch_num);
+
+	/* start dma */
+	scu_audma_start(audma_slave_id, ss);
+
+	if (first_flag) {
+		/* Four Descripters are registered first */
+
+		/* start dma */
+		scu_audma_start(audma_slave_id, ss);
+
+		/* start dma */
+		scu_audma_start(audma_slave_id, ss);
+
+		/* start dma */
+		scu_audma_start(audma_slave_id, ss);
+
+		/* start ssi */
+		if (callback.init_ssi)
+			callback.init_ssi(pcminfo->pdata->ssi_master,
+				pcminfo->pdata->ssi_slave,
+				ssi_mode, ssi_depend, dir);
+
+		/* start dvc */
+		if (callback.init_dvc)
+			callback.init_dvc(dvc_ch);
+
+		/* start src */
+		if (callback.init_src)
+			callback.init_src(src_ch, ss->runtime->rate, src_mode);
+	}
+
+	FNC_EXIT
+	return;
+}
+
+static void scu_pcm_stop(struct snd_pcm_substream *ss)
+{
+	struct scu_pcm_info *pcminfo = ss->runtime->private_data;
+	int dir = ss->stream == SNDRV_PCM_STREAM_CAPTURE;
+	int route = 0;
+	int audma_slave_id = 0;
+	int ssi_ch = 0;
+	int ssi_depend = 0;
+	int ssi_mode = 0;
+	int src_ch = 0;
+	int dvc_ch = 0;
+	struct scu_pcm_callback callback;
+
+	FNC_ENTRY
+
+	if (!dir) { /* playback */
+		route = pcminfo->routeinfo->p_route;
+		callback = pcminfo->routeinfo->pcb;
+	} else { /* capture */
+		route = pcminfo->routeinfo->c_route;
+		callback = pcminfo->routeinfo->ccb;
+	}
+
+	audma_slave_id = scu_find_data(route, pcminfo->pdata->audma_slave,
+					pcminfo->pdata->audma_slave_num);
+	ssi_ch = scu_find_data(route, pcminfo->pdata->ssi_ch,
+					pcminfo->pdata->ssi_ch_num);
+	ssi_depend = scu_find_data(route, pcminfo->pdata->ssi_depend,
+					pcminfo->pdata->ssi_depend_num);
+	ssi_mode = scu_find_data(route, pcminfo->pdata->ssi_mode,
+					pcminfo->pdata->ssi_mode_num);
+	src_ch = scu_find_data(route, pcminfo->pdata->src_ch,
+					pcminfo->pdata->src_ch_num);
+	dvc_ch = scu_find_data(route, pcminfo->pdata->dvc_ch,
+					pcminfo->pdata->dvc_ch_num);
+	/* stop src */
+	if (callback.deinit_src)
+		callback.deinit_src(src_ch);
+
+	/* stop dvc */
+	if (callback.deinit_dvc)
+		callback.deinit_dvc(dvc_ch);
+
+	/* stop ssi */
+	if (callback.deinit_ssi)
+		callback.deinit_ssi(ssi_ch, ssi_mode, ssi_depend, dir);
+
+	/* stop dma */
+	scu_audma_stop(audma_slave_id, ss);
+
+	FNC_EXIT
+	return;
+}
+
+static void scu_dma_do_work(struct work_struct *work)
+{
+	struct scu_pcm_info *pcminfo =
+			container_of(work, struct scu_pcm_info, work);
+	struct snd_pcm_substream *ss = pcminfo->ss;
+
+	FNC_ENTRY
+
+	/* start pcm process */
+	scu_pcm_start(ss, pcminfo->flag_first);
+	if (pcminfo->flag_first == 1)
+		pcminfo->flag_first = 0;
+
+	FNC_EXIT
+	return;
+}
+
+static int scu_audio_start(struct snd_pcm_substream *ss)
+{
+	struct scu_pcm_info *pcminfo = ss->runtime->private_data;
+	int ret = 0;
+
+	FNC_ENTRY
+
+	/* dma channel request */
+	ret = scu_dmae_request(ss);
+	if (ret < 0) {
+		pr_info("scu_dmae_request faild\n");
+		FNC_EXIT
+		return ret;
+	}
+
+	/* DMA control */
+	pcminfo->flag_start = 1;
+	/* PCM 1st process */
+	pcminfo->flag_first = 1;
+
+	pcminfo->buf_offset = 0;
+	pcminfo->tran_size = 0;
+	pcminfo->period_piece = 0;
+	pcminfo->tran_period_piece = 0;
+
+	mdelay(codec_powerup_wait);
+	queue_work(pcminfo->workq, &pcminfo->work);
+
+	FNC_EXIT
+	return ret;
+}
+
+static int scu_audio_stop(struct snd_pcm_substream *ss)
+{
+	int ret = 0;
+	struct scu_pcm_info *pcminfo = ss->runtime->private_data;
+
+	FNC_ENTRY
+
+	/* stop dma */
+	pcminfo->flag_start = 0;
+
+	/* stop pcm process */
+	scu_pcm_stop(ss);
+
+	/* dma channel release */
+	ret = scu_dmae_release(ss);
+
+	/* Cancel work queue */
+	cancel_work_sync(&pcminfo->work);
+
+	FNC_EXIT
+	return ret;
+}
+
+static struct scu_pcm_info *scu_pcm_new_stream(struct snd_pcm_substream *ss)
+{
+	struct scu_pcm_info *pcminfo;
+
+	FNC_ENTRY
+
+	/* allocate scu_pcm_info structure */
+	pcminfo = kzalloc(sizeof(struct scu_pcm_info), GFP_KERNEL);
+	if (!pcminfo)
+		return pcminfo;
+
+	/* initialize rcar_pcm_info structure */
+	pcminfo->routeinfo   = scu_get_route_info();
+	pcminfo->ss          = ss;
+	pcminfo->pdata       = scu_get_platform_data();
+
+	/* allocate dma_chan structure */
+	pcminfo->de_chan = kzalloc((sizeof(struct dma_chan) *
+					pcminfo->pdata->dma_slave_maxnum),
+					GFP_KERNEL);
+	if (!pcminfo->de_chan) {
+		kfree(pcminfo);
+		return NULL;
+	}
+
+	/* allocate sh_dmadesc_slave structure */
+	pcminfo->de_param = kzalloc((sizeof(struct rza1_dma_slave) *
+					pcminfo->pdata->dma_slave_maxnum),
+					GFP_KERNEL);
+	if (!pcminfo->de_param) {
+		kfree(pcminfo->de_chan);
+		kfree(pcminfo);
+		return NULL;
+	}
+	spin_lock_init(&pcminfo->pcm_lock);
+	pcminfo->workq = alloc_ordered_workqueue("sh_scu_pcm", 0);
+	INIT_WORK(&pcminfo->work, scu_dma_do_work);
+
+	FNC_EXIT
+	return pcminfo;
+}
+
+static void scu_pcm_free_stream(struct snd_pcm_runtime *runtime)
+{
+	struct scu_pcm_info *pcminfo = runtime->private_data;
+
+	FNC_ENTRY
+
+	/* post process */
+	cancel_work_sync(&pcminfo->work);
+	destroy_workqueue(pcminfo->workq);
+	kfree(pcminfo->de_param);
+	kfree(pcminfo->de_chan);
+	kfree(runtime->private_data);	/* free pcminfo structure */
+
+	FNC_EXIT
+	return;
+}
+
+static int scu_pcm_open(struct snd_pcm_substream *ss)
+{
+	struct scu_pcm_info *pcminfo;
+	int dir = ss->stream == SNDRV_PCM_STREAM_CAPTURE;
+	int ret = 0;
+
+	FNC_ENTRY
+
+	pcminfo = scu_pcm_new_stream(ss);
+	if (pcminfo == NULL)
+		return -ENOMEM;
+
+	ret = scu_check_route(dir, pcminfo->routeinfo);
+	if (ret < 0)
+		return ret;
+
+	ss->runtime->private_data = pcminfo;
+	ss->runtime->private_free = scu_pcm_free_stream;
+
+	FNC_EXIT
+	return 0;
+}
+
+static int scu_pcm_close(struct snd_pcm_substream *ss)
+{
+	FNC_ENTRY
+
+	FNC_EXIT
+	return 0;
+}
+
+static int scu_pcm_hw_params(struct snd_pcm_substream *ss,
+			     struct snd_pcm_hw_params *hw_params)
+{
+	struct device *dev = ss->pcm->card->dev;
+	int ret;
+
+	FNC_ENTRY
+
+	ret = snd_pcm_lib_malloc_pages(ss, params_buffer_bytes(hw_params));
+	if (ret < 0)
+		dev_err(dev, "snd_pcm_lib_malloc_pages() failed\n");
+
+	FNC_EXIT
+	return ret;
+}
+
+static int scu_pcm_hw_free(struct snd_pcm_substream *ss)
+{
+	struct device *dev = ss->pcm->card->dev;
+	int ret;
+
+	FNC_ENTRY
+
+	ret = snd_pcm_lib_free_pages(ss);
+	if (ret < 0)
+		dev_err(dev, "snd_pcm_lib_free_pages() failed\n");
+
+	FNC_EXIT
+	return ret;
+}
+
+static int scu_pcm_prepare(struct snd_pcm_substream *ss)
+{
+	FNC_ENTRY
+
+	FNC_EXIT
+	return 0;
+}
+
+static int scu_pcm_trigger(struct snd_pcm_substream *ss, int cmd)
+{
+	int ret = 0;
+	struct snd_pcm_runtime *runtime = ss->runtime;
+	struct scu_pcm_info *pcminfo = runtime->private_data;
+
+	spin_lock(&pcminfo->pcm_lock);
+
+	FNC_ENTRY
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+		ret = scu_audio_start(ss);
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+		ret = scu_audio_stop(ss);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	spin_unlock(&pcminfo->pcm_lock);
+
+	FNC_EXIT
+	return ret;
+}
+
+static snd_pcm_uframes_t scu_pcm_pointer_dma(struct snd_pcm_substream *ss)
+{
+	struct snd_pcm_runtime *runtime = ss->runtime;
+	struct scu_pcm_info *pcminfo = runtime->private_data;
+	snd_pcm_uframes_t position = 0;
+
+	position = pcminfo->tran_size % runtime->buffer_size;
+
+	DBG_MSG("\tposition = %d\n", (u32)position);
+
+	return position;
+}
+
+static int scu_pcm_new(struct snd_soc_pcm_runtime *rtd)
+{
+	int ret = 0;
+	struct snd_card *card = rtd->card->snd_card;
+
+	FNC_ENTRY
+
+	ret = scu_dai_add_control(card);
+
+	if (ret)
+		return ret;
+
+	if (!card->dev->dma_mask)
+		card->dev->dma_mask = &dma_mask;
+
+	if (!card->dev->coherent_dma_mask)
+		card->dev->coherent_dma_mask = DMA_BIT_MASK(32);
+	ret = snd_pcm_lib_preallocate_pages_for_all(
+		rtd->pcm,
+		SNDRV_DMA_TYPE_DEV,
+		rtd->card->snd_card->dev,
+		SCU_BUFFER_BYTES_MAX, SCU_BUFFER_BYTES_MAX);
+
+	FNC_EXIT
+	return ret;
+}
+
+static void scu_pcm_free(struct snd_pcm *pcm)
+{
+	FNC_ENTRY
+
+	/* free dma buffer */
+	snd_pcm_lib_preallocate_free_for_all(pcm);
+
+	FNC_EXIT
+}
+
+static const struct snd_pcm_ops scu_pcm_ops = {
+	.open		= scu_pcm_open,
+	.close		= scu_pcm_close,
+	.ioctl		= snd_pcm_lib_ioctl,
+	.hw_params	= scu_pcm_hw_params,
+	.hw_free	= scu_pcm_hw_free,
+	.prepare	= scu_pcm_prepare,
+	.trigger	= scu_pcm_trigger,
+	.pointer	= scu_pcm_pointer_dma,
+};
+
+struct snd_soc_component_driver scu_component = {
+	.name		= DRV_NAME,
+	.ops		= &scu_pcm_ops,
+	.pcm_new	= scu_pcm_new,
+	.pcm_free	= scu_pcm_free,
+};
+EXPORT_SYMBOL_GPL(scu_component);
diff --git a/sound/soc/sh/rza2mevb.c b/sound/soc/sh/rza2mevb.c
new file mode 100755
index 000000000..0edc96293
--- /dev/null
+++ b/sound/soc/sh/rza2mevb.c
@@ -0,0 +1,627 @@
+/*
+ * sound/soc/sh/rza2mevb.c
+ *     This file is ALSA SoC driver for rza2.
+ *
+ * Copyright (C) 2014 Renesas Solutions Corp.
+ * Copyright (C) 2014 Renesas Electronics Corporation
+ * Copyright (C) 2014 Timesys Corporation
+ *
+ * This file is based on the sound/soc/sh/rza2mevb.c
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/device.h>
+#include <linux/module.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/soc.h>
+#include <sound/sh_rza2.h>
+
+#undef DEBUG
+#ifdef DEBUG
+#define FNC_ENTRY	pr_info("entry:%s:%d\n", __func__, __LINE__);
+#define FNC_EXIT	pr_info("exit:%s:%d\n", __func__, __LINE__);
+#define DBG_POINT()	pr_info("check:%s:%d\n", __func__, __LINE__);
+#define DBG_MSG(args...)	pr_info(args)
+#else  /* DEBUG */
+#define FNC_ENTRY
+#define FNC_EXIT
+#define DBG_POINT()
+#define DBG_MSG(args...)
+#endif /* DEBUG */
+
+static const struct of_device_id rza2_snd_of_match[] = {
+	{ .compatible = "renesas,rza2mevb_sound_alsa" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, rza2_snd_of_match);
+
+static struct scu_route_info *routeinfo;
+
+int scu_check_route(int dir, struct scu_route_info *routeinfo)
+{
+	if (!dir) { /* playback */
+		if (routeinfo->p_route != RP_MEM_SSI0 &&
+		    routeinfo->p_route != RP_MEM_SRC1_SSI0 &&
+		    routeinfo->p_route != RP_MEM_SRC1_DVC1_SSI0) {
+			pr_info("scu playback route is invalid.\n");
+			return -EPERM;
+		}
+	} else { /* capture */
+		if (routeinfo->c_route != RC_SSI0_MEM &&
+		    routeinfo->c_route != RC_SSI0_SRC0_MEM) {
+			pr_info("scu capture route is invalid.\n");
+			return -EPERM;
+		}
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(scu_check_route);
+
+/************************************************************************
+
+	DAPM
+
+************************************************************************/
+#undef EV_PRINT
+#ifdef EV_PRINT
+static void event_print(int event, char *evt_str)
+{
+
+	switch (event) {
+	case SND_SOC_DAPM_PRE_PMU:
+		snd_printk(KERN_INFO "%s SND_SOC_DAPM_PRE_PMU\n", evt_str);
+		break;
+	case SND_SOC_DAPM_POST_PMU:
+		snd_printk(KERN_INFO "%s SND_SOC_DAPM_POST_PMU\n", evt_str);
+		break;
+	case SND_SOC_DAPM_PRE_PMD:
+		snd_printk(KERN_INFO "%s SND_SOC_DAPM_PRE_PMD\n", evt_str);
+		break;
+	case SND_SOC_DAPM_POST_PMD:
+		snd_printk(KERN_INFO "%s SND_SOC_DAPM_POST_PMD\n", evt_str);
+		break;
+	default:
+		snd_printk(KERN_INFO "%s unknown event\n", evt_str);
+	}
+}
+#else
+#define event_print(a, b)
+#endif
+
+static int event_ssi0(struct snd_soc_dapm_widget *w,
+		      struct snd_kcontrol *kcontrol, int event)
+{
+	event_print(event, "ssi0");
+	if (event == SND_SOC_DAPM_POST_PMU) {
+		/* playback */
+		routeinfo->pcb.init_ssi = scu_init_ssi;
+		routeinfo->pcb.deinit_ssi = scu_deinit_ssi;
+		/* add capture */
+		routeinfo->ccb.init_ssi = scu_init_ssi;
+		routeinfo->ccb.deinit_ssi = scu_deinit_ssi;
+	} else if (event == SND_SOC_DAPM_PRE_PMD) {
+		/* playback */
+		routeinfo->pcb.init_ssi = NULL;
+		routeinfo->pcb.deinit_ssi = NULL;
+		/* add capture */
+		routeinfo->ccb.init_ssi = NULL;
+		routeinfo->ccb.deinit_ssi = NULL;
+	}
+	return 0;
+}
+
+static int event_ssi0_src0(struct snd_soc_dapm_widget *w,
+			   struct snd_kcontrol *kcontrol, int event)
+{
+	event_print(event, "ssi0_src0");
+	if (event == SND_SOC_DAPM_POST_PMU) {
+		routeinfo->ccb.init_ssi = scu_init_ssi;
+		routeinfo->ccb.deinit_ssi = scu_deinit_ssi;
+	} else if (event == SND_SOC_DAPM_PRE_PMD) {
+		routeinfo->ccb.init_ssi = NULL;
+		routeinfo->ccb.deinit_ssi = NULL;
+	}
+	return 0;
+}
+
+static int event_ssi0_src1(struct snd_soc_dapm_widget *w,
+			   struct snd_kcontrol *kcontrol, int event)
+{
+	event_print(event, "ssi0_src1");
+	if (event == SND_SOC_DAPM_POST_PMU) {
+		routeinfo->pcb.init_ssi = scu_init_ssi;
+		routeinfo->pcb.deinit_ssi = scu_deinit_ssi;
+	} else if (event == SND_SOC_DAPM_PRE_PMD) {
+		routeinfo->pcb.init_ssi = NULL;
+		routeinfo->pcb.deinit_ssi = NULL;
+	}
+	return 0;
+}
+
+static int event_ssi0_dvc1(struct snd_soc_dapm_widget *w,
+			   struct snd_kcontrol *kcontrol, int event)
+{
+	event_print(event, "ssi0_dvc1");
+	if (event == SND_SOC_DAPM_POST_PMU) {
+		routeinfo->pcb.init_ssi = scu_init_ssi;
+		routeinfo->pcb.deinit_ssi = scu_deinit_ssi;
+	} else if (event == SND_SOC_DAPM_PRE_PMD) {
+		routeinfo->pcb.init_ssi = NULL;
+		routeinfo->pcb.deinit_ssi = NULL;
+	}
+	return 0;
+}
+
+
+static int event_src0(struct snd_soc_dapm_widget *w,
+		      struct snd_kcontrol *kcontrol, int event)
+{
+	event_print(event, "src0");
+	if (event == SND_SOC_DAPM_POST_PMU) {
+		routeinfo->ccb.init_src = scu_init_src;
+		routeinfo->ccb.deinit_src = scu_deinit_src;
+	} else if (event == SND_SOC_DAPM_PRE_PMD) {
+		routeinfo->ccb.init_src = NULL;
+		routeinfo->ccb.deinit_src = NULL;
+	}
+	return 0;
+}
+
+static int event_src1(struct snd_soc_dapm_widget *w,
+		      struct snd_kcontrol *kcontrol, int event)
+{
+	event_print(event, "src1");
+	if (event == SND_SOC_DAPM_POST_PMU) {
+		routeinfo->pcb.init_src = scu_init_src;
+		routeinfo->pcb.deinit_src = scu_deinit_src;
+	} else if (event == SND_SOC_DAPM_PRE_PMD) {
+		routeinfo->pcb.init_src = NULL;
+		routeinfo->pcb.deinit_src = NULL;
+	}
+	return 0;
+}
+
+static int event_src1_dvc1(struct snd_soc_dapm_widget *w,
+			   struct snd_kcontrol *kcontrol, int event)
+{
+	event_print(event, "src1_dvc1");
+	if (event == SND_SOC_DAPM_POST_PMU) {
+		routeinfo->pcb.init_src = scu_init_src;
+		routeinfo->pcb.deinit_src = scu_deinit_src;
+	} else if (event == SND_SOC_DAPM_PRE_PMD) {
+		routeinfo->pcb.init_src = NULL;
+		routeinfo->pcb.deinit_src = NULL;
+	}
+	return 0;
+}
+
+static int event_dvc1(struct snd_soc_dapm_widget *w,
+		      struct snd_kcontrol *kcontrol, int event)
+{
+	event_print(event, "dvc1");
+	if (event == SND_SOC_DAPM_POST_PMU) {
+		routeinfo->pcb.init_dvc = scu_init_dvc;
+		routeinfo->pcb.deinit_dvc = scu_deinit_dvc;
+	} else if (event == SND_SOC_DAPM_PRE_PMD) {
+		routeinfo->pcb.init_dvc = NULL;
+		routeinfo->pcb.deinit_dvc = NULL;
+	}
+	return 0;
+}
+
+static void scu_playback_route_control(struct snd_soc_dapm_context *dapm)
+{
+	snd_soc_dapm_disable_pin(dapm, "SSI0_OUT0");
+	snd_soc_dapm_disable_pin(dapm, "SSI0_OUT1");
+	snd_soc_dapm_disable_pin(dapm, "SSI0_OUT2");
+
+	switch (routeinfo->p_route) {
+	case RP_MEM_SSI0:
+		snd_soc_dapm_enable_pin(dapm, "SSI0_OUT0");
+		break;
+	case RP_MEM_SRC1_SSI0:
+		snd_soc_dapm_enable_pin(dapm, "SSI0_OUT1");
+		break;
+	case RP_MEM_SRC1_DVC1_SSI0:
+		snd_soc_dapm_enable_pin(dapm, "SSI0_OUT2");
+		break;
+	default:
+		break;
+	};
+}
+
+static void scu_capture_route_control(struct snd_soc_dapm_context *dapm)
+{
+	snd_soc_dapm_disable_pin(dapm, "SSI0_IN0");
+	snd_soc_dapm_disable_pin(dapm, "SSI0_IN1");
+
+	switch (routeinfo->c_route) {
+	case RC_SSI0_MEM:
+		snd_soc_dapm_enable_pin(dapm, "SSI0_IN0");
+		break;
+	case RC_SSI0_SRC0_MEM:
+		snd_soc_dapm_enable_pin(dapm, "SSI0_IN1");
+		break;
+	default:
+		break;
+	};
+}
+
+static int scu_get_ssi0_route(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = routeinfo->route_ssi[0];
+
+	return 0;
+}
+
+static int scu_set_ssi0_route(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+
+	if (routeinfo->route_ssi[0] == ucontrol->value.integer.value[0])
+		return 0;
+
+	routeinfo->route_ssi[0] = ucontrol->value.integer.value[0];
+
+	if (routeinfo->route_ssi[0])
+		routeinfo->p_route |= RP_MEM_SSI0;
+	else
+		routeinfo->p_route &= ~RP_MEM_SSI0;
+
+	scu_playback_route_control(&card->dapm);
+
+	return 1;
+}
+
+static int scu_get_ssi0_caproute(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = routeinfo->route_ssi[1];
+
+	return 0;
+}
+
+static int scu_set_ssi0_caproute(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+	DBG_MSG("start:scu_set_ssi0_caproute");
+	if (routeinfo->route_ssi[1] == ucontrol->value.integer.value[0])
+		return 0;
+
+	routeinfo->route_ssi[1] = ucontrol->value.integer.value[0];
+
+	if (routeinfo->route_ssi[1])
+		routeinfo->c_route |= RC_SSI0_MEM;
+	else
+		routeinfo->c_route &= ~RC_SSI0_MEM;
+
+	scu_capture_route_control(&card->dapm);
+	return 1;
+}
+
+static int scu_get_src0_route(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = routeinfo->route_src[SRC0];
+
+	return 0;
+}
+
+static int scu_set_src0_route(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+
+	if (routeinfo->route_src[SRC0] == ucontrol->value.integer.value[0])
+		return 0;
+
+	routeinfo->route_src[SRC0] = ucontrol->value.integer.value[0];
+	if (routeinfo->route_src[SRC0])
+		routeinfo->c_route |= W_SRC0;
+	else
+		routeinfo->c_route &= ~W_SRC0;
+
+	scu_capture_route_control(&card->dapm);
+
+	return 1;
+}
+
+static int scu_get_src1_route(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = routeinfo->route_src[SRC1];
+
+	return 0;
+}
+static int scu_set_src1_route(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+
+	if (routeinfo->route_src[SRC1] == ucontrol->value.integer.value[0])
+		return 0;
+
+	routeinfo->route_src[SRC1] = ucontrol->value.integer.value[0];
+	if (routeinfo->route_src[SRC1])
+		routeinfo->p_route |= W_SRC1;
+	else
+		routeinfo->p_route &= ~W_SRC1;
+
+	scu_playback_route_control(&card->dapm);
+
+	return 1;
+}
+
+static int scu_get_dvc1_route(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = routeinfo->route_dvc[DVC1];
+
+	return 0;
+}
+
+static int scu_set_dvc1_route(struct snd_kcontrol *kcontrol,
+			      struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_card *card = snd_kcontrol_chip(kcontrol);
+
+	if (routeinfo->route_dvc[DVC1] == ucontrol->value.integer.value[0])
+		return 0;
+
+	routeinfo->route_dvc[DVC1] = ucontrol->value.integer.value[0];
+	if (routeinfo->route_dvc[DVC1])
+		routeinfo->p_route |= W_DVC1;
+	else
+		routeinfo->p_route &= ~W_DVC1;
+
+	scu_playback_route_control(&card->dapm);
+
+	return 1;
+}
+
+static const char * const widget_switch[] = {"Off", "On"};
+
+static const struct soc_enum widget_switch_enum =
+	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(widget_switch), widget_switch);
+
+static const struct snd_kcontrol_new playback_controls[] = {
+	SOC_ENUM_EXT("SSI0 Control", widget_switch_enum,
+	scu_get_ssi0_route, scu_set_ssi0_route),
+	SOC_ENUM_EXT("SRC1 Control", widget_switch_enum,
+	scu_get_src1_route, scu_set_src1_route),
+	SOC_ENUM_EXT("DVC1 Control", widget_switch_enum,
+	scu_get_dvc1_route, scu_set_dvc1_route),
+};
+
+static const struct snd_kcontrol_new capture_controls[] = {
+	SOC_ENUM_EXT("SSI0 CapControl", widget_switch_enum,
+	scu_get_ssi0_caproute, scu_set_ssi0_caproute),
+	SOC_ENUM_EXT("SRC0 Control", widget_switch_enum,
+	scu_get_src0_route, scu_set_src0_route),
+};
+
+static const struct snd_soc_dapm_widget rza2menv_dapm_widgets[] = {
+	/* Playback */
+	SND_SOC_DAPM_OUTPUT("SSI0_OUT0"),
+	SND_SOC_DAPM_OUTPUT("SSI0_OUT1"),
+	SND_SOC_DAPM_OUTPUT("SSI0_OUT2"),
+	SND_SOC_DAPM_DAC("MEM_OUT", "HiFi Playback", SND_SOC_NOPM, 0, 0),
+
+	SND_SOC_DAPM_MIXER_E("SSI0", SND_SOC_NOPM, 0, 0, NULL, 0,
+	event_ssi0,
+	SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
+	SND_SOC_DAPM_MIXER_E("SSI0_SRC1", SND_SOC_NOPM, 0, 0, NULL, 0,
+	event_ssi0_src1,
+	SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
+	SND_SOC_DAPM_MIXER_E("SSI0_DVC1", SND_SOC_NOPM, 0, 0, NULL, 0,
+	event_ssi0_dvc1,
+	SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
+	SND_SOC_DAPM_MIXER_E("SRC1", SND_SOC_NOPM, 0, 0, NULL, 0,
+	event_src1,
+	SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
+	SND_SOC_DAPM_MIXER_E("DVC1", SND_SOC_NOPM, 0, 0, NULL, 0,
+	event_dvc1,
+	SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
+	SND_SOC_DAPM_MIXER_E("src1_dvc1", SND_SOC_NOPM, 0, 0, NULL, 0,
+	event_src1_dvc1,
+	SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
+
+	/* Capture */
+	SND_SOC_DAPM_ADC("MEM_IN", "HiFi Capture", SND_SOC_NOPM, 0, 0),
+
+	SND_SOC_DAPM_INPUT("SSI0_IN0"),
+	SND_SOC_DAPM_INPUT("SSI0_IN1"),
+	SND_SOC_DAPM_MIXER_E("SSI0", SND_SOC_NOPM, 0, 0, NULL, 0,
+	event_ssi0,
+	SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
+	SND_SOC_DAPM_MIXER_E("SSI0_SRC0", SND_SOC_NOPM, 0, 0, NULL, 0,
+	event_ssi0_src0,
+	SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
+	SND_SOC_DAPM_MIXER_E("SRC0", SND_SOC_NOPM, 0, 0, NULL, 0,
+	event_src0,
+	SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
+};
+
+static const struct snd_soc_dapm_route audio_map[] = {
+	/* Playback route */
+	/* SSI<-MEM */
+	{"SSI0", NULL, "MEM_OUT"},
+	{"SSI0_OUT0", NULL, "SSI0"},
+	/* SSI<-SRC<-MEM */
+	{"SRC1", NULL, "MEM_OUT"},
+	{"SSI0_SRC1", NULL, "SRC1"},
+	{"SSI0_OUT1", NULL, "SSI0_SRC1"},
+	/* SSI<-DVC<-SRC<-MEM */
+	{"DVC1", NULL, "SRC1"},
+	{"SSI0_DVC1", NULL, "DVC1"},
+	{"SSI0_OUT2", NULL, "SSI0_DVC1"},
+
+	/* Capture route */
+	/* MEM<-SSI */
+	{"SSI0", NULL, "SSI0_IN0"},
+	{"MEM_IN", NULL, "SSI0"},
+	/* MEM<-SRC<-SSI */
+	{"SSI0_SRC0", NULL, "SSI0_IN1"},
+	{"SRC0", NULL, "SSI0_SRC0"},
+	{"MEM_IN", NULL, "SRC0"},
+};
+
+/************************************************************************
+
+	ALSA SoC
+
+************************************************************************/
+static int rza2menv_hw_params(struct snd_pcm_substream *substream,
+			    struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->codec_dai;
+	int ret;
+
+	/* set PLL clock */
+	ret = snd_soc_dai_set_sysclk(codec_dai, 0, 22579200, SND_SOC_CLOCK_IN);
+	if (ret) {
+		pr_err("snd_soc_dai_set_sysclk err=%d\n", ret);
+		return ret;
+	}
+
+	ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_CBS_CFS |
+				  SND_SOC_DAIFMT_I2S |
+				  SND_SOC_DAIFMT_NB_NF);
+	if (ret) {
+		pr_err("snd_soc_dai_set_fmt err=%d\n", ret);
+		return ret;
+	}
+
+	return ret;
+}
+
+static int rza2menv_hw_free(struct snd_pcm_substream *substream)
+{
+	return 0;
+}
+
+static const struct snd_soc_ops rza2menv_dai_ops = {
+	.hw_params = rza2menv_hw_params,
+	.hw_free = rza2menv_hw_free,
+};
+
+#if 1
+static int rza2menv_dai_init(struct snd_soc_pcm_runtime *rtd)
+{
+	struct snd_soc_component *component = rtd->codec_dai->component;
+	struct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);
+
+	int ret;
+
+	FNC_ENTRY
+
+	/* Add controls */
+	ret = snd_soc_add_card_controls(rtd->card, playback_controls,
+					ARRAY_SIZE(playback_controls));
+	if (ret) {
+		pr_err("snd_soc_add_card_controls(playback) err=%d\n", ret);
+		return ret;
+	}
+
+	ret = snd_soc_add_card_controls(rtd->card, capture_controls,
+					ARRAY_SIZE(capture_controls));
+	if (ret) {
+		pr_err("snd_soc_add_card_controls(capture) err=%d\n", ret);
+		return ret;
+	}
+
+	/* Add widget and route for scu */
+	ret = snd_soc_dapm_new_controls(dapm, rza2menv_dapm_widgets,
+					ARRAY_SIZE(rza2menv_dapm_widgets));
+	if (ret) {
+		pr_err("snd_soc_dapm_new_controls err=%d\n", ret);
+		return ret;
+	}
+
+	ret = snd_soc_dapm_add_routes(dapm, audio_map, ARRAY_SIZE(audio_map));
+	if (ret) {
+		pr_err("snd_soc_dapm_add_routes err=%d\n", ret);
+		return ret;
+	}
+
+	scu_playback_route_control(dapm);
+	scu_capture_route_control(dapm);
+
+	FNC_EXIT
+	return ret;
+}
+#endif // 0
+/* rza2menv digital audio interface glue - connects codec <--> CPU */
+static struct snd_soc_dai_link rza2menv_dai = {
+	.name		= "wm8978",		/* Codec name */
+	.stream_name	= "WM8978",		/* Stream name */
+	.cpu_dai_name	= "rza2-ssi-dai",	/* DAI name of the CPU DAI*/
+//	.cpu_dai_name	= "rza2-pcm-audio.0",	/* DAI name of the CPU DAI*/
+	.codec_dai_name	= "wm8978-hifi",	/* DAI name within the codec */
+	.platform_name	= "rza2-pcm-audio.0",	/* device name */
+#if (defined(CONFIG_SPI_MASTER) && defined(CONFIG_MACH_RZA2MEVB))
+	.codec_name	= "spi0.0",		/* device name */
+#else
+	.codec_name	= "wm8978.0-001a",	/* device name */
+#endif
+	.dai_fmt = SND_SOC_DAIFMT_NB_IF | SND_SOC_DAIFMT_I2S |
+		   SND_SOC_DAIFMT_CBS_CFS,
+	.ops		= &rza2menv_dai_ops,	/* machine stream operations */
+	.init		= rza2menv_dai_init,	/* machine specific init */
+};
+
+/* rza2menv audio machine driver */
+static struct snd_soc_card snd_soc_rza2menv = {
+	.name = "rza2menv-wm8978",
+	.owner = THIS_MODULE,
+	.dai_link = &rza2menv_dai,
+	.num_links = 1,
+
+	.dapm_widgets = rza2menv_dapm_widgets,
+	.num_dapm_widgets = ARRAY_SIZE(rza2menv_dapm_widgets),
+	.dapm_routes = audio_map,
+	.num_dapm_routes = ARRAY_SIZE(audio_map),
+};
+
+static int rza2menv_probe(struct platform_device *pdev)
+{
+	int ret = -ENOMEM;
+
+	FNC_ENTRY
+
+	routeinfo = scu_get_route_info();
+
+	snd_soc_rza2menv.dev = &pdev->dev;
+	ret = snd_soc_register_card(&snd_soc_rza2menv);
+
+	if (ret)
+		pr_err("Unable to register sound card\n");
+
+	FNC_EXIT
+	return ret;
+}
+
+static struct platform_driver rza2menv_alsa_driver = {
+	.driver = {
+		.name = "rza2menv_alsa_soc_platform",
+		.owner = THIS_MODULE,
+		.of_match_table = rza2_snd_of_match,
+	},
+	.probe = rza2menv_probe,
+};
+
+module_platform_driver(rza2menv_alsa_driver);
+
+MODULE_AUTHOR(" Renesas Solutions Corp.");
+MODULE_DESCRIPTION("ALSA SoC rza2mevb");
+MODULE_LICENSE("GPL v2");
